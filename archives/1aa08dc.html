<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="不断提高自己认知，不断的为自己想要的努力"><title>Java动态绑定机制 | fuchenxuan’ blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="/weixin.js"></script><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java动态绑定机制</h1><a id="logo" href="/.">fuchenxuan’ blog</a><p class="description">不断提高自己认知，不断的为自己想要的努力</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/" class="current"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/message/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java动态绑定机制</h1><div class="post-meta">Apr 7, 2015<span> | </span><span class="category"><a href="/categories/java/">java</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="archives/1aa08dc.html" href="/archives/1aa08dc.html#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>在Java方法调用的过程中，JVM是如何知道调用的是哪个类的方法源代码？ 这里面到底有什么内幕呢？ 这篇文章我们就将揭露JVM方法调用的<strong>静态(static binding) </strong>和<strong>动态绑定机制(auto binding) </strong>。</p>
<h4 id="静态绑定机制"><a href="#静态绑定机制" class="headerlink" title="静态绑定机制"></a><strong>静态绑定机制</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//被调用的类  </span></div><div class="line"><span class="keyword">package</span> hr.test;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;  </div><div class="line">              System.out.println(<span class="string">"Father— f1()"</span>);  </div><div class="line">      &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//调用静态方法  </span></div><div class="line"><span class="keyword">import</span> hr.test.Father;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCall</span></span>&#123;  </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </div><div class="line">            Father.f1(); <span class="comment">//调用静态方法  </span></div><div class="line">       &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的源代码中执行方法调用的语句(Father.f1())被编译器编译成了一条指令：invokestatic #13。我们看看JVM是如何处理这条指令的</p>
<pre><code>(1) 指令中的#13指的是StaticCall类的常量池中第13个常量表的索引项(关于常量池详见《[Class文件内容及常量池](http://hxraid.iteye.com/blog/687660) 》)。这个常量表(**CONSTATN_Methodref_info** ) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到方法f1所在的类的全限定名: hr.test.Father。

(2) 紧接着JVM会加载、链接和初始化Father类。

(3) 然后在Father类所在的方法区中找到f1()方法的直接地址，并将这个直接地址记录到StaticCall类的常量池索引为13的常量表中。这个过程叫**常量池解析 **，以后再次调用Father.f1()时，将直接找到f1方法的字节码。

(4) 完成了StaticCall类常量池索引项13的常量表的解析之后，JVM就可以调用f1()方法，并开始解释执行f1()方法中的指令了。

通过上面的过程，我们发现经过常量池解析之后，JVM就能够确定要调用的f1()方法具体在内存的什么位置上了。实际上，这个信息在编译阶段就已经在StaticCall类的常量池中记录了下来。这种在编译阶段就能够确定调用哪个方法的方式，我们叫做 **静态绑定机制 **。

除了被static 修饰的静态方法，所有被private 修饰的私有方法、被final 修饰的禁止子类覆盖的方法都会被编译成invokestatic指令。另外所有类的初始化方法和会被编译成invokespecial指令。JVM会采用静态绑定机制来顺利的调用这些方法。
</code></pre><h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a><strong>动态绑定机制</strong></h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> package hr.test;  </div><div class="line"><span class="number">2.</span> <span class="comment">//被调用的父类  </span></div><div class="line"><span class="number">3.</span> <span class="keyword">class</span> <span class="title">Father</span>&#123;  </div><div class="line"><span class="number">4.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;  </div><div class="line"><span class="number">5.</span>         System.<span class="keyword">out</span>.println(<span class="string">"father-f1()"</span>);  </div><div class="line"><span class="number">6.</span>     &#125;  </div><div class="line"><span class="number">7.</span>         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">int</span> i</span>)</span>&#123;  </div><div class="line"><span class="number">8.</span>                 System.<span class="keyword">out</span>.println(<span class="string">"father-f1()  para-int "</span>+i);  </div><div class="line"><span class="number">9.</span>         &#125;  </div><div class="line"><span class="number">10.</span> &#125;  </div><div class="line"><span class="number">11.</span> <span class="comment">//被调用的子类  </span></div><div class="line"><span class="number">12.</span> <span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;  </div><div class="line"><span class="number">13.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123; <span class="comment">//覆盖父类的方法  </span></div><div class="line"><span class="number">14.</span>         System.<span class="keyword">out</span>.println(<span class="string">"Son-f1()"</span>);  </div><div class="line"><span class="number">15.</span>     &#125;  </div><div class="line"><span class="number">16.</span>         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">char</span> c</span>)</span>&#123;  </div><div class="line"><span class="number">17.</span>                 System.<span class="keyword">out</span>.println(<span class="string">"Son-s1() para-char "</span>+c);  </div><div class="line"><span class="number">18.</span>         &#125;  </div><div class="line"><span class="number">19.</span> &#125;  </div><div class="line"><span class="number">20.</span>   </div><div class="line"><span class="number">21.</span> <span class="comment">//调用方法  </span></div><div class="line"><span class="number">22.</span> import hr.test.*;  </div><div class="line"><span class="number">23.</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutoCall</span>&#123;  </div><div class="line"><span class="number">24.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;  </div><div class="line"><span class="number">25.</span>         Father father=<span class="keyword">new</span> Son(); <span class="comment">//多态  </span></div><div class="line"><span class="number">26.</span>         father.f1(); <span class="comment">//打印结果： Son-f1()  </span></div><div class="line"><span class="number">27.</span>     &#125;  </div><div class="line"><span class="number">28.</span> &#125;</div></pre></td></tr></table></figure>
<pre><code>上面的源代码中有三个重要的概念：**多态(polymorphism) **、**方法覆盖 、方法重载 **。打印的结果大家也都比较清楚，但是JVM是如何知道f.f1()调用的是子类Sun中方法而不是Father中的方法呢？在解释这个问题之前，我们首先简单的讲下JVM管理的一个非常重要的数据结构——**方法表 **。

 在JVM加载类的同时，会在方法区中为这个类存放很多信息(详见《[Java 虚拟机体系结构](http://hxraid.iteye.com/blog/676235) 》)。其中就有一个数据结构叫方法表。它以数组的形式记录了当前类及其所有超类的可见方法字节码在内存中的直接地址 。下图是上面源代码中Father和Sun类在方法区中的方法表：
</code></pre><p><img src="http://hxraid.iteye.com/upload/picture/pic/65417/ab4e5838-83f6-34a4-9dfc-a1b93e1ff02c.jpg" alt=""></p>
<p>上图中的方法表有两个特点：<br>(1) 子类方法表中继承了父类的方法，比如Father extends Object。<br>(2) 相同的方法(相同的方法签名：方法名和参数列表)在所有类的方法表中的索引相同。比如Father方法表中的f1()和Son方法表中的f1()都位于各自方法表的第11项中。<br>对于上面的源代码，编译器首先会把main方法编译成下面的字节码指令：<br>多态调用的字节码指令代码 </p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="number">0</span>  new hr.test.Son [<span class="number">13</span>] <span class="comment">//在堆中开辟一个Son对象的内存空间，并将对象引用压入操作数栈  </span></div><div class="line"><span class="number">2.</span> <span class="number">3</span>  dup    </div><div class="line"><span class="number">3.</span> <span class="number">4</span>  invokespecial #<span class="number">7</span> [<span class="number">15</span>] <span class="comment">// 调用初始化方法来初始化堆中的Son对象   </span></div><div class="line"><span class="number">4.</span> <span class="number">7</span>  astore_1 <span class="comment">//弹出操作数栈的Son对象引用压入局部变量1中  </span></div><div class="line"><span class="number">5.</span> <span class="number">8</span>  aload_1 <span class="comment">//取出局部变量1中的对象引用压入操作数栈  </span></div><div class="line"><span class="number">6.</span> <span class="number">9</span>  invokevirtual #<span class="number">15</span> <span class="comment">//调用f1()方法  </span></div><div class="line"><span class="number">7.</span> <span class="number">12</span>  return</div></pre></td></tr></table></figure>
<p> 其中invokevirtual指令的详细调用过程是这样的：<br> (1) invokevirtual指令中的#15指的是AutoCall类的常量池中第15个常量表的索引项。这个常量表(<strong>CONSTATN_Methodref_info</strong> ) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到调用方法f1的类的全限定名: hr.test.Father。这是因为调用方法f1的类的对象father声明为Father类型。<br>(2) 在Father类型的方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项11(如上图)记录到AutoCall类的常量池中第15个常量表中(<strong>常量池解析 </strong>)。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。<br>(3) 在调用invokevirtual指令前有一个aload_1指令，它会将开始创建在堆中的Son对象的引用压入操作数栈。然后invokevirtual指令会根据这个Son对象的引用首先找到堆中的Son对象，然后进一步找到Son对象所属类型的方法表。过程如下图所示：</p>
<pre><code>              ![](/images/4f775e04-3dd2-34bb-bb44-086d5743ee4c.jpg)

(4) 这是通过第(2)步中解析完成的#15常量表中的方法表的索引项11，可以定位到Son类型方法表中的方法f1()，然后通过直接地址找到该方法字节码所在的内存空间。

很明显，根据对象(father)的声明类型(Father)还不能够确定调用方法f1的位置，必须根据father在堆中实际创建的对象类型Son来确定f1方法所在的位置。这种在程序运行过程中，通过动态创建的对象的方法表来定位方法的方式，我们叫做 **动态绑定机制 **。

上面的过程很清楚的反映出在方法覆盖的多态调用的情况下，JVM是如何定位到准确的方法的。但是下面的调用方法JVM是如何定位的呢？(仍然使用上面代码中的Father和Son类型)
</code></pre><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutoCall</span>&#123;  </div><div class="line"><span class="number">2.</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;  </div><div class="line"><span class="number">3.</span>              Father father=<span class="keyword">new</span> Son();  </div><div class="line"><span class="number">4.</span>              <span class="keyword">char</span> c=<span class="string">'a'</span>;  </div><div class="line"><span class="number">5.</span>              father.f1(c); <span class="comment">//打印结果：father-f1()  para-int 97  </span></div><div class="line"><span class="number">6.</span>        &#125;  </div><div class="line"><span class="number">7.</span> &#125;</div></pre></td></tr></table></figure>
<pre><code> 问题是Fahter类型中并没有方法签名为f1(char)的方法呀。但打印结果显示JVM调用了Father类型中的f1(int)方法，并没有调用到Son类型中的f1(char)方法。

 根据上面详细阐述的调用过程，首先可以明确的是：JVM首先是根据对象father声明的类型Father来解析常量池的(也就是用Father方法表中的索引项来代替常量池中的符号引用)。如果Father中没有匹配到&quot;合适&quot; 的方法，就无法进行常量池解析，这在编译阶段就通过不了。

那么什么叫&quot;合适&quot;的方法呢？当然，方法签名完全一样的方法自然是合适的。但是如果方法中的参数类型在声明的类型中并不能找到呢？比如上面的代码中调用father.f1(char)，Father类型并没有f1(char)的方法签名。实际上，JVM会找到一种“凑合”的办法，就是通过 **参数的自动转型 **来找 到“合适”的 方法。比如char可以通过自动转型成int，那么Father类中就可以匹配到这个方法了 (关于Java的自动转型问题可以参见《[【解惑】Java类型间的转型](http://hxraid.iteye.com/blog/466997)》)。但是还有一个问题，如果通过自动转型发现可以“凑合”出两个方法的话怎么办？比如下面的代码：
</code></pre><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="keyword">class</span> <span class="title">Father</span>&#123;  </div><div class="line"><span class="number">2.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params">Object o</span>)</span>&#123;  </div><div class="line"><span class="number">3.</span>         System.<span class="keyword">out</span>.println(<span class="string">"Object"</span>);  </div><div class="line"><span class="number">4.</span>     &#125;  </div><div class="line"><span class="number">5.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">double</span>[] d</span>)</span>&#123;  </div><div class="line"><span class="number">6.</span>         System.<span class="keyword">out</span>.println(<span class="string">"double[]"</span>);  </div><div class="line"><span class="number">7.</span>     &#125;  </div><div class="line"><span class="number">8.</span>       </div><div class="line"><span class="number">9.</span> &#125;  </div><div class="line"><span class="number">10.</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span>&#123;  </div><div class="line"><span class="number">11.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </div><div class="line"><span class="number">12.</span>         <span class="keyword">new</span> Father().f1(<span class="literal">null</span>); <span class="comment">//打印结果： double[]  </span></div><div class="line"><span class="number">13.</span>     &#125;  </div><div class="line"><span class="number">14.</span> &#125;</div></pre></td></tr></table></figure>
<pre><code>null可以引用于任何的引用类型，那么JVM如何确定“合适”的方法呢。一个很重要的标准就是：如果一个方法可以接受传递给另一个方法的任何参数，那么第一个方法就相对不合适。比如上面的代码: 任何传递给f1(double[])方法的参数都可以传递给f1(Object)方法，而反之却不行，那么f1(double[])方法就更合适。因此JVM就会调用这个更合适的方法。
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>(1) 所有私有方法、静态方法、构造器及初始化方法都是采用静态绑定机制。在编译器阶段就已经指明了调用方法在常量池中的符号引用，JVM运行的时候只需要进行一次常量池解析即可。<br>(2) 类对象方法的调用必须在运行过程中采用动态绑定机制。<br> 首先，根据对象的声明类型(对象引用的类型)找到“合适”的方法。具体步骤如下：<br>① 如果能在声明类型中匹配到方法签名完全一样(参数类型一致)的方法，那么这个方法是最合适的。<br>② 在第①条不能满足的情况下，寻找可以“凑合”的方法。标准就是通过将参数类型进行自动转型之后再进行匹配。如果匹配到多个自动转型后的方法签名f(A)和f(B)，则用下面的标准来确定合适的方法：传递给f(A)方法的参数都可以传递给f(B)，则f(A)最合适。反之f(B)最合适 。<br> ③ 如果仍然在声明类型中找不到“合适”的方法，则编译阶段就无法通过。然后，根据在堆中创建对象的实际类型找到对应的方法表，从中确定具体的方法在内存中的位置。</p>
<h4 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h4><p>一个实例方法可以覆写（override）在其超类中可访问到的具有相同签名的所有实例方法，从而使能了动态分派（dynamic dispatch）；换句话说，VM将基于实例的运行期类型来选择要调用的覆写方法。覆写是面向对象编程技术的基础，并且是唯一没有被普遍劝阻的名字重用形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;  </div><div class="line">      public void f()&#123;&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;  </div><div class="line">      public void f()&#123;&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><p>一个域、静态方法或成员类型可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名)的所有域、静态方法或成员类型。隐藏一个成员将阻止其被继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;  </div><div class="line">	      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">	&#125;  </div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span>  </span>&#123;  </div><div class="line">	       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;   <span class="comment">//hides Base. f()  </span></div><div class="line">	 &#125;</div></pre></td></tr></table></figure>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>在某个类中的方法可以重载（overload）另一个方法，只要它们具有相同的名字和不同的签名。由调用所指定的重载方法是在编译期选定的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">CircuitBreaker</span>&#123;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span> (<span class="params"><span class="keyword">int</span> i</span>)</span>&#123;&#125;    <span class="comment">//int overloading  </span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="params">String s</span>)</span>&#123;&#125;   <span class="comment">//String overloading  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="遮蔽"><a href="#遮蔽" class="headerlink" title="遮蔽"></a>遮蔽</h4><p>一个变量、方法或类型可以分别遮蔽（shadow）在一个闭合的文本范围内的具有相同名字的所有变量、方法或类型。如果一个实体被遮蔽了，那么你用它的简单名是无法引用到它的;根据实体的不同，有时你根本就无法引用到它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class WhoKnows&#123;  </div><div class="line">    <span class="keyword">static</span> <span class="built_in">String</span> sentence=”I don<span class="symbol">'t</span> know.”;  </div><div class="line">    public <span class="keyword">static</span> void main(<span class="built_in">String</span>[] args〕&#123;  </div><div class="line">           <span class="built_in">String</span> sentence=”I don<span class="symbol">'t</span> know.”;  <span class="comment">//shadows static field  </span></div><div class="line">           System.out. println (sentence);  <span class="comment">// prints local variable  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>尽管遮蔽通常是被劝阻的，但是有一种通用的惯用法确实涉及遮蔽。构造器经常将来自其所在类的某个域名重用为一个参数，以传递这个命名域的值。这种惯用法并不是没有风险，但是大多数Java程序员都认为这种风格带来的实惠要超过其风险:</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Belt&#123;  </div><div class="line">      <span class="keyword">private</span> <span class="built_in">find</span> <span class="keyword">int</span> <span class="built_in">size</span> ;  <span class="comment">//Parameter shadows Belt. size  </span></div><div class="line">      <span class="keyword">public</span> Belt (<span class="keyword">int</span> <span class="built_in">size</span>)&#123;  </div><div class="line">           <span class="keyword">this</span>. <span class="built_in">size</span>=<span class="built_in">size</span>;  </div><div class="line">      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="遮掩"><a href="#遮掩" class="headerlink" title="遮掩"></a>遮掩</h4><p>一个变量可以遮掩具有相同名字的一个类型，只要它们都在同一个范围内:如果这个名字被用于变量与类型都被许可的范围，那么它将引用到变量上。相似地，一个变量或一个类型可以遮掩一个包。遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式，这些名字空间包括:变量、包、方法或类型。如果一个类型或一个包被遮掩了，那么你不能通过其简单<br>名引用到它，除非是在这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字。遵守命名习惯就可以极大地消除产生遮掩的可能性:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Obscure&#123;  </div><div class="line">      <span class="keyword">static</span> <span class="keyword">String</span> System;<span class="comment">// Obscures type java.lang.System  </span></div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)  </div><div class="line">            <span class="comment">// Next line won't compile:System refers to static field  </span></div><div class="line">            System. out. <span class="built_in">println</span>(“hello, obscure world!”);  </div><div class="line">      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a href="/archives/158db06e.html" class="pre">深入理解Handler原理</a><a href="/archives/394d1a7f.html" class="next">计算机网络体系分类</a></div><div id="disqus_thread"><script>var disqus_shortname = 'fushenghua';
var disqus_identifier = 'archives/1aa08dc.html';
var disqus_title = 'Java动态绑定机制';
var disqus_url = 'http://fushenghua.github.io/archives/1aa08dc.html';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//fushenghua.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://fushenghua.github.io"/></form></div><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://fushenghua.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础技能/">基础技能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码/">源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/archives/3e3728fd.html">为什么说枚举更占内存，枚举原理是什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/ed6915f6.html">在Pypi上发布自己的Python包</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/a9cc5307.html">ART 和 Dalvik的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/db6d97a8.html">APK 瘦身，减少APK体积的大小</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/a72a1e10.html">app安全之Apk完整性校验</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/8e05eece.html">git仓库迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/5f794a45.html">EventBus解析</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/235d5e38.html">ViewStub原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/c66eed35.html">优化Gradle 依赖使用方式</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/375726b.html">版本管理发布流程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//fushenghua.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">fuchenxuan’ blog</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/weixin.js"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>