<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="不断提高自己认知，不断的为自己想要的努力"><title>EventBus解析 | fuchenxuan’ blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="/weixin.js"></script><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">EventBus解析</h1><a id="logo" href="/.">fuchenxuan’ blog</a><p class="description">不断提高自己认知，不断的为自己想要的努力</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/" class="current"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/message/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">EventBus解析</h1><div class="post-meta">Jun 7, 2016<span> | </span><span class="category"><a href="/categories/源码/">源码</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="archives/5f794a45.html" href="/archives/5f794a45.html#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。</p>
<p>作为一个消息总线主要有三个组成部分：</p>
<p>事件（Event）：可以是任意类型的对象。通过事件的发布者将事件进行传递。</p>
<p>事件订阅者（Subscriber）：接收特定的事件。</p>
<p>事件发布者（Publisher）：用于通知 Subscriber 有事件发生。可以在任意线程任意位置发送事件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-42b1c487b9640141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>上图解释了整个EventBus的大概工作流程：事件的发布者（Publisher）将事件（Event）通过post()方法发送。EventBus内部进行处理，找到订阅了该事件（Event）的事件订阅者（Subscriber）。然后该事件的订阅者（Subscriber）通过onEvent()方法接收事件进行相关处理（关于onEvent()在EventBus 3.0中有改动，下面详细说明）。</p>
<h2 id="二、EventBus的简单使用"><a href="#二、EventBus的简单使用" class="headerlink" title="二、EventBus的简单使用"></a>二、EventBus的简单使用</h2><p>1、把EventBus依赖到项目</p>
<p>build.gradle添加引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'de.greenrobot:eventbus:3.0.0-beta1'</span></div></pre></td></tr></table></figure>
<p>2、构造事件（Event）对象。也就是发送消息类<br>每一个消息类，对应一种事件。这里我们定义两个消息发送类。后面讲解具体作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewsEvent</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToastEvent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、注册/解除事件订阅（Subscriber）</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus<span class="selector-class">.getDefault</span>()<span class="selector-class">.register</span>(this);<span class="comment">//注册事件 其中this代表订阅者</span></div></pre></td></tr></table></figure>
<p>具体注册了对什么事件的订阅，这个需要onEvent()方法来说明。在EventBus 3.0之前，onEvent()方法是用来接收指定事件（Event）类型对象，然后进行相关处理操作。在EventBus 3.0之后，onEvent()方法可以自定义方法名，不过要加入注解@Subscribe。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过register(this)来表示该订阅者进行了订阅，通过onToastEvent(ToastEvent event)表示指定对事件ToastEvent的订阅。到这里订阅就完成了。</p>
<p>需要注意的是：一般在onCreate()方法中进行注册订阅。在onDestory()方法中进行解除订阅。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>4 、发送消息<br>订阅已经完成，那么便可以发送订阅了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> ToastEvent(<span class="string">"Toast,发个提示，祝大家新年快乐！"</span>));</div></pre></td></tr></table></figure>
<p>那么onToastEvent(ToastEvent event)会收到事件，并弹出提示。</p>
<p>EventBus的基础使用流程就是这样的。</p>
<p>其实，EventBus还有好多其他的功能。下面我们一个个介绍。</p>
<h2 id="三、EventBus的进阶使用"><a href="#三、EventBus的进阶使用" class="headerlink" title="三、EventBus的进阶使用"></a>三、EventBus的进阶使用</h2><h5 id="1-线程模式ThreadMode"><a href="#1-线程模式ThreadMode" class="headerlink" title="1.线程模式ThreadMode"></a>1.线程模式ThreadMode</h5><p>当你接收的的事件后，如果处于非UI线程，你要更新UI怎么办？如果处于UI线程，你要进行耗时操作，怎么办?等等其他情况，通过ThreadMode统统帮你解决。</p>
<p>用法展示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@Subscribe</span>(threadMode = ThreadMode.MainThread)</div><div class="line">    public void  onNewsEvent(NewsEvent event)&#123;</div><div class="line">        String message = event<span class="selector-class">.getMessage</span>();</div><div class="line">        mTv_message<span class="selector-class">.setText</span>(message);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用起来很简单，通过<code>@Subscribe(threadMode = ThreadMode.MainThread)</code>即可指定。<br>下面具体介绍下ThreadMode。</p>
<p>关于ThreadMode，一共有四种模式PostThread，PostThread，BackgroundThread以及Async。</p>
<p><strong>PostThread：</strong>事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程。</p>
<p><strong>MainThread: </strong>事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的。</p>
<p><strong>BackgroundThread：</strong>如果事件是在UI线程中发布出来的，那么事件处理就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么事件处理直接在该子线程中执行。所有待处理事件会被加到一个队列中，由对应线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。</p>
<p><strong>Async：</strong>事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程。</p>
<h5 id="2-priority事件优先级"><a href="#2-priority事件优先级" class="headerlink" title="2.priority事件优先级"></a>2.priority事件优先级</h5><p>事件的优先级类似广播的优先级，优先级越高优先获得消息。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当多个订阅者（Subscriber）对同一种事件类型进行订阅时，即对应的事件处理方法中接收的事件类型一致，则<strong>优先级高（priority 设置的值越大），则会先接收事件进行处理；优先级低（priority 设置的值越小），则会后接收事件进行处理。</strong></p>
<p>除此之外，EventBus也可以终止对事件继续传递的功能。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">       Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">       EventBus.getDefault().cancelEventDelivery(event);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这样其他优先级比100低，并且订阅了该事件的订阅者就会接收不到该事件。</p>
<h5 id="3-EventBus黏性事件"><a href="#3-EventBus黏性事件" class="headerlink" title="3.EventBus黏性事件"></a>3.EventBus黏性事件</h5><p>EventBus除了普通事件也支持粘性事件。可以理解成：订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅的方法有所不同，需要注解中添加sticky = true。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>,sticky = <span class="keyword">true</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">        EventBus.getDefault().cancelEventDelivery(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这样，假设一个ToastEvent 的事件已经发布，此时还没有注册订阅。当设置了sticky = true，在ToastEvent 的事件发布后，进行注册。依然能够接收到之前发布的事件。</p>
<p>不过这个时候，发布事件的方式就改变了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().postSticky(<span class="keyword">new</span> ToastEvent(<span class="string">"Toast,发个提示，祝大家新年快乐！"</span>));</div></pre></td></tr></table></figure>
<p>我们如果不再需要该粘性事件我们可以移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().removeStickyEvent(ToastEvent.class);</div></pre></td></tr></table></figure>
<p>或者调用移除所有粘性事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().removeAllStickyEvents();</div></pre></td></tr></table></figure>
<h5 id="4-EventBus配置"><a href="#4-EventBus配置" class="headerlink" title="4.EventBus配置"></a>4.EventBus配置</h5><p>EventBus在2.3版本中添加了EventBuilder去配置EventBus的各方各面。</p>
<p>比如：如何去构建一个在发布事件时没有订阅者时保持沉默的EventBus。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventBus eventBus = EventBus.builder()</div><div class="line">.logNoSubscriberMessages(<span class="keyword">false</span>)</div><div class="line">.sendNoSubscriberEvent(<span class="keyword">false</span>)</div><div class="line">.build();</div></pre></td></tr></table></figure>
<p>通过上述设置，当一个事件没有订阅者时，不会输出log信息，也不会发布一条默认信息。</p>
<p>配置默认的EventBus实例，使用EventBus.getDefault()是一个简单的方法。获取一个单例的EventBus实例。EventBusBuilder也允许使用installDefaultEventBus方法去配置默认的EventBus实例。</p>
<p><strong>注意：不同的EventBus 的对象的数据是不共享的。通过一个EventBus 对象去发布事件，只有通过同一个EventBus 对象订阅事件，才能接收该事件。所以以上使用EventBus.getDefault()获得的都是同一个实例。</strong></p>
<h2 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h2><p><code>EventBus</code>实现了观察者模式，使用方法非常简单</p>
<p>下面文章主要讲解EventBus的实现原理。<br>EventBus内部有一个map，当register时往map中增加一个元素(key为事件的类型，value为观察者)，post时根据事件类型找到观察者之后，对其反射调用。<br>下面我们从register方法开始：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span>(<span class="params">Object <span class="keyword">object</span></span>) </span>&#123;</div><div class="line">    Multimap, EventHandler&gt; methodsInListener =</div><div class="line">        finder.findAllHandlers(<span class="keyword">object</span>);</div><div class="line">    handlersByTypeLock.writeLock().<span class="keyword">lock</span>();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      handlersByType.putAll(methodsInListener);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      handlersByTypeLock.writeLock().unlock();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用eventBus.register(new Event())时，会将事件类型及观察者(封装为EventHandler)放置在SetMultimap, EventHandler&gt; handlersByType中，这是一个线程安全的对象容器，卸载事件也是在这个容器中做移除操作。根据事件类型查找观察者时使用了策略模式，HandlerFindingStrategy finder做为策略接口，目前只有一个策略实现AnnotatedHandlerFinder(查找带有Subscribe注解的方法)。<br>有了这样一个map，调用post时只需要根据类型找到观察者就行了：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span>(<span class="params">Object <span class="keyword">event</span></span>) </span>&#123;</div><div class="line">    Set&gt; dispatchTypes = flattenHierarchy(<span class="keyword">event</span>.getClass());</div><div class="line"></div><div class="line">    boolean dispatched = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (Class eventType : dispatchTypes) &#123;</div><div class="line">      handlersByTypeLock.readLock().<span class="keyword">lock</span>();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Set wrappers = handlersByType.<span class="keyword">get</span>(eventType);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!wrappers.isEmpty()) &#123;</div><div class="line">          dispatched = <span class="literal">true</span>;</div><div class="line">          <span class="keyword">for</span> (EventHandler wrapper : wrappers) &#123;</div><div class="line">            enqueueEvent(<span class="keyword">event</span>, wrapper);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        handlersByTypeLock.readLock().unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dispatched &amp;&amp; !(<span class="keyword">event</span> instanceof DeadEvent)) &#123;</div><div class="line">      post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, <span class="keyword">event</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispatchQueuedEvents();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里查找到参数匹配的<code>EventHandler</code>后并没有立刻执行反射调用，而是分发到了事件队列<code>（ThreadLocal&gt; eventsToDispatch）</code>中，当所有事件分发完毕之后，事件队列做统一的事件消费。</p>
<p>下面是一些EventBus源码解析。</p>
<h3 id="getDefault"><a href="#getDefault" class="headerlink" title="getDefault()"></a>getDefault()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">                <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> defaultInstance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过上述代码可以得知，getDefault()中通过双检查锁（DCL）机制实现了EventBus的单例机制，获得了一个默认配置的EventBus对象。<br>下面我们继续看register()方法。</p>
<h3 id="register"><a href="#register" class="headerlink" title="register()"></a>register()</h3><p>在了解register()之前，我们先要了解一下EventBus中的几个关键的成员变量。方便对下面内容的理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Map&lt;订阅事件, 订阅该事件的订阅者集合&gt; */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</div><div class="line"></div><div class="line"><span class="comment">/** Map&lt;订阅者, 订阅事件集合&gt; */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</div><div class="line"></div><div class="line"><span class="comment">/** Map&lt;订阅事件类类型,订阅事件实例对象&gt;. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</div></pre></td></tr></table></figure>
<p>下面看具体的register()中执行的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">        <span class="comment">//订阅者类型</span></div><div class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass(); </div><div class="line">        <span class="comment">//判断该类是不是匿名类，如果是匿名累要使用反射</span></div><div class="line">        <span class="keyword">boolean</span> forceReflection = subscriberClass.isAnonymousClass();</div><div class="line">        <span class="comment">//获取订阅者全部的响应函数信息（即上面的onNewsEvent()之类的方法）</span></div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods =</div><div class="line">                subscriberMethodFinder.findSubscriberMethods(subscriberClass, forceReflection);</div><div class="line">        <span class="comment">//循环每一个事件响应函数，执行 subscribe()方法，更新订阅相关信息</span></div><div class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">            subscribe(subscriber, subscriberMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由此可见，register()第一步获取订阅者的类类型. 第二步,通过SubscriberMethodFinder类来解析订阅者类,获取所有的响应函数集合. 第三步,遍历订阅函数,执行 subscribe()方法，更新订阅相关信息。<br>关于 subscriberMethodFinder这里就不介绍了。先跟着线索，继续看subscribe()方法。<br>subscribe 函数分三步。</p>
<p>第一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//获取订阅的事件类型</span></div><div class="line">  Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line"> <span class="comment">//获取订阅该事件的订阅者集合</span></div><div class="line">  CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line"><span class="comment">//把通过register()订阅的订阅者包装成Subscription 对象</span></div><div class="line">  Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">  <span class="comment">//订阅者集合为空，创建新的集合，并把newSubscription 加入</span></div><div class="line">  <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</div><div class="line">      subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Subscription&gt;();</div><div class="line">      subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//集合中已经有该订阅者，抛出异常。不能重复订阅</span></div><div class="line">      <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">                  + eventType);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="comment">//把新的订阅者按照优先级加入到订阅者集合中。</span></div><div class="line">  <span class="keyword">synchronized</span> (subscriptions) &#123;</div><div class="line">      <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">          <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">              subscriptions.add(i, newSubscription);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>第二步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//根据订阅者，获得该订阅者订阅的事件类型集合</span></div><div class="line"> List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line"><span class="comment">//如果事件类型集合为空，创建新的集合，并加入新订阅的事件类型。</span></div><div class="line"> <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">     subscribedEvents = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</div><div class="line">     typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line"> &#125;</div><div class="line"><span class="comment">//如果事件类型集合不为空，加入新订阅的事件类型</span></div><div class="line"> subscribedEvents.add(eventType);</div></pre></td></tr></table></figure>
<p>第三步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该事件是stick=true。</span></div><div class="line"><span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">            <span class="comment">//响应订阅事件的父类事件</span></div><div class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">                <span class="comment">//循环获得每个stickyEvent事件</span></div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                    <span class="comment">//是该类的父类</span></div><div class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                         <span class="comment">//该事件类型最新的事件发送给当前订阅者。</span></div><div class="line">                        Object stickyEvent = entry.getValue();</div><div class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>由此可见，第一步：通过subscriptionsByEventType得到该事件类型所有订阅者信息队列，根据优先级将当前订阅者信息插入到订阅者队列subscriptionsByEventType中；</p>
<p>第二步：在typesBySubscriber中得到当前订阅者订阅的所有事件队列，将此事件保存到队列typesBySubscriber中，用于后续取消订阅；<br>第三步：检查这个事件是否是 Sticky 事件，如果是则从stickyEvents事件保存队列中取出该事件类型最后一个事件发送给当前订阅者。</p>
<p>到此，便完成了订阅功能。下面是订阅的具体流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-210bce35b60a5481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h3 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取该订阅者所有的订阅事件类类型集合.</span></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">            unsubscribeByEventType(subscriber, eventType);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 从typesBySubscriber删除该&lt;订阅者对象,订阅事件类类型集合&gt;</span></div><div class="line">        typesBySubscriber.remove(subscriber);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Log.e(<span class="string">"EventBus"</span>, <span class="string">"Subscriber to unregister was not registered before: "</span></div><div class="line">                + subscriber.getClass());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取订阅事件对应的订阅者信息集合.</span></div><div class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</div><div class="line">            Subscription subscription = subscriptions.get(i);</div><div class="line">            <span class="comment">// 从订阅者集合中删除特定的订阅者.</span></div><div class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</div><div class="line">                subscription.active = <span class="keyword">false</span>;</div><div class="line">                subscriptions.remove(i);</div><div class="line">                i --;</div><div class="line">                size --;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>unregister()方法比较简单，主要完成了subscriptionsByEventType以及typesBySubscriber两个集合的同步。</p>
<h3 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取当前线程的Posting状态.</span></div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    <span class="comment">// 获取当前线程的事件队列.</span></div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    <span class="comment">//将当前事件添加到其事件队列</span></div><div class="line">    eventQueue.add(event);</div><div class="line">    <span class="comment">//判断新加入的事件是否在分发中</span></div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">        postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 循环处理当前线程eventQueue中的每一个event对象.</span></div><div class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 处理完知乎重置postingState一些标识信息.</span></div><div class="line">            postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">            postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>post 函数会首先得到当前线程的 post 信息PostingThreadState，其中包含事件队列，将当前事件添加到其事件队列中，然后循环调用 postSingleEvent 函数发布队列中的每个事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> </span>&#123;</div><div class="line">   <span class="comment">//分发事件的类型</span></div><div class="line">    Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">   <span class="comment">//响应订阅事件的父类事件</span></div><div class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">        <span class="comment">//找出当前订阅事件类类型eventClass的所有父类的类类型和其实现的接口的类类型</span></div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h ++) &#123;</div><div class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">            <span class="comment">//发布每个事件到每个订阅者</span></div><div class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">    &#125;</div><div class="line">....................................</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 postSingleEventForEventType 函数发布每个事件到每个订阅者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState,</span></span></div><div class="line">                                            Class&lt;?&gt; eventClass) &#123;</div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 获取订阅事件类类型对应的订阅者信息集合.(register函数时构造的集合)</span></div><div class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">            postingState.event = event;</div><div class="line">            postingState.subscription = subscription;</div><div class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 发布订阅事件给订阅函数</span></div><div class="line">                postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                aborted = postingState.canceled;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postingState.event = <span class="keyword">null</span>;</div><div class="line">                postingState.subscription = <span class="keyword">null</span>;</div><div class="line">                postingState.canceled = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (aborted) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 postToSubscription 函数向每个订阅者发布事件。<br>postToSubscription 函数中会判断订阅者的 ThreadMode，从而决定在什么 Mode 下执行事件响应函数。这里就不贴源码了。后续还牵着到反射以及线程调度问题，这里就不展开了。<br>以上就是post的流程，下面是具体的post的流程图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-6567ff2602475d05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
</div><div class="tags"></div><div class="post-nav"><a href="/archives/8e05eece.html" class="pre">git仓库迁移</a><a href="/archives/235d5e38.html" class="next">ViewStub原理分析</a></div><div id="disqus_thread"><script>var disqus_shortname = 'fushenghua';
var disqus_identifier = 'archives/5f794a45.html';
var disqus_title = 'EventBus解析';
var disqus_url = 'http://fushenghua.github.io/archives/5f794a45.html';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//fushenghua.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://fushenghua.github.io"/></form></div><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://fushenghua.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础技能/">基础技能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码/">源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/archives/3e3728fd.html">为什么说枚举更占内存，枚举原理是什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/ed6915f6.html">在Pypi上发布自己的Python包</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/a9cc5307.html">ART 和 Dalvik的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/db6d97a8.html">APK 瘦身，减少APK体积的大小</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/a72a1e10.html">app安全之Apk完整性校验</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/8e05eece.html">git仓库迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/5f794a45.html">EventBus解析</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/235d5e38.html">ViewStub原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/c66eed35.html">优化Gradle 依赖使用方式</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/375726b.html">版本管理发布流程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//fushenghua.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">fuchenxuan’ blog</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/weixin.js"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>