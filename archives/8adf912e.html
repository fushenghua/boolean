<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="不断提高自己认知，不断的为自己想要的努力"><title>OkHttp 理解 | fuchenxuan’ blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="/weixin.js"></script><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">OkHttp 理解</h1><a id="logo" href="/.">fuchenxuan’ blog</a><p class="description">不断提高自己认知，不断的为自己想要的努力</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/" class="current"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/message/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">OkHttp 理解</h1><div class="post-meta">May 2, 2018<span> | </span><span class="category"><a href="/categories/android/">android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="archives/8adf912e.html" href="/archives/8adf912e.html#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>先从Okhttp3的请求实现说起（包括同步请求和异步请求）</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="同步请求："><a href="#同步请求：" class="headerlink" title="同步请求："></a>同步请求：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static final String DESTINATION_ADDRESS = &quot;https://github.com/soulrelay&quot;;</div><div class="line">OkHttpClient client = new OkHttpClient.Builder().build();</div><div class="line">Request request = new Request.Builder()</div><div class="line">        .url(DESTINATION_ADDRESS)</div><div class="line">        .build();</div><div class="line">Response response = client.newCall(request).execute();</div></pre></td></tr></table></figure>
<h2 id="异步请求："><a href="#异步请求：" class="headerlink" title="异步请求："></a>异步请求：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static final String DESTINATION_ADDRESS = &quot;https://github.com/soulrelay&quot;;</div><div class="line">OkHttpClient client = new OkHttpClient.Builder().build();</div><div class="line">Request request = new Request.Builder()</div><div class="line">        .url(DESTINATION_ADDRESS)</div><div class="line">        .build();</div><div class="line">client.newCall(request).enqueue(new Callback() &#123;</div><div class="line">    @Override</div><div class="line">    public void onFailure(Call call, IOException e) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><blockquote>
<ul>
<li>不管是同步请求还是异步请求，都需要初始化OkHttpClient以及创建一个Request，然后再调用OkHttpClinet的newCall方法，创建出一个RealCall对象</li>
<li>对于同步请求，是调用RealCall的execute方法；而异步请求，则是调用RealCall的enqueue方法实现</li>
</ul>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<ul>
<li>OkHttpCLient:在Okhttp库中，OkHttpClient处于一个中心者的地位，很多功能都需要通过它来转发或者实现的。在创建的时候，初始化了很多功能类，比如缓存，拦截器，网络连接池，分发器等类。 由于初始化比较复杂，OkHttpClient内部提供了Builder模式来创建，一般情况下，OkHttpClient是唯一的</li>
<li>Request:是用来构建一个请求对象的，符合Http请求的标准，包含了请求头，方法等等属性，较为复杂，因此同样提供Builder模式构建。</li>
<li>Response:是用来构建一个响应对象的，包含了响应头，响应码，数据等等属性，同样也提供Builder模式构建</li>
</ul>
</blockquote>
<h2 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 同步</div><div class="line">client.newCall(request).execute()</div><div class="line">// 异步</div><div class="line">client.newCall(request).enqueue(Callback)</div></pre></td></tr></table></figure>
<p>同步和异步请求，都是调用OkHttpClient的newCall方法创建一个RealCall对象，然后通过这个对象，执行请求的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public Call newCall(Request request) &#123;</div><div class="line">    return new RealCall(this, request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="execute-同步请求"><a href="#execute-同步请求" class="headerlink" title="execute 同步请求"></a>execute 同步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public Response execute() throws IOException &#123;</div><div class="line">     // 方法检测，execute只能调用1次</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">      executed = true;</div><div class="line">    &#125;</div><div class="line">    try &#123;</div><div class="line">       // 将RealCall添加到Dispatcher中的同步请求队列中</div><div class="line">      client.dispatcher().executed(this);</div><div class="line">       // 获取响应的数据</div><div class="line">       // Okhttp会对数据（请求流和响应流）进行拦截进行一些额外的处理，</div><div class="line">       // 比如失败重连，添加请求头，没网络优先返回缓存数据等等。</div><div class="line">       // 这一拦截过程，采用责任链模式来实现的，和Android中的事件传递机制差不多</div><div class="line">      Response result = getResponseWithInterceptorChain();</div><div class="line">      if (result == null) throw new IOException(&quot;Canceled&quot;);</div><div class="line">      return result;</div><div class="line">    &#125; finally &#123;</div><div class="line">       // 请求完成或者取消，都会将RealCall从同步请求队列中移除</div><div class="line">      client.dispatcher().finished(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="enqueue-异步请求"><a href="#enqueue-异步请求" class="headerlink" title="enqueue-异步请求"></a>enqueue-异步请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public void enqueue(Callback responseCallback) &#123;</div><div class="line">    // 和execute一样，enqueue也只能调用1次</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">      executed = true;</div><div class="line">    &#125;</div><div class="line">    // 执行请求</div><div class="line">    client.dispatcher().enqueue(new AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h2><p>AsyncCall–实际上是一个Runnable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public abstract class NamedRunnable implements Runnable &#123;</div><div class="line">  protected final String name;</div><div class="line"></div><div class="line">  public NamedRunnable(String format, Object... args) &#123;</div><div class="line">    this.name = Util.format(format, args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public final void run() &#123;</div><div class="line">    String oldName = Thread.currentThread().getName();</div><div class="line">    Thread.currentThread().setName(name);</div><div class="line">    try &#123;</div><div class="line">      execute();</div><div class="line">    &#125; finally &#123;</div><div class="line">      Thread.currentThread().setName(oldName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  protected abstract void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NamedRunnable，继承Runnable的抽象类，根据传入的名称来修改线程名称，抽象出执行任务的execute方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">final class AsyncCall extends NamedRunnable &#123;</div><div class="line">    // 其他省略，execute方法式真正执行请求</div><div class="line">    @Override protected void execute() &#123;</div><div class="line">      boolean signalledCallback = false;</div><div class="line">      try &#123;</div><div class="line">        Response response = getResponseWithInterceptorChain();</div><div class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">          signalledCallback = true;</div><div class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">        &#125; else &#123;</div><div class="line">          signalledCallback = true;</div><div class="line">          responseCallback.onResponse(RealCall.this, response);</div><div class="line">        &#125;</div><div class="line">      &#125; catch (IOException e) &#123;</div><div class="line">        if (signalledCallback) &#123;</div><div class="line">          // Do not signal the callback twice!</div><div class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</div><div class="line">        &#125; else &#123;</div><div class="line">          responseCallback.onFailure(RealCall.this, e);</div><div class="line">        &#125;</div><div class="line">      &#125; finally &#123;</div><div class="line">        client.dispatcher().finished(this);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AsyncCall中的execute方法，是请求任务执行的方法，获取相应数据最终也是调用了getResponseWithInterceptorChain方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private Response getResponseWithInterceptorChain() throws IOException &#123;</div><div class="line">    // Build a full stack of interceptors.</div><div class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">    interceptors.addAll(client.interceptors());</div><div class="line">    interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</div><div class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</div><div class="line">    interceptors.add(new ConnectInterceptor(client));</div><div class="line">    if (!retryAndFollowUpInterceptor.isForWebSocket()) &#123;</div><div class="line">      interceptors.addAll(client.networkInterceptors());</div><div class="line">    &#125;</div><div class="line">    interceptors.add(new CallServerInterceptor(</div><div class="line">        retryAndFollowUpInterceptor.isForWebSocket()));</div><div class="line"></div><div class="line">    Interceptor.Chain chain = new RealInterceptorChain(</div><div class="line">        interceptors, null, null, null, 0, originalRequest);</div><div class="line">    return chain.proceed(originalRequest);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>原理：</p>
<blockquote>
<ul>
<li>对于异步请求来说，Dispatcher类内部持有一个正在执行(运行中)异步任务的队列和一个等待执行(就绪)异步请求的队列，以及一个线程池</li>
<li>这个线程池，没有常存的核心线程，最多线程数为Integer.MAX_VALUE，线程空闲时存活时间为60秒，而SynchronousQueue <a href="https://github.com/soulrelay/InterviewMemoirs/issues/2" target="_blank" rel="external">#2</a> 是不保存任务的，所以只要把任务添加进去就会执行</li>
<li>OkHttp不是在线程池中维护线程的个数，线程是一直在Dispatcher中直接控制。线程池中的请求都是运行中的请求。这也就是说<strong>线程的重用不是线程池控制的，通过源码我们发现线程重用的地方是请求结束的地方finished(AsyncCall call) ，而真正的控制是通过promoteCalls方法</strong>， 根据maxRequests和maxRequestsPerHost来调整runningAsyncCalls和readyAsyncCalls，使运行中的异步请求不超过两种最大值，并且如果队列有空闲，将就绪状态的请求归类为运行中</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line">public final class Dispatcher &#123;</div><div class="line">  //最大请求数</div><div class="line">  private int maxRequests = 64;</div><div class="line">  //相同host最大请求数</div><div class="line">  private int maxRequestsPerHost = 5;</div><div class="line">  //请求执行，懒加载</div><div class="line">  private ExecutorService executorService;</div><div class="line">  //就绪状态的异步请求队列</div><div class="line">  private final Deque&lt;AsyncCall&gt; readyCalls = new ArrayDeque&lt;&gt;();</div><div class="line">  //运行中的异步请求队列</div><div class="line">  private final Deque&lt;AsyncCall&gt; runningCalls = new ArrayDeque&lt;&gt;();</div><div class="line">  //进行中的同步请求，包括那些尚未完成被取消的请求</div><div class="line">  private final Deque&lt;Call&gt; executedCalls = new ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">  public Dispatcher(ExecutorService executorService) &#123;</div><div class="line">    this.executorService = executorService;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public Dispatcher() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public synchronized ExecutorService getExecutorService() &#123;</div><div class="line">    if (executorService == null) &#123;</div><div class="line">       //corePoolSize 为 0表示，没有核心线程，所有执行请求的线程，使用完了如果过期了（keepAliveTime）就回收了,</div><div class="line">      //maximumPoolSize 无限大的线程池空间</div><div class="line">      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</div><div class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</div><div class="line">    &#125;</div><div class="line">    return executorService;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public synchronized void setMaxRequests(int maxRequests) &#123;</div><div class="line">    if (maxRequests &lt; 1) &#123;</div><div class="line">      throw new IllegalArgumentException(&quot;max &lt; 1: &quot; + maxRequests);</div><div class="line">    &#125;</div><div class="line">    this.maxRequests = maxRequests;</div><div class="line">    promoteCalls();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public synchronized int getMaxRequests() &#123;</div><div class="line">    return maxRequests;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) &#123;</div><div class="line">    if (maxRequestsPerHost &lt; 1) &#123;</div><div class="line">      throw new IllegalArgumentException(&quot;max &lt; 1: &quot; + maxRequestsPerHost);</div><div class="line">    &#125;</div><div class="line">    this.maxRequestsPerHost = maxRequestsPerHost;</div><div class="line">    promoteCalls();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public synchronized int getMaxRequestsPerHost() &#123;</div><div class="line">    return maxRequestsPerHost;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  synchronized void enqueue(AsyncCall call) &#123;</div><div class="line">    if (runningCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">      runningCalls.add(call);</div><div class="line">      getExecutorService().execute(call);</div><div class="line">    &#125; else &#123;</div><div class="line">      readyCalls.add(call);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //取消带有tag的所有请求</div><div class="line">  public synchronized void cancel(Object tag) &#123;</div><div class="line">    for (AsyncCall call : readyCalls) &#123;</div><div class="line">      if (Util.equal(tag, call.tag())) &#123;</div><div class="line">        call.cancel();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (AsyncCall call : runningCalls) &#123;</div><div class="line">      if (Util.equal(tag, call.tag())) &#123;</div><div class="line">        call.get().canceled = true;</div><div class="line">        HttpEngine engine = call.get().engine;</div><div class="line">        if (engine != null) engine.cancel();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (Call call : executedCalls) &#123;</div><div class="line">      if (Util.equal(tag, call.tag())) &#123;</div><div class="line">        call.cancel();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //异步请求结束</div><div class="line">  //当该异步请求结束的时候，会调用此方法，</div><div class="line">  //用于将运行中的异步请求队列中的该请求移除并调整请求队列</div><div class="line">  //此时就绪队列中的请求就可以进入运行中的队列</div><div class="line">  synchronized void finished(AsyncCall call) &#123;</div><div class="line">    if (!runningCalls.remove(call)) throw new AssertionError(&quot;AsyncCall wasn&apos;t running!&quot;);</div><div class="line">    promoteCalls();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //根据maxRequests和maxRequestsPerHost来调整</div><div class="line">  //runningAsyncCalls和readyAsyncCalls</div><div class="line">  //使运行中的异步请求不超过两种最大值</div><div class="line">  //并且如果队列有空闲，将就绪状态的请求归类为运行中。</div><div class="line">  private void promoteCalls() &#123;</div><div class="line">    //运行中的异步请求队列的请求数大于最大请求数，那么就没必要去将就绪状态的请求移动到运行中。</div><div class="line">    //其实就是说，如果有超过最大请求数的请求正在运行，是不需要将其移出队列的，继续运行完即可</div><div class="line">    if (runningCalls.size() &gt;= maxRequests) return;</div><div class="line">    //如果就绪的队列为空，那就更没有必要移动了，因为都没有。</div><div class="line">    if (readyCalls.isEmpty()) return; </div><div class="line">    //遍历就绪队列</div><div class="line">    for (Iterator&lt;AsyncCall&gt; i = readyCalls.iterator(); i.hasNext(); ) &#123;</div><div class="line">      //取出一个请求</div><div class="line">      AsyncCall call = i.next();</div><div class="line">      //如果当前请求对应的host下，没有超过maxRequestsPerHost</div><div class="line">      //那么将其从就绪队列中移除，并加入在运行队列。</div><div class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; </div><div class="line">        //移除        </div><div class="line">        i.remove();</div><div class="line">        //加入运行队列</div><div class="line">        runningCalls.add(call);</div><div class="line">        //立即执行该请求</div><div class="line">        getExecutorService().execute(call);</div><div class="line">      &#125;</div><div class="line">        //如果运行队列已经到达了最大请求数上限</div><div class="line">        //此时如果还有就绪中的请求，也不管了</div><div class="line">      if (runningCalls.size() &gt;= maxRequests) return; </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //对比已有的运行中的请求和当前请求的host</div><div class="line">  private int runningCallsForHost(AsyncCall call) &#123;</div><div class="line">    int result = 0;</div><div class="line">    for (AsyncCall c : runningCalls) &#123;</div><div class="line">      if (c.host().equals(call.host())) result++;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  synchronized void executed(Call call) &#123;</div><div class="line">    executedCalls.add(call);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //同步请求结束</div><div class="line">  //当该同步请求结束的时候，会调用此方法，</div><div class="line">  //用于将运行中的同步请求队列中的该请求移除</div><div class="line">  synchronized void finished(Call call) &#123;</div><div class="line">    if (!executedCalls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public synchronized int getRunningCallCount() &#123;</div><div class="line">    return runningCalls.size();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public synchronized int getQueuedCallCount() &#123;</div><div class="line">    return readyCalls.size();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a href="/archives/1dde1414.html" class="next">Android中的设计模式</a></div><div id="disqus_thread"><script>var disqus_shortname = 'fushenghua';
var disqus_identifier = 'archives/8adf912e.html';
var disqus_title = 'OkHttp 理解';
var disqus_url = 'http://fushenghua.github.io/archives/8adf912e.html';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//fushenghua.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://fushenghua.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础技能/">基础技能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码/">源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/archives/8adf912e.html">OkHttp 理解</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/1dde1414.html">Android中的设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/3e3728fd.html">为什么说枚举更占内存，枚举原理是什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/ed6915f6.html">在Pypi上发布自己的Python包</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/59f7e7f7.html">调试 ART 垃圾回收</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/59f7e7f7.html">配置ART</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/af68deab.html">INSTALL_FAILED_TEST_ONLY的原因</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/3dbdbf17.html">实现 ART 即时 (JIT) 编译器</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/3b12125.html">Android 8.0 中的 ART 功能改进</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/a9cc5307.html">ART 和 Dalvik的区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//fushenghua.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">fuchenxuan’ blog</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/weixin.js"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>