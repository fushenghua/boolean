<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fuchenxuan’ blog</title>
  <subtitle>不断提高自己认知，不断的为自己想要的努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fushenghua.github.io/"/>
  <updated>2018-04-20T05:25:03.649Z</updated>
  <id>http://fushenghua.github.io/</id>
  
  <author>
    <name>fushenghua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Pypi上发布自己的Python包</title>
    <link href="http://fushenghua.github.io/archives/ed6915f6.html"/>
    <id>http://fushenghua.github.io/archives/ed6915f6.html</id>
    <published>2018-04-09T07:39:39.000Z</published>
    <updated>2018-04-20T05:25:03.649Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python编程的都知道，Python的包安装非常的方便，一般都是可以<strong>pip</strong>来安装搞定：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sudo pip <span class="keyword">install</span></div></pre></td></tr></table></figure>
<p>pip的安装请移步：<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="external">https://pip.pypa.io/en/stable/installing/</a></p>
<p>在<a href="https://github.com/fushenghua/gitbook-plugin-summary" target="_blank" rel="external">gitbook-plugin-summary</a> 需要，发布了一个自己的pypi Python包，这里我大致分享如何发布自己的Pypi包一般过程。</p>
<p>打包工作主要依赖python的一个叫setuptools的包来完成，在进行下面操作前请使用pip安装它：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip <span class="keyword">install</span> setuptools</div></pre></td></tr></table></figure>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul>
<li>注册</li>
</ul>
<p><a href="https://pypi.python.org/pypi" target="_blank" rel="external">https://pypi.python.org/pypi</a>注册自己的用户, 点击“Register”，填写自己的用户名，密码，邮件地址后，就成功了，我是直接用Google 账户。</p>
<p><img src="/images/15236887893053.jpg" alt=""></p>
<p>记住自己的用户名和密码，后面上传的时候要输入的</p>
<h3 id="准备setup-py-setup-conf文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier-等等，下面是我自己包的一个setup-py文件的内容，基本上只需要在这个上面修改就行了，具体如下："><a href="#准备setup-py-setup-conf文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier-等等，下面是我自己包的一个setup-py文件的内容，基本上只需要在这个上面修改就行了，具体如下：" class="headerlink" title="准备setup.py/setup.conf文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier)等等，下面是我自己包的一个setup.py文件的内容，基本上只需要在这个上面修改就行了，具体如下："></a>准备setup.py/setup.conf文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier)等等，下面是我自己包的一个setup.py文件的内容，基本上只需要在这个上面修改就行了，具体如下：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">!/usr/bin/env python <span class="meta"># coding=utf-8</span></div><div class="line"></div><div class="line">from setuptools <span class="keyword">import</span> <span class="built_in">setup</span>, find_packages</div><div class="line"></div><div class="line"><span class="built_in">setup</span>(</div><div class="line">    name=<span class="string">''</span>,</div><div class="line">    version=,</div><div class="line">    description=( <span class="string">''</span> ),</div><div class="line">    long_description=<span class="built_in">open</span>(<span class="string">'README.rst'</span>).<span class="built_in">read</span>(),</div><div class="line">    author=<span class="string">''</span>,</div><div class="line">    author_email=<span class="string">''</span>,</div><div class="line">    maintainer=<span class="string">''</span>,</div><div class="line">    maintainer_email=<span class="string">''</span>,</div><div class="line">    license=<span class="string">'BSD License'</span>,</div><div class="line">    packages=find_packages(),</div><div class="line">    platforms=[<span class="string">"all"</span>],</div><div class="line">    url=<span class="string">''</span>,</div><div class="line">    classifiers=[ <span class="string">'Development Status :: 4 - Beta'</span>, <span class="string">'Operating System :: OS Independent'</span>, <span class="string">'Intended Audience :: Developers'</span>, <span class="string">'License :: OSI Approved :: BSD License'</span>, <span class="string">'Programming Language :: Python'</span>, <span class="string">'Programming Language :: Python :: Implementation'</span>, <span class="string">'Programming Language :: Python :: 2'</span>, <span class="string">'Programming Language :: Python :: 2.7'</span>, <span class="string">'Programming Language :: Python :: 3'</span>, <span class="string">'Programming Language :: Python :: 3.4'</span>, <span class="string">'Programming Language :: Python :: 3.5'</span>, <span class="string">'Programming Language :: Python :: 3.6'</span>, <span class="string">'Topic :: Software Development :: Libraries'</span> ],</div><div class="line">)</div></pre></td></tr></table></figure>
<p>需要注意的上面的字段：</p>
<ul>
<li><strong>version</strong> - 这个简单，就是包的发布的版本，可以直接写在这，也可以从其他地方引用过来。</li>
<li><strong>long_description</strong> - 必须是rst（reStructuredText )格式的，因为这个里面的内容是显示在pypi包首页上，具体rst的语法可以参考：<a href="http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html" target="_blank" rel="external">http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html</a></li>
</ul>
<p>　　　我的long_description是同目录下的README.rst的内容，同时这个README也是我的github项目首页。</p>
<ul>
<li><strong>packages</strong> - 申明你的包里面要包含的目录，比如  [‘mypackage’, ‘mypackage_test’]  可以是这种使用我的示例，让setuptools自动决定要包含哪些包</li>
<li><strong>install_requires</strong> - 申明依赖包，安装包时pip会自动安装：格式如下（我上面的setup.py没有这个参数，因为我不依赖第三方包:)）：</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">install_requires</span>=[ <span class="string">'Twisted&gt;=13.1.0'</span>, <span class="string">'w3lib&gt;=1.17.0'</span>, <span class="string">'queuelib'</span>, <span class="string">'lxml'</span>, <span class="string">'pyOpenSSL'</span>, <span class="string">'cssselect&gt;=0.9'</span>, <span class="string">'six&gt;=1.5.2'</span>, <span class="string">'parsel&gt;=1.1'</span>, <span class="string">'PyDispatcher&gt;=2.0.5'</span>, <span class="string">'service_identity'</span>,]</div></pre></td></tr></table></figure>
<h3 id="准备requirements-txt-和-test-requirements-txt，这个申明包的依赖包和跑自动化测试的测试依赖包，具体格式示例如下："><a href="#准备requirements-txt-和-test-requirements-txt，这个申明包的依赖包和跑自动化测试的测试依赖包，具体格式示例如下：" class="headerlink" title="准备requirements.txt 和 test-requirements.txt，这个申明包的依赖包和跑自动化测试的测试依赖包，具体格式示例如下："></a>准备requirements.txt 和 test-requirements.txt，这个申明包的依赖包和跑自动化测试的测试依赖包，具体格式示例如下：</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mock&gt;=<span class="number">2.0</span><span class="number">.0</span></div><div class="line">flake8&gt;=<span class="number">3.2</span><span class="number">.1</span> eventlet&gt;=<span class="number">0.19</span><span class="number">.0</span></div><div class="line">nose2&gt;=<span class="number">0.6</span><span class="number">.5</span> cov_core&gt;=<span class="number">1.15</span><span class="number">.0</span></div><div class="line">virtualenv&gt;=<span class="number">15.1</span><span class="number">.0</span></div></pre></td></tr></table></figure>
<p>以上是我的test-requirements.txt的内容，requirements.txt的格式个上面一样。</p>
<p><strong>准备这个两个文件不是必须的。</strong></p>
<p>但是，有了它们，用户可以自己手动安装依赖包</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`<span class="javascript">pip&lt;span&gt; <span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span>``<span class="javascript">install</span>` `<span class="javascript">-r requirements.txt</span>`</div></pre></td></tr></table></figure>
<p>有了它们，结合tox等工具，可以非常方便的加入自动化测试。　</p>
<h3 id="准备一个项目的README-rst文件-前面也提到了它的格式要求，第一次发包，可以直接copy别人的格式，这东西熟能生巧，多写就会了。"><a href="#准备一个项目的README-rst文件-前面也提到了它的格式要求，第一次发包，可以直接copy别人的格式，这东西熟能生巧，多写就会了。" class="headerlink" title="准备一个项目的README.rst文件,前面也提到了它的格式要求，第一次发包，可以直接copy别人的格式，这东西熟能生巧，多写就会了。"></a>准备一个项目的README.rst文件,前面也提到了它的格式要求，第一次发包，可以直接copy别人的格式，这东西熟能生巧，多写就会了。</h3><p>README的截图就不放了，以免广告嫌疑。有兴趣可以到参考<a href="http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html" target="_blank" rel="external">http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html</a></p>
<h3 id="准备好上面的步骤，一个包就基本完整了，剩下的就是打包了-cd到包的根目录-："><a href="#准备好上面的步骤，一个包就基本完整了，剩下的就是打包了-cd到包的根目录-：" class="headerlink" title="准备好上面的步骤，一个包就基本完整了，剩下的就是打包了(cd到包的根目录)："></a>准备好上面的步骤，一个包就基本完整了，剩下的就是打包了(cd到包的根目录)：</h3><p>可以使用下面命令打包一个源代码的包:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> sdist build</div></pre></td></tr></table></figure>
<p>这样在当前目录的dist文件夹下，就会多出一个以tar.gz结尾的包了：</p>
<p>也可以打包一个wheels格式的包，使用下面的命令搞定：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> bdist_wheel --universal</div></pre></td></tr></table></figure>
<p>这样会在dist文件夹下生成一个whl文件，</p>
<h3 id="上传生成的包，可以使用setuptools-或者twine上传-推荐使用twine上次，因为使用setuptools上传时，你的用户名和密码是明文或者未加密传输，安全起见还是使用twine吧"><a href="#上传生成的包，可以使用setuptools-或者twine上传-推荐使用twine上次，因为使用setuptools上传时，你的用户名和密码是明文或者未加密传输，安全起见还是使用twine吧" class="headerlink" title="上传生成的包，可以使用setuptools,或者twine上传,推荐使用twine上次，因为使用setuptools上传时，你的用户名和密码是明文或者未加密传输，安全起见还是使用twine吧"></a>上传生成的包，可以使用setuptools,或者twine上传,推荐使用twine上次，因为使用setuptools上传时，你的用户名和密码是明文或者未加密传输，安全起见还是使用twine吧</h3><h1 id="上传source-包"><a href="#上传source-包" class="headerlink" title="上传source 包"></a>上传source 包</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> sdist upload</div></pre></td></tr></table></figure>
<h1 id="上传pre-compiled包"><a href="#上传pre-compiled包" class="headerlink" title="上传pre-compiled包"></a>上传pre-compiled包</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> bdist_wheel upload</div></pre></td></tr></table></figure>
<p>使用twine上传,先安装twine</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo pip <span class="keyword">install</span> twine</div><div class="line"></div><div class="line">twine upload dist/*</div></pre></td></tr></table></figure>
<p>上次前都会提示你前面注册的用户名和密码。一切搞定，你的包现在可以通过pip在任何地方安装了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python编程的都知道，Python的包安装非常的方便，一般都是可以&lt;strong&gt;pip&lt;/strong&gt;来安装搞定：&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;d
    
    </summary>
    
      <category term="python" scheme="http://fushenghua.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么说枚举更占内存，枚举原理是什么？</title>
    <link href="http://fushenghua.github.io/archives/3e3728fd.html"/>
    <id>http://fushenghua.github.io/archives/3e3728fd.html</id>
    <published>2018-04-09T07:39:39.000Z</published>
    <updated>2018-04-20T05:25:03.643Z</updated>
    
    <content type="html"><![CDATA[<p>从以前学习java 开始就听说枚举很占内存，然后老版Android开发指南文章也指出，枚举通常需要比静态常量多两倍的内存。你应该严格避免在android上使用枚举。那么究竟为什么说枚举更占内存呢？本文就是通过这种方法来分析枚举为什么占内存的，而不是说拒绝枚举。</p>
<blockquote>
<p>在阅读过程中有任何问题，请及时联系。如需转载请注明 <a href="http://blog.csdn.net/vfush" target="_blank" rel="external">fuchenxuan de Blog</a>  </p>
</blockquote>
<h2 id="关于-Enum"><a href="#关于-Enum" class="headerlink" title="关于 Enum"></a>关于 Enum</h2><p><code>Enum</code> 一般用来表示一组相同类型可列举的常量。如性别、日期、月份、颜色等。对这些属性用常量的好处是显而易见的，不仅可以保证单例，且比较时候可以用 <code>”==”</code> 来替换 <code>equals</code> 。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>看看枚举的基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;   </div><div class="line">  </div><div class="line">  RED , BLUE,GREEN,BLACK ;   </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>通常会使用<code>javap -c Color.class</code> 反编译<code>class</code> 文件，查看生成的字节码，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Compiled from "Color.java"</div><div class="line">public final class org.fast.clean.Color extends java.lang.Enum&lt;org.fast.clean.Color&gt; &#123;</div><div class="line">  public static final org.fast.clean.Color RED;</div><div class="line"></div><div class="line">  public static final org.fast.clean.Color BLUE;</div><div class="line"></div><div class="line">  public static final org.fast.clean.Color GREEN;</div><div class="line"></div><div class="line">  public static final org.fast.clean.Color BLACK;</div><div class="line"></div><div class="line">  public static org.fast.clean.Color[] values();</div><div class="line">    Code:</div><div class="line">       0: getstatic     #1                  // Field $VALUES:[Lorg/fast/clean/Color;</div><div class="line">       3: invokevirtual #2                  // Method "[Lorg/fast/clean/Color;".clone:()Ljava/lang/Object;</div><div class="line">       6: checkcast     #3                  // class "[Lorg/fast/clean/Color;"</div><div class="line">       9: areturn</div><div class="line"></div><div class="line">  public static org.fast.clean.Color valueOf(java.lang.String);</div><div class="line">    Code:</div><div class="line">     ....</div><div class="line">            9: areturn</div><div class="line"></div><div class="line">  static &#123;&#125;;</div><div class="line">    Code:</div><div class="line">       0: new           #4                  // class org/fast/clean/Color</div><div class="line">       3: dup</div><div class="line">       4: ldc           #7                  // String RED</div><div class="line">       6: iconst_0</div><div class="line">       7: invokespecial #8                  // Method "&lt;init&gt;":(Ljava/lang/</div><div class="line">       ....</div><div class="line">      10: putstatic     #9                  // Field RED:Lorg/fast/clean/Color;</div><div class="line">      13: new           #4                  // class org/fast/clean/Color</div><div class="line">      16: dup</div><div class="line">      17: ldc           #10                 // String BLUE</div><div class="line">          83: return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>org.fast.clean.Color</code> 类被编译成继承自继承自<code>java.lang.Enum</code>的<code>final</code>类，其中的成员变量也是final常量，它们都不能被修改的。</p>
<p>下面使用<a href="http://www.javadecompilers.com/jad" target="_blank" rel="external">jad </a>反编译生成jad源码文件， 文件显示每个方法的字节码的实际作用，与源码做出对比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Color[] values()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (Color[])$VALUES.clone();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Color <span class="title">valueOf</span><span class="params">(String s)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (Color)Enum.valueOf(org/fast/clean/Color, s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">super</span>(s, i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLACK;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color $VALUES[];</div><div class="line">    <span class="keyword">static</span> </div><div class="line">    &#123;</div><div class="line">        RED = <span class="keyword">new</span> Color(<span class="string">"RED"</span>, <span class="number">0</span>);</div><div class="line">        BLUE = <span class="keyword">new</span> Color(<span class="string">"BLUE"</span>, <span class="number">1</span>);</div><div class="line">        GREEN = <span class="keyword">new</span> Color(<span class="string">"GREEN"</span>, <span class="number">2</span>);</div><div class="line">        BLACK = <span class="keyword">new</span> Color(<span class="string">"BLACK"</span>, <span class="number">3</span>);</div><div class="line">        $VALUES = (<span class="keyword">new</span> Color[] &#123;</div><div class="line">            RED, BLUE, GREEN, BLACK</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过比较字节码和源代码的区别，我们可以知道为什么枚举确实比简单的静态变量占用的内存要更多。</p>
<h2 id="Android-简单替代枚举的方法"><a href="#Android-简单替代枚举的方法" class="headerlink" title="Android 简单替代枚举的方法"></a>Android 简单替代枚举的方法</h2><p>严格来讲，这个使用方法是有很多缺陷的，但是使用下面的方法就能满足需求的话，那么用<code>Java Enum</code>是会带来各种更大的开销。</p>
<ul>
<li><strong>方法一：使用接口变量</strong></li>
</ul>
<p>接口变量默认都是<code>public static final</code>的，个人理解接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展(不同的实现<code>implements</code>)开放，接口是对开闭原则的一种体现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorCode</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ERROR_MANUAL_EXP = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ERROR_MANUAL_BACK = <span class="number">101</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>javap Color.class</code> 反编译<code>class</code> 文件，查看生成的字节码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Compiled from <span class="string">"ErrorCode.java"</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">org</span>.<span class="title">fast</span>.<span class="title">clean</span>.<span class="title">ErrorCode</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_MANUAL_EXP;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_MANUAL_BACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出就是一个<code>public static final</code>的静态变量。</p>
<ul>
<li><strong>方法二：使用support-annotations 注解库</strong></li>
</ul>
<p>从<code>Android Support Library19.1</code>版本开始引入了一个新的注解库，使用 <code>com.android.support:support-annotations</code> ，这个官方的注解支持库中包含了许多很好的注解，可以帮助我们在编译的时候就找到错误。<code>IntDef</code> 和 <code>StringDef</code> 是包含在库中的两个关于常量的注解，我们可以用来代替枚举其中包括了很多有用的元注解，可以用来修饰代码，如<code>@NonNull</code>，<code>@StringRes</code>，<code>@IntDef</code>，<code>@StringDef</code>等等</p>
<p>下面我们使用<code>@IntDef</code>来替代枚举,方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">0</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLUE = <span class="number">1</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="meta">@IntDef</span>(&#123;RED, BLUE, GREEN&#125;)</div><div class="line">  <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line">  <span class="keyword">public</span> <span class="meta">@interface</span> Colors &#123;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>gradle 依赖：</p>
<blockquote>
<p>dependencies { compile ‘com.android.support:support-annotations:24.2.0’ } </p>
</blockquote>
<p>等等还有其他方法。</p>
<h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><p>枚举在单例的使用也是很平常的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleTon &#123;</div><div class="line">       INSTANCE;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">//单例对象的获取：</span></div><div class="line">   SingleTon instance = SingleTon.INSTANCE;</div></pre></td></tr></table></figure></p>
<p>通过查看<code>java.lang.Enum</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * prevent default deserialization</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,</span></div><div class="line">       ClassNotFoundException &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>对于单例是否安全，主要考虑以下两方面：序列化和反序列方面、线程安全方面。</p>
<ul>
<li><p>对于序列化和反序列化，因为每一个枚举类型和枚举变量在JVM中都是唯一的，即Java在序列化和反序列化枚举时做了特殊的规定，枚举的<code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法是被编译器禁用的，因此也不存在实现序列化接口后调用<code>readObject</code>会破坏单例的问题。</p>
</li>
<li><p>对于线程安全方面，类似于普通的饿汉模式，通过在第一次调用时的静态初始化创建的对象是线程安全的。</p>
</li>
</ul>
<p>所以使用枚举也是一种比较好的单例模式，通过反编译我们知道，缺点就是不能够继承，因为<code>final</code>了。</p>
<p>通过上面的分析枚举，我们只是讨论为什么说枚举更占内存，枚举原理是什么，而不是让我们拒绝使用枚举，因为就几个枚举，让应用内存开销大，那就实在是太可怕了。。。更重要的是通过比较字节码和源代码，我们可以发现很多的问题，一个很重要的作用就是了解很多编译器内部的工作机制。</p>
<p> 更多java 学习总结，请点击下方图片哦。</p>
<blockquote>
<p>水平有限，若有错漏，欢迎指正，批评，如需转载，请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a>，谢谢！<br><a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160608162227307" alt="这里写图片描述"></a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从以前学习java 开始就听说枚举很占内存，然后老版Android开发指南文章也指出，枚举通常需要比静态常量多两倍的内存。你应该严格避免在android上使用枚举。那么究竟为什么说枚举更占内存呢？本文就是通过这种方法来分析枚举为什么占内存的，而不是说拒绝枚举。&lt;/p&gt;
&lt;b
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 8.0 中的 ART 功能改进</title>
    <link href="http://fushenghua.github.io/archives/3b12125.html"/>
    <id>http://fushenghua.github.io/archives/3b12125.html</id>
    <published>2018-04-02T00:55:29.000Z</published>
    <updated>2018-05-07T08:39:05.326Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 8.0 版本中，Android Runtime (ART) 有了极大改进。下面的列表总结了设备制造商可以在 ART 中获得的增强功能。</p>
<h2 id="并发压缩式垃圾回收器"><a href="#并发压缩式垃圾回收器" class="headerlink" title="并发压缩式垃圾回收器"></a>并发压缩式垃圾回收器</h2><p>正如 Google 在 Google I/O 大会上所宣布的那样，ART 在 Android 8.0 中提供了新的并发压缩式垃圾回收器 (GC)。该回收器会在每次执行 GC 时以及应用正在运行时对堆进行压缩，且仅在处理线程根时短暂停顿一次。该回收器具有以下优势：</p>
<ul>
<li>GC 始终会对堆进行压缩：堆的大小平均比 Android 7.0 中的小 32%。</li>
<li>得益于压缩，系统现可实现线程局部碰撞指针对象分配：分配速度比 Android 7.0 中的快 70%。</li>
<li>H2 基准的停顿次数比 Android 7.0 GC 的少 85%。</li>
<li>停顿次数不再随堆的大小而变化，应用在使用较大的堆时也无需担心造成卡顿。</li>
<li>GC 实现细节 - 读取屏障：<ul>
<li>读取屏障是在读取每个对象字段时所做的少量工作。</li>
<li>它们在编译器中经过了优化，但可能会减慢某些用例的速度。</li>
</ul>
</li>
</ul>
<h2 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h2><p>在 Android 8.0 版本中，ART 采取了多种循环优化措施，具体如下：</p>
<ul>
<li>消除边界检查<ul>
<li>静态：在编译时证明范围位于边界内</li>
<li>动态：运行时测试确保循环始终位于边界内（否则不进行优化）</li>
</ul>
</li>
<li>消除归纳变量<ul>
<li>移除无用归纳</li>
<li>用封闭式表达式替换仅在循环后使用的归纳</li>
</ul>
</li>
<li>消除循环主体内的无用代码，移除整个死循环</li>
<li>强度降低</li>
<li>循环转换：逆转、交换、拆分、展开、单模等</li>
<li>SIMDization（也称为矢量化）</li>
</ul>
<p>循环优化器位于 ART 编译器中一个独立的优化环节中。大多数循环优化与其他方面的优化和简化类似。由于大多数 CFG 实用工具（请参阅 nodes.h）侧重于编译而不是重写 CFG，因此通过更复杂（与平时相比）的方式进行一些重写 CFG 的优化时，会面临挑战。</p>
<h2 id="类层次结构分析"><a href="#类层次结构分析" class="headerlink" title="类层次结构分析"></a>类层次结构分析</h2><p>在 Android 8.0 中，ART 会使用类层次结构分析 (CHA)，这是一种编译器优化，可基于通过分析类层次结构所生成的信息，将虚拟调用去虚拟化为直接调用。虚拟调用代价高昂，因为它们围绕 vtable 查找来实现，且会占用几个依赖负载。另外，虚拟调用也不能内嵌。</p>
<p>以下是对相关增强功能的总结：</p>
<ul>
<li>动态单一实现方法状态更新 - 在类关联时间结束时，如果 vtable 已被填充，ART 会按条目对超类的 vtable 进行比较。</li>
<li>编译器优化 - 编译器会利用某种方法的单一实现信息。如果方法 A.foo 设置了单一实现标记，则编译器会将虚拟调用去虚拟化为直接调用，并借此进一步尝试内嵌直接调用。</li>
<li>已编译代码无效 - 另外，在类关联时间结束时，如果单一实现信息进行了更新，且方法 A.foo 之前拥有单一实现，但该状态现已变为无效，则依赖方法 A.foo 拥有单一实现这一假设的所有已编译代码都需要变为无效代码。</li>
<li>去优化 - 对于堆栈上已编译的有效代码，系统会启动去优化功能，以强制使已编译无效代码进入解释器模式，从而确保正确性。系统会采用结合了同步和异步去优化的全新去优化机制。</li>
</ul>
<h2 id="oat-文件中的内嵌缓存"><a href="#oat-文件中的内嵌缓存" class="headerlink" title=".oat 文件中的内嵌缓存"></a>.oat 文件中的内嵌缓存</h2><p>ART 现在采用内嵌缓存，并对有足够数据可用的调用站点进行优化。内嵌缓存功能会将额外的运行时信息记录到配置文件中，并利用这类信息将动态优化添加到预先编译中。</p>
<h2 id="Dexlayout"><a href="#Dexlayout" class="headerlink" title="Dexlayout"></a>Dexlayout</h2><p>Dexlayout 是在 Android 8.0 中引入的一个库，用于分析 dex 文件，并根据配置文件对其进行重新排序。Dexlayout 旨在使用运行时配置信息对 dex 文件的各个部分进行重新排序（在设备的空闲维护编译期间）。通过将经常一起访问的部分 dex 文件集中在一起，程序可以因改进文件位置而拥有更好的内存访问模式，从而节省 RAM 并缩短启动时间。</p>
<p>由于配置文件信息目前仅在运行应用后可用，因此系统会在空闲维护期间将 dexlayout 集成到 dex2oat 的设备编译中。</p>
<h2 id="Dex-缓存移除"><a href="#Dex-缓存移除" class="headerlink" title="Dex 缓存移除"></a>Dex 缓存移除</h2><p>在 Android 7.0 及更早版本中，DexCache 对象拥有四个大型数组，与 DexFile 中特定元素的数量成正比，即：</p>
<ul>
<li>字符串（每个 DexFile::StringId 一个引用），</li>
<li>类型（每个 DexFile::TypeId 一个引用），</li>
<li>方法（每个 DexFile::MethodId 一个原生指针），</li>
<li>字段（每个 DexFile::FieldId 一个原生指针）。</li>
</ul>
<p>这些数组用于快速检索我们以前解析的对象。在 Android 8.0 中，除方法数组外，所有数组都已移除。</p>
<h2 id="解释器性能"><a href="#解释器性能" class="headerlink" title="解释器性能"></a>解释器性能</h2><p>通过引入 Mterp（一种解释器，具有以汇编语言编写的核心提取/解码/解释机制），Android 7.0 版本中的解释器性能得以显著提升。Mterp 模仿了快速 Dalvik 解释器，并支持 arm、arm64、x86、x86_64、mips 和 mips64。对于计算代码而言，ART 的 Mterp 大致相当于 Dalvik 的快速解释器。不过，有时候，它的速度可能会显著变慢，甚至急剧变慢：</p>
<ol>
<li>调用性能。</li>
<li>字符串操作和 Dalvik 中其他被视为内嵌函数的高频用户方法。</li>
<li>堆栈内存使用量较高。</li>
</ol>
<p>Android 8.0 解决了这些问题。</p>
<h2 id="详细了解内嵌"><a href="#详细了解内嵌" class="headerlink" title="详细了解内嵌"></a>详细了解内嵌</h2><p>从 Android 6.0 开始，ART 可以内嵌同一个 dex 文件中的任何调用，但只能内嵌来自其他 dex 文件的叶方法。此项限制具有以下两个原因：</p>
<ol>
<li>从其他 dex 文件进行内嵌需要使用该 dex 文件的 dex 缓存，这与同一 dex 文件内嵌（只能重复使用调用程序的 dex 缓存）有所不同。已编译代码中需要具有 dex 缓存，以便执行一系列指令，例如静态调用、字符串加载或类加载。</li>
<li>堆栈映射只对当前 dex 文件中的方法索引进行编码。</li>
</ol>
<p>为了应对这些限制，Android 8.0 做出了以下改进：</p>
<ol>
<li>从已编译代码中移除 dex 缓存访问（另请参阅“Dex 缓存移除”部分）</li>
<li>扩展堆栈映射编码。</li>
</ol>
<h2 id="同步方面的改进"><a href="#同步方面的改进" class="headerlink" title="同步方面的改进"></a>同步方面的改进</h2><p>ART 团队调整了 MonitorEnter/MonitorExit 代码路径，并减少了我们对 ARMv8 上传统内存屏障的依赖，尽可能将其替换为较新的（获取/释放）指令。</p>
<h2 id="更快速的原生方法"><a href="#更快速的原生方法" class="headerlink" title="更快速的原生方法"></a>更快速的原生方法</h2><p>使用 <a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java" target="_blank" rel="external"><code>@FastNative</code></a> 和 <a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/CriticalNative.java" target="_blank" rel="external"><code>@CriticalNative</code></a> 注解可实现对 Java 原生接口 (JNI) 更快速的原生调用。这种内置的 ART 运行时优化加快了 JNI 转换，并取代了现在已弃用的 !<em>bang JNI 标记。</em>注解对非原生方法没有任何影响，并且仅适用于 <code>bootclasspath</code> 上的平台 Java 语言代码（无 Play 商店更新）。</p>
<p><code>@FastNative</code> 注解支持非静态方法。如果某种方法将 <code>jobject</code> 作为参数或返回值进行访问，请使用此注解。</p>
<p>利用 <code>@CriticalNative</code> 注解，可更快速地运行原生方法，但存在以下限制：</p>
<ul>
<li>方法必须是静态的 - 没有参数、返回值或隐式 <code>this</code> 的对象。</li>
<li>仅将基元类型传递给原生方法。</li>
<li>原生方法在其函数定义中不使用 <code>JNIEnv</code> 和 <code>jclass</code> 参数。</li>
<li>该方法必须是使用 <code>RegisterNatives</code> 注册的，而不是依靠动态 JNI 链接。</li>
</ul>
<p><code>@FastNative</code> 和 <code>@CriticalNative</code> 注解在执行原生方法时会停用垃圾回收。请勿使用运行时间较长的方法，包括通常很快但一般不受控制的方法。</p>
<p>停顿垃圾回收可能会导致死锁。如果锁尚未得到本地释放（即尚未返回受管理代码），请勿在原生快速调用期间获取锁。此要求不适用于常规的 JNI 调用，因为 ART 将正执行的原生代码视为已暂停的状态。</p>
<p><code>@FastNative</code> 可以使原生方法的性能提升高达 3 倍，<code>@CriticalNative</code> 则可以提升高达 5 倍。例如，在 Nexus 6P 设备上测量的 JNI 转换如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Java 原生接口 (JNI) 调用</th>
<th>执行时间（以纳秒计）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>常规 JNI</td>
<td>115</td>
<td></td>
</tr>
<tr>
<td></td>
<td><em>!bang JNI</em></td>
<td>60</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>&lt;span style=&quot;box-sizing: inherit;&quot;&gt;@FastNative&lt;/span&gt;</code></td>
<td>35</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>&lt;span style=&quot;box-sizing: inherit;&quot;&gt;@CriticalNative&lt;/span&gt;</code></td>
<td>25</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Android 8.0 版本中，Android Runtime (ART) 有了极大改进。下面的列表总结了设备制造商可以在 ART 中获得的增强功能。&lt;/p&gt;
&lt;h2 id=&quot;并发压缩式垃圾回收器&quot;&gt;&lt;a href=&quot;#并发压缩式垃圾回收器&quot; class=&quot;header
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>实现 ART 即时 (JIT) 编译器</title>
    <link href="http://fushenghua.github.io/archives/3dbdbf17.html"/>
    <id>http://fushenghua.github.io/archives/3dbdbf17.html</id>
    <published>2018-04-02T00:55:29.000Z</published>
    <updated>2018-05-10T03:30:31.574Z</updated>
    
    <content type="html"><![CDATA[<p>Android 运行时 (ART) 包含一个具备代码分析功能的即时 (JIT) 编译器，该编译器可以在 Android 应用运行时持续提高其性能。JIT 编译器补充了 ART 当前的预先 (AOT) 编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速度。相较于 AOT 编译器，JIT 编译器的优势也更为明显，因为它不会在应用自动更新期间或重新编译应用（在无线下载 (OTA) 更新期间）时拖慢系统速度。</p>
<p>尽管 JIT 和 AOT 使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT 会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 (OSR) 编译成为可能，而这一切都会使其生成的代码略有不同。</p>
<h2 id="JIT-架构"><a href="#JIT-架构" class="headerlink" title="JIT 架构"></a>JIT 架构</h2><p><img src="/images/jit-arch.png" alt="JIT 架构"></p>
<p><strong>图 1.</strong> JIT 架构。</p>
<h2 id="JIT-编译"><a href="#JIT-编译" class="headerlink" title="JIT 编译"></a>JIT 编译</h2><p>JIT 编译涉及以下活动：</p>
<p><img src="/images/jit-profile-comp.png" alt="配置文件引导的编译"></p>
<p><strong>图 2.</strong> 配置文件引导的编译。</p>
<ol>
<li><p>用户运行应用，而这随后就会触发 ART 加载 <code>.dex</code> 文件。</p>
<ul>
<li>如果有 <code>.oat</code> 文件（即 <code>.dex</code> 文件的 AOT 二进制文件），则 ART 会直接使用该文件。虽然 <code>.oat</code> 文件会定期生成，但文件中不一定会包含经过编译的代码（即 AOT 二进制文件）。</li>
<li><p>如果没有 <code>.oat</code> 文件，则 ART 会通过 JIT 或解释器执行 <code>.dex</code> 文件。</p>
<p><code>.oat</code></p>
<p><code>.dex</code></p>
</li>
</ul>
</li>
<li><p>针对任何未根据 <code>speed</code> 编译过滤器编译的应用启用 JIT（也就是说，要尽可能多地编译应用中的代码）。</p>
</li>
<li>将 JIT 配置文件数据转存到只限应用访问的系统目录内的文件中。</li>
<li><p>AOT 编译 (<code>dex2oat</code>) 守护进程通过解析该文件来推进其编译。</p>
<p> <img src="/images/jit-daemon.png" alt="JIT 守护进程"></p>
<p> <strong>图 3.</strong> JIT 守护进程活动。</p>
</li>
</ol>
<p>举例来说，Google Play 服务就是一种由其他应用使用的类似于共享库的服务。</p>
<h2 id="JIT-工作流程"><a href="#JIT-工作流程" class="headerlink" title="JIT 工作流程"></a>JIT 工作流程</h2><p><img src="/images/jit-workflow.png" alt="JIT 架构"></p>
<p><strong>图 4.</strong> JIT 数据流。</p>
<ul>
<li>分析信息会存储在代码缓存中，并会在内存紧张时作为垃圾被回收。<ul>
<li>无法保证在应用处于后台运行状态时所捕获的快照能够包含完整的数据（即 JIT 编译的所有内容）。</li>
<li>该过程不会尝试确保记录所有内容（因为这将影响运行时性能）。</li>
</ul>
</li>
<li>方法可能有三种不同的状态：<ul>
<li>已经过解释（dex 代码）</li>
<li>已经过 JIT 编译</li>
<li>已经过 AOT 编译如果同时存在 JIT 和 AOT 代码（例如，由于反复进行逆优化），经过 JIT 编译的代码将是首选代码。</li>
</ul>
</li>
<li>在不影响前台应用性能的情况下运行 JIT 所需的内存取决于相关应用。大型应用比小型应用需要更多内存。一般来说，大型应用所需的内存稳定维持在 4 MB 左右。</li>
</ul>
<h2 id="开启-JIT-日志记录"><a href="#开启-JIT-日志记录" class="headerlink" title="开启 JIT 日志记录"></a>开启 JIT 日志记录</h2><p>要开启 JIT 日志记录，请运行以下命令：</p>
<p><code>adb root</code><br><code>adb shell stop</code><br><code>adb shell setprop dalvik.vm.extra-opts -verbose:jit</code><br><code>adb shell start</code></p>
<h2 id="停用-JIT"><a href="#停用-JIT" class="headerlink" title="停用 JIT"></a>停用 JIT</h2><p>要停用 JIT，请运行以下命令：</p>
<p><code>adb root</code><br><code>adb shell stop</code><br><code>adb shell setprop dalvik.vm.usejit false</code><br><code>adb shell start</code></p>
<h2 id="强制编译"><a href="#强制编译" class="headerlink" title="强制编译"></a>强制编译</h2><p>要强制编译，请运行以下命令：</p>
<p>adb shell cmd package compile</p>
<p>强制编译特定软件包的常见用例：</p>
<ul>
<li><p>基于配置文件：</p>
<p>  adb shell cmd package compile -m speed-profile -f my-package</p>
</li>
</ul>
<ul>
<li><p>全面：</p>
<p>  adb shell cmd package compile -m speed -f my-package</p>
</li>
</ul>
<p>强制编译所有软件包的常见用例：</p>
<ul>
<li><p>基于配置文件：</p>
<p>  adb shell cmd package compile -m speed-profile -f -a</p>
</li>
</ul>
<ul>
<li><p>全面：</p>
<p>  adb shell cmd package compile -m speed -f -a</p>
</li>
</ul>
<h2 id="清除配置文件数据"><a href="#清除配置文件数据" class="headerlink" title="清除配置文件数据"></a>清除配置文件数据</h2><p>要清除配置文件数据并移除经过编译的代码，请运行以下命令：</p>
<ul>
<li><p>针对一个软件包：</p>
<p>  adb shell cmd package compile –reset my-package</p>
</li>
</ul>
<ul>
<li><p>针对所有软件包：</p>
<p>  adb shell cmd package compile –reset -a</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 运行时 (ART) 包含一个具备代码分析功能的即时 (JIT) 编译器，该编译器可以在 Android 应用运行时持续提高其性能。JIT 编译器补充了 ART 当前的预先 (AOT) 编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>ART 和 Dalvik的区别</title>
    <link href="http://fushenghua.github.io/archives/a9cc5307.html"/>
    <id>http://fushenghua.github.io/archives/a9cc5307.html</id>
    <published>2017-03-07T00:55:29.000Z</published>
    <updated>2018-05-05T15:30:46.808Z</updated>
    
    <content type="html"><![CDATA[<p>Android Runtime (ART) 是 Android 上的应用和部分系统服务使用的托管式运行时。ART 及其前身 Dalvik 最初是专为 Android 项目打造的。作为运行时的 ART 可执行 Dalvik 可执行文件并遵循 Dex 字节码规范。</p>
<p>ART 和 Dalvik 是运行 Dex 字节码的兼容运行时，因此针对 Dalvik 开发的应用也能在 ART 环境中运作。不过，Dalvik 采用的一些技术并不适用于 ART。有关最重要问题的信息，请参阅在 Android Runtime (ART) 上验证应用行为。</p>
<h2 id="ART-功能"><a href="#ART-功能" class="headerlink" title="ART 功能"></a>ART 功能</h2><p>以下是 ART 实现的一些主要功能。</p>
<h3 id="预先-AOT-编译"><a href="#预先-AOT-编译" class="headerlink" title="预先 (AOT) 编译"></a>预先 (AOT) 编译</h3><p>ART 推出了预先 (AOT) 编译，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。</p>
<p>在安装时，ART 使用设备自带的 <strong>dex2oat</strong> 工具来编译应用。该实用工具接受 <a href="https://source.android.google.cn/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">DEX</a> 文件作为输入，并针对目标设备生成已编译的应用可执行文件。该实用工具应能够毫不费力地编译所有有效的 DEX 文件。但是，一些后处理工具会生成无效文件，Dalvik 可以接受这些文件，但 ART 无法编译这些文件。有关详情，请参阅<a href="http://developer.android.google.cn/guide/practices/verifying-apps-art.html#GC_Migration" target="_blank" rel="external">解决垃圾回收问题</a>。</p>
<h3 id="优化的垃圾回收"><a href="#优化的垃圾回收" class="headerlink" title="优化的垃圾回收"></a>优化的垃圾回收</h3><p>垃圾回收 (GC) 可能会损害应用的性能，从而导致显示不稳定、界面响应速度缓慢以及其他问题。ART 通过以下几种方式优化垃圾回收：</p>
<ul>
<li>采用一个而非两个 GC 暂停</li>
<li>在 GC 保持暂停状态期间并行处理</li>
<li>采用总 GC 时间更短的回收器清理最近分配的短时对象这种特殊情况</li>
<li>优化了垃圾回收人机工程学，能够更加及时地进行并行垃圾回收，这使得 <a href="http://developer.android.google.cn/tools/debugging/debugging-memory.html#LogMessages" target="_blank" rel="external"><code>GC_FOR_ALLOC</code></a> 事件在典型用例中极为罕见</li>
<li>压缩 GC 以减少后台内存使用和碎片</li>
</ul>
<h3 id="开发和调试优化"><a href="#开发和调试优化" class="headerlink" title="开发和调试优化"></a>开发和调试优化</h3><p>ART 提供了大量功能来优化应用开发和调试。</p>
<h4 id="支持采样分析器"><a href="#支持采样分析器" class="headerlink" title="支持采样分析器"></a>支持采样分析器</h4><p>一直以来，开发者都使用 <a href="http://developer.android.google.cn/tools/help/traceview.html" target="_blank" rel="external">Traceview</a> 工具（旨在跟踪应用执行）作为分析器。虽然 Traceview 可提供有用的信息，但其根据每次方法调用开销得出的 Dalvik 分析结果会出现偏差，而且使用该工具明显会影响运行时性能。</p>
<p>ART 添加了对没有这些限制的专用采样分析器的支持，从而更准确地了解应用执行情况，而不会明显减慢速度。KitKat 版本为 Dalvik 的 Traceview 添加了采样支持。</p>
<h4 id="支持更多调试功能"><a href="#支持更多调试功能" class="headerlink" title="支持更多调试功能"></a>支持更多调试功能</h4><p>ART 支持许多新的调试选项，特别是与监控和垃圾回收相关的功能。例如，您可以：</p>
<ul>
<li>查看堆栈跟踪中保留了哪些锁，然后跳转到持有锁的线程。</li>
<li>询问指定类的当前活动的实例数、请求查看实例，以及查看使对象保持有效状态的参考。</li>
<li>过滤特定实例的事件（如断点）。</li>
<li>查看方法退出（使用“method-exit”事件）时返回的值。</li>
<li>设置字段观察点，以在访问和/或修改特定字段时暂停程序执行。</li>
</ul>
<h4 id="优化了异常和崩溃报告中的诊断详细信息"><a href="#优化了异常和崩溃报告中的诊断详细信息" class="headerlink" title="优化了异常和崩溃报告中的诊断详细信息"></a>优化了异常和崩溃报告中的诊断详细信息</h4><p>当发生运行时异常时，ART 会为您提供尽可能多的上下文和详细信息。ART 会提供 <code>[java.lang.ClassCastException](http://developer.android.google.cn/reference/java/lang/ClassCastException.html)</code>、<code>[java.lang.ClassNotFoundException](http://developer.android.google.cn/reference/java/lang/ClassNotFoundException.html)</code> 和 <code>[java.lang.NullPointerException](http://developer.android.google.cn/reference/java/lang/NullPointerException.html)</code> 的更多异常详细信息。 （更高版本的 Dalvik 提供 <code>[java.lang.ArrayIndexOutOfBoundsException](http://developer.android.google.cn/reference/java/lang/ArrayIndexOutOfBoundsException.html)</code> 和 <code>[java.lang.ArrayStoreException](http://developer.android.google.cn/reference/java/lang/ArrayStoreException.html)</code> 的更多异常详细信息，这些信息现在包括数组大小和超出范围的偏移量；ART 也提供这类信息。）</p>
<p>例如，<code>[java.lang.NullPointerException](http://developer.android.google.cn/reference/java/lang/NullPointerException.html)</code> 现在会显示有关应用尝试处理 null 指针时所执行操作的信息（例如应用尝试写入的字段或尝试调用的方法）。一些典型示例如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">java.lang.NullPointerException: Attempt <span class="keyword">to</span> <span class="keyword">write</span> <span class="keyword">to</span> field <span class="string">'int</span></div><div class="line">android.accessibilityservice.AccessibilityServiceInfo.flags' <span class="keyword">on</span> a null object</div><div class="line"><span class="keyword">reference</span></div><div class="line"></div><div class="line">java.lang.NullPointerException: Attempt <span class="keyword">to</span> invoke <span class="keyword">virtual</span> <span class="function"><span class="keyword">method</span></span></div><div class="line">'<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span>.<span class="title">toString</span><span class="params">()</span>' <span class="title">on</span> <span class="title">a</span> <span class="title">null</span> <span class="title">object</span> <span class="title">reference</span></div></pre></td></tr></table></figure>
<p>ART 还通过纳入 Java 和原生堆栈信息在应用原生代码崩溃报告中提供优化的上下文信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Runtime (ART) 是 Android 上的应用和部分系统服务使用的托管式运行时。ART 及其前身 Dalvik 最初是专为 Android 项目打造的。作为运行时的 ART 可执行 Dalvik 可执行文件并遵循 Dex 字节码规范。&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>优化Gradle 依赖使用方式</title>
    <link href="http://fushenghua.github.io/archives/c66eed35.html"/>
    <id>http://fushenghua.github.io/archives/c66eed35.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.653Z</updated>
    
    <content type="html"><![CDATA[<p>经历过模块化后,项目依赖变的错综复杂,以至于编译速度过慢,部分模块依赖不合理导致包增大等。所以清理了一些不必要的依赖及重复依赖详见 <strong>commit</strong>：</p>
<blockquote>
<p><a href="http://stash.lab.tclclouds.com/projects/CLEAN/repos/cleaner_module/commits/d374e1c36d5e7a44c3b1d817216f3b6a04a9f318" target="_blank" rel="external">commits/d374e1c36d5e7a44c3b1d817216f3b6a04a9f318</a></p>
</blockquote>
<p>现在仍有些问题,比如 <strong>SpaceBase</strong> 依赖了 <strong>VirusEngine</strong> 等问题。</p>
<h3 id="全新的依赖方式"><a href="#全新的依赖方式" class="headerlink" title="全新的依赖方式"></a>全新的依赖方式</h3><h4 id="需要那个开那个"><a href="#需要那个开那个" class="headerlink" title="需要那个开那个"></a>需要那个开那个</h4><p>修改项目中 <code>module.properties</code> 的配置, <code>true</code> 代表以<code>Project</code> 方式引入,反之则是<code>aar</code>方式,<strong>该配置已被忽略,只对当前工程配置有效。</strong></p>
<p>如果你确实想提交修改,请使用 <code>git add -f module.properties</code> 命令强制添加。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="params">...</span></div><div class="line">isBoostengineDebug=<span class="literal">false</span></div><div class="line">isAppmgrDebug=<span class="literal">false</span></div><div class="line">isCpuDebug=<span class="literal">false</span></div><div class="line">isNotifyboxDebug=<span class="literal">false</span></div><div class="line">isHardwareDebug=<span class="literal">false</span></div><div class="line">isAntivirusDebug=<span class="literal">false</span></div><div class="line">isJunkDebug=<span class="literal">false</span></div><div class="line">isAllDebug=<span class="literal">false</span><span class="comment">// 全部 Debug，即编译Project模式</span></div></pre></td></tr></table></figure>
<h4 id="添加新的模块依赖"><a href="#添加新的模块依赖" class="headerlink" title="添加新的模块依赖"></a>添加新的模块依赖</h4><p>如果你需要添加新的模块依赖,请按照以下方法,在 <code>module.gradle</code> 脚本中新增 <code>compile_*</code> 方法,如下:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> compile_junk(<span class="keyword">Project</span> projectModule)&#123;</div><div class="line">    projectModule.<span class="keyword">dependencies</span>&#123;</div><div class="line">        <span class="keyword">if</span> (isAllDebug.toBoolean() || isJunkDebug.toBoolean()) &#123;</div><div class="line">            <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':junk'</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">compile</span>(name: <span class="string">'junk'</span>, ext: <span class="string">'aar'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后通过闭包形式传递出去,在 <code>module.gradle</code> 脚本中有<code>ext</code> 扩展属性 ，添加如下：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class">ext </span>&#123;</div><div class="line">  compile_junk = this.<span class="variable">&amp;compile_junk</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终通过以下方式使用</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile_junk(<span class="name">getProject</span>())</div></pre></td></tr></table></figure>
<h3 id="模块公用的Libs库"><a href="#模块公用的Libs库" class="headerlink" title="模块公用的Libs库"></a>模块公用的Libs库</h3><p>在工程目录的顶级 <code>libs</code> 文件夹中存放着各个模块的 <code>aar</code> ,如果需要更新,可以通过脚本进行<br>全量更新,或者各模块部分更新。</p>
<h3 id="更新AAR"><a href="#更新AAR" class="headerlink" title="更新AAR"></a>更新AAR</h3><p>在<code>cleaner</code> 工程目录下，在你每次<strong>运行</strong>程序时 <code>update-aar.gradle</code>会自动更新<strong>已开启</strong>模块(如<code>isJunkDebug=true</code>)的<code>aar</code> 到 公用<code>libs</code>库中，你所需要做的就是 <code>commit</code>，这样能保证各位小伙伴使用的都是较新的<code>aar</code>。</p>
<p>同样的你也可以手动触发<code>Task</code>来更新<code>aar</code>，相应<code>Task</code> 如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">task</span> updateAAR &lt;&lt; &#123;</div><div class="line">    eachLibsAAR()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>如果需要全部通过 <code>Project</code> 形式构建<strong>版本发布</strong>,只需添加动态参数 <code>isAllDebug=true</code> ，比如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew -PisAllDebug=<span class="literal">true</span> hello</div></pre></td></tr></table></figure>
<p>同样的可以添加更多的模块参数,来表示某些模块通过 <code>Project</code> 形式构建，比如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew -PisAppmgrDebug=<span class="literal">true</span> -PisJunkDebug=<span class="literal">true</span> hello</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: 默认都是以引入<code>aar</code> 形式构建(除<strong>SpaceBase</strong>),所以如果不添加参数,需要及时更新<code>aar</code></p>
</blockquote>
<h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><h4 id="2017-4-21-优化Gradle编译速度，最快3s。"><a href="#2017-4-21-优化Gradle编译速度，最快3s。" class="headerlink" title="2017/4/21 优化Gradle编译速度，最快3s。"></a>2017/4/21 优化Gradle编译速度，最快3s。</h4><blockquote>
<p>1、修改<strong><code>isAllDebug</code></strong> 作用域，由原存放在<code>module.properties</code> 修改存放在<code>gradle.properties</code>中。<br>2、可选模块<strong>include</strong>，只有在<code>module.properties</code>配置文件中开关为<strong>true</strong> 的模块，才会被Android Studio 所<strong>include</strong>。<br>3、新增<code>task</code> 耗时监听，方便查看耗时<code>task</code>，在<em>Gradle Console</em> 中输出。<br>4、区分测试开发输出，新增<strong><code>dev</code></strong> <code>productFlavors</code>,同时关闭一些不用的<code>productFlavors</code>，其中<strong><code>dev</code></strong> 用于测试Jenkins 输出apk <code>flavors</code>，<strong><code>buildVersion</code></strong> 用于研发本地输出apk，<strong>minSdkVersion=21</strong>，关闭<strong>fabric</strong> 在<strong><code>buildVersion</code></strong> 中上报初始化，同时也优化了其他模块的依赖。<br>5、本地默认只有<strong><code>buildVersion</code></strong><code>flavors</code>，只有在<code>isAllDebug=true</code>的情况，才会开启其他的<code>flavors</code>。以便获得更好的编译体验。<strong>还有修改完gradle配置文件后记得点build sync<img src="/images/toolbar-sync-gradle.png" alt="Alt text">进行同步一下。</strong></p>
</blockquote>
<h4 id="2017-5-27-添加自动合并多语言task"><a href="#2017-5-27-添加自动合并多语言task" class="headerlink" title="2017/5/27  添加自动合并多语言task"></a>2017/5/27  添加自动合并多语言task</h4><blockquote>
<p>1 、使用<code>Python</code>脚本自动化合入多语言的<code>task</code>，所以在使用前需要有<code>Python</code>环境，相应代码块如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">task mergeLanguage(<span class="built_in">type</span>: Exec) &#123;</div><div class="line">    workingDir <span class="string">'./'</span></div><div class="line">    <span class="built_in">command</span>Line <span class="string">"python"</span>, <span class="string">"merge_strs.py"</span>,</div><div class="line"><span class="string">"/home/silver/ssd/AndroidStudioProjects/cleaner_module/spaceplus_android/junk/src/main/res/"</span>,</div><div class="line">            <span class="string">"/home/silver/桌面/清理缓存0502-多语言/"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中第一个参数是需要添入多语言模块文件目录，第二个参数是存放多语言文件目录。修改参数 执行<strong><code>mergeLanguage</code></strong> <code>task</code>即可合并多语言。<br><img src="/images/2017-05-27 19:26:37屏幕截图.png" alt="Alt text"></p>
<h4 id="2017-5-31-Auto-Update-Librarys-AAR"><a href="#2017-5-31-Auto-Update-Librarys-AAR" class="headerlink" title="2017/5/31  Auto Update Librarys AAR"></a>2017/5/31  Auto Update Librarys AAR</h4><blockquote>
<p>1 、<strong><code>quartz-robot</code></strong>会在<strong>每周一至周五(8,12,16,20h)</strong>准时自动更新<code>aar</code>到git repos。</p>
</blockquote>
<h4 id="2017-5-1-更新说明"><a href="#2017-5-1-更新说明" class="headerlink" title="2017/5/1  更新说明"></a>2017/5/1  更新说明</h4><p>以上是模块化后解决过渡时期编译速度慢,方便开发调试等各种便利的方案,各位研发大拿体验<br>下,感受如丝般顺滑,如有问题及时沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历过模块化后,项目依赖变的错综复杂,以至于编译速度过慢,部分模块依赖不合理导致包增大等。所以清理了一些不必要的依赖及重复依赖详见 &lt;strong&gt;commit&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://stash.lab.
    
    </summary>
    
      <category term="基础技能" scheme="http://fushenghua.github.io/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>app安全之Apk完整性校验</title>
    <link href="http://fushenghua.github.io/archives/a72a1e10.html"/>
    <id>http://fushenghua.github.io/archives/a72a1e10.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.638Z</updated>
    
    <content type="html"><![CDATA[<p>APK 完整性校验，虽然很难做到绝对的安全，但能提高应用的安全性和破解难度,下面简单记录一下Apk完整性的校验方案。</p>
<h2 id="一、认识APK安全性"><a href="#一、认识APK安全性" class="headerlink" title="一、认识APK安全性"></a>一、认识APK安全性</h2><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>可以通过修改客户端文件篡改客户端行为。攻击者可以让客户端显示自己制作的钓鱼网站，偷取用户信息</p>
<h2 id="二、完整性校验原理"><a href="#二、完整性校验原理" class="headerlink" title="二、完整性校验原理"></a>二、完整性校验原理</h2><h3 id="完整性校验的几种方式"><a href="#完整性校验的几种方式" class="headerlink" title="完整性校验的几种方式"></a>完整性校验的几种方式</h3><ol>
<li>CRC校验</li>
<li>MD5值校验</li>
<li>SHA1值校验</li>
</ol>
<h3 id="常见android完整性检测"><a href="#常见android完整性检测" class="headerlink" title="常见android完整性检测"></a>常见android完整性检测</h3><ol>
<li>检测签名</li>
<li>校验classes.dex</li>
<li>校验整个apk</li>
</ol>
<h4 id="检测签名"><a href="#检测签名" class="headerlink" title="检测签名"></a>检测签名</h4><p>Android对每一个Apk文件都会进行签名，在Apk文件安装时，系统会对其签名信息进行比对，判断程序的完整性，从而决定该Apk文件是否可以安装，在一定程度上达到安全的目的。</p>
<ol>
<li>MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。</li>
<li>CERT.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。</li>
<li>CERT.RSA文件中保存了公钥、所采用的加密算法等信息。系统对签名文件进行解密，所需要的公钥就是从这个文件里取出来的。<br>这三个文件在apk META-INFO文件夹</li>
</ol>
<p>结论：从上面的总结可以看出，META-INFO里面的说那个文件环环相扣，从而保证Android程序的安全性。（只是防止开发者的程序不被攻击者修改，如果开发者的公私钥对对攻击者得到或者开发者开发出攻击程序，Android系统都无法检测出来。）</p>
<p>虽然系统通过以上方式可以防止，但如果是root的手机就不安全了，建议通过服务器来校验，</p>
<h4 id="校验classes-dex"><a href="#校验classes-dex" class="headerlink" title="校验classes.dex"></a>校验classes.dex</h4><p><strong>用crc32对classes.dex文件的完整性进行校验</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="meta">@Override</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(BundlesavedInstanceState)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"> </div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"> </div><div class="line">    String apkPath = getPackageCodePath();</div><div class="line"> </div><div class="line">    Long dexCrc = Long.parseLong(getString(R.string.classesdex_crc));</div><div class="line">    <span class="comment">//建议将dexCrc值放在服务器做校验</span></div><div class="line"> </div><div class="line">    <span class="keyword">try</span></div><div class="line"> </div><div class="line">    &#123;</div><div class="line"> </div><div class="line">        ZipFile zipfile = <span class="keyword">new</span> ZipFile(apkPath);</div><div class="line"> </div><div class="line">        ZipEntry dexentry = zipfile.getEntry(<span class="string">"classes.dex"</span>);</div><div class="line"> </div><div class="line">        Log.i(<span class="string">"verification"</span>,<span class="string">"classes.dexcrc="</span>+dexentry.getCrc());</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(dexentry.getCrc() != dexCrc)&#123;</div><div class="line"> </div><div class="line">        Log.i(<span class="string">"verification"</span>,<span class="string">"Dexhas been modified!"</span>);</div><div class="line"> </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line"> </div><div class="line">        Log.i(<span class="string">"verification"</span>,<span class="string">"Dex hasn't been modified!"</span>);</div><div class="line"> </div><div class="line">        &#125;</div><div class="line"> </div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"> </div><div class="line">     <span class="comment">// TODO Auto-generated catch block</span></div><div class="line"> </div><div class="line">     e.printStackTrace();</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="校验整个apk"><a href="#校验整个apk" class="headerlink" title="校验整个apk"></a>校验整个apk</h4><p>用哈希值对整个apk完整性进行校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="meta">@Override</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(BundlesavedInstanceState)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"> </div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"> </div><div class="line">   </div><div class="line"> String apkPath = getPackageCodePath();</div><div class="line"> </div><div class="line">     MessageDigest msgDigest = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line"> </div><div class="line">        msgDigest = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> byteCount;</div><div class="line"> </div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(apkPath));</div><div class="line"> </div><div class="line">        <span class="keyword">while</span> ((byteCount = fis.read(bytes)) &gt; <span class="number">0</span>)</div><div class="line"> </div><div class="line">        &#123;</div><div class="line"> </div><div class="line">            msgDigest.update(bytes, <span class="number">0</span>, byteCount);</div><div class="line"> </div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, msgDigest.digest());</div><div class="line"> </div><div class="line">        String sha = bi.toString(<span class="number">16</span>);</div><div class="line"> </div><div class="line">        fis.close();</div><div class="line"> </div><div class="line">        <span class="comment">//这里添加从服务器中获取哈希值然后进行对比校验</span></div><div class="line"> </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> </div><div class="line">            e.printStackTrace();</div><div class="line"> </div><div class="line">        &#125;</div><div class="line"></div><div class="line"> </div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将把crc值和sha1值放在服务器做处理，做个记录。</p>
<p>更多Android 之美，请阅读<a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external">《Android 之美 从0到1 – 高手之路》</a>系列文章</p>
<blockquote>
<p>水平有限，若有错漏，欢迎指正，批评，如需转载，请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a>，谢谢！</p>
<p>作者：fuchenxuan<br>出处：<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a><br>欢迎访问我的个人站点：<a href="http://fuchenxuan.cn" target="_blank" rel="external">http://fuchenxuan.cn</a><br>转载请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a></p>
</blockquote>
<p><a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160608234402229" alt="Android 之美 从0到1"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;APK 完整性校验，虽然很难做到绝对的安全，但能提高应用的安全性和破解难度,下面简单记录一下Apk完整性的校验方案。&lt;/p&gt;
&lt;h2 id=&quot;一、认识APK安全性&quot;&gt;&lt;a href=&quot;#一、认识APK安全性&quot; class=&quot;headerlink&quot; title=&quot;一、认识AP
    
    </summary>
    
      <category term="安全" scheme="http://fushenghua.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>APK 瘦身，减少APK体积的大小</title>
    <link href="http://fushenghua.github.io/archives/db6d97a8.html"/>
    <id>http://fushenghua.github.io/archives/db6d97a8.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.634Z</updated>
    
    <content type="html"><![CDATA[<p>让我们的apk文件尽可能更小，移除那些未使用的代码和资源文件。本章节介绍了如何做到让APK更小，性能更好，下载转化率会更高，以及如何指定在构建APK过程中保留或移除项目中的代码和资源，在我们还没有分析APK大小之前，项目中存在一些资源放置处理不当，没有统一的规范，依赖管理不合理，资源重叠，dex方法数过多、文件过大等问题，导致整个APK文件也比较大，对于下载转化率必然有一定的影响。</p>
<p>[TOC]</p>
<h1 id="分析APK的大小"><a href="#分析APK的大小" class="headerlink" title="分析APK的大小"></a>分析APK的大小</h1><p>古人云：工欲善其事，必先利其器，我们得先有利器，下面就是我们常用的分析APK大小工具的利器做一些简单的介绍和使用，帮助我们分析造成APK体积较大的元凶，以便于我们从那些方面入手优化。</p>
<h3 id="使用Android-Studio-2-2"><a href="#使用Android-Studio-2-2" class="headerlink" title="使用Android Studio 2.2"></a>使用Android Studio 2.2</h3><p>Android Studio 2.2 新功能直接能分析APK的大小，双击打开就能看到那些占用APK比例大，方法数等。</p>
<p><img src="http://img.blog.csdn.net/20160821125248173" alt="这里写图片描述"></p>
<ul>
<li>分析任何的APK</li>
<li>查看APK下载包的大小，解压后的实际大小</li>
<li>反编译资源文件，还原layout中的资源id，代码</li>
<li>分析dex，显示每部分的方法数，直接查看那些library体积比较大</li>
</ul>
<p>使用方法：Build -&gt; Analyz APK</p>
<p>有了<code>Analyz APK</code>这个利器，以下工具也可以基本不用了</p>
<h3 id="NimbleDroid"><a href="#NimbleDroid" class="headerlink" title="NimbleDroid"></a>NimbleDroid</h3><p><a href="https://nimbledroid.com/" target="_blank" rel="external">NimbleDroid</a> 是美国哥伦比亚大学的博士创业团队研发出来的自动化分析Android app性能指标的系统，分析的方式有静态和动态两种方式，其中静态分析可以分析出APK安装包中大文件排行榜，各种知名SDK的大小以及占代码整体的比例，各种类型文件的大小以及占排行，各种知名SDK的方法数以及占所有dex中方法数的比例,针对缓慢的方法，缓慢的第三方SDK和内存泄漏。<br>测量生成的速度、网络、内存和磁盘使用率。总之有非常多分析App性能的功能，如果要做性能优化，也可以尝试使用<a href="https://nimbledroid.com/" target="_blank" rel="external">NimbleDroid</a>。</p>
<p>查看详细的方法耗时</p>
<p><img src="https://nimbledroid.com/assets/home/img-2nd-section-a313c4d4a955152934fbc2999bbbb266.png" alt=""></p>
<p>具体使用方法请看官网：<br><a href="https://nimbledroid.com/" target="_blank" rel="external">https://nimbledroid.com/</a></p>
<p>不过需要注意的是<a href=""><strong>不要上传任何未发布的产品</strong></a>。</p>
<h3 id="ClassShark"><a href="#ClassShark" class="headerlink" title="ClassShark"></a>ClassShark</h3><p>ClassShark 是一款查看Android执行文件（apk）的浏览工具，目前有两个android App（Apk）和桌面（jar）的版本。<br>使用这款工具，可以很方便的打开APK/Class/Jar/res<br>等 文件和分析里面的内容。</p>
<p><img src="https://github.com/borisf/classyshark-user-guide/raw/master/images/5%20ClassesDexData.png" alt=""></p>
<p>具体源码与使用方法详细在github中：<br><a href="https://github.com/google/android-classyshark" target="_blank" rel="external">https://github.com/google/android-classyshark</a></p>
<p>通过以上任一工具分析我们知道我们项目中主要是以下文件占用APK大小：</p>
<ul>
<li><p><strong>classes.dex</strong><br>   classes.dex是java源码编译后生成的java字节码文件，</p>
</li>
<li><p><strong>res</strong><br>  主要是存放我们的图片资源</p>
</li>
<li><p><strong>resources.arsc</strong><br>  编译后的二进制资源文件，非常多无效资源文件(语言)</p>
</li>
<li><p><strong>assets</strong><br>  主要存放了我们的缓存数据文件，已做最优化压缩，我们考虑能否云端存放。</p>
</li>
<li><p><strong>lib</strong></p>
<pre><code>主要是存放我们的so库，目前我们已经优化了
</code></pre></li>
</ul>
<p>既然知道了那些数据导致我们APK体积大，那么我们就着手瘦身了。</p>
<h1 id="对APK进行瘦身"><a href="#对APK进行瘦身" class="headerlink" title="对APK进行瘦身"></a>对APK进行瘦身</h1><h2 id="对资源进行极限压缩"><a href="#对资源进行极限压缩" class="headerlink" title="对资源进行极限压缩"></a>对资源进行极限压缩</h2><p>对资源进行极限压缩，主要是对如：res里面用到的图片资源文件和assets文件夹下的一些html，db等一些缓存预留在APK的数据文件</p>
<ul>
<li>assets资源压缩，使用7zip或者lzma压缩方式最高，把文件打包压缩</li>
<li>res 图片资源的压缩，使用tinypng优化Android的资源图片，通常我们可以在保证图片不失真的情况下，多压缩几次。目前tinypng已经支持png和jpg图片、.9图的压缩  </li>
<li>将非alpha的图转换成jpg形式</li>
</ul>
<p>通过以上方法我们图片降低了79%的大小。</p>
<h3 id="使用WEBP，SVG图片资源格式"><a href="#使用WEBP，SVG图片资源格式" class="headerlink" title="使用WEBP，SVG图片资源格式"></a>使用WEBP，SVG图片资源格式</h3><ul>
<li>WebP是谷歌研发出来的一种图片数据格式，它是一种支持有损压缩和无损压缩的图片文件格式，如果应用支持到Android 4.0+，那么我们可以使用WebP格式代替PNG，我们的资源大小能降低50%多。或者有些资源可以使用SVG图片资源更小。<br>以下是他们的对比图：</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160821131133417" alt="这里写图片描述"></p>
<p>  这里提供方便转换的WEBP资源的工具：</p>
<ul>
<li><a href="https://isparta.github.io/" target="_blank" rel="external">https://isparta.github.io/</a></li>
<li><a href="https://imageoptim.com/mac" target="_blank" rel="external">https://imageoptim.com/mac</a></li>
</ul>
<ul>
<li>使用VectorDrawable和SVG图片来替换原有图片<br>  使用SVG不用考虑屏幕适配问题，体积非常小。</li>
</ul>
<h3 id="利用AndResGuard资源压缩打包工具"><a href="#利用AndResGuard资源压缩打包工具" class="headerlink" title="利用AndResGuard资源压缩打包工具"></a>利用AndResGuard资源压缩打包工具</h3><p>微信中的资源混淆工具主要为了混淆资源ID长度(例如将res/drawable/icon.png,png变成混淆为r/s/a.png)，同时利用7z深度压缩、对png的存储方式做了改变占用内存更小，大大减少了安装包体积</p>
<p>具体源码与使用方法详细在github中：</p>
<p><a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="external">https://github.com/shwenzhang/AndResGuard</a></p>
<h2 id="清除你的代码和资源"><a href="#清除你的代码和资源" class="headerlink" title="清除你的代码和资源"></a>清除你的代码和资源</h2><p>通过上面的图片资源极限压缩能对APK减小不少，但这往往这些还是不够的，项目里还有很多未使用的资源文件，重复的资源等，这里主要参考Google官方文档<a href="https://developer.android.com/studio/build/shrink-code.html#shrink-code" target="_blank" rel="external">https://developer.android.com/studio/build/shrink-code.html#shrink-code</a> 部分，利用Android Plugin开启gradle 的<code>Code shrinking</code>和<code>ProGuard</code>结合使用。</p>
<ul>
<li><p><code>ProGuard</code>能够检测和删除未使用的类，字段，方法，和从你的打包应用程序的属性，包括那些包含代码库，<a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html" target="_blank" rel="external">ProGuard</a>是一个混淆优化字节码的工具,能够删除一些未使用的代码，混淆使用的类，字段，方法和短名称，经过混淆处理也能够使APK源代码得到保护</p>
</li>
<li><p><code>Code shrinking</code>是一个Android Plugin for Gradle，从您的打包的应用程序中删除未使用的资源，包括代码库中的未使用的资源。它工作在与代码缩小，这样，一旦未使用的代码已被删除，任何资源不再引用可以安全地删除。</p>
</li>
</ul>
<p>该功能需要依赖于：</p>
<ul>
<li>SDK Tools 25.0.10 或更高</li>
<li>Android Plugin for Gradle 2.0.0 或更高</li>
</ul>
<h3 id="清除无用代码"><a href="#清除无用代码" class="headerlink" title="清除无用代码"></a>清除无用代码</h3><p>code shrinking需要结合ProGuard使用，添加<code>minifyEnabled</code> <code>true</code>在你的<code>build.gradle</code>文件中。</p>
<blockquote>
<p>需要注意code shrinking会减慢Gradle 编译，应避免使用它在您的调试版本中使用它。Android Studio禁用ProGuard使用 <a href="https://developer.android.com/tools/building/building-studio.html#instant-run" target="_blank" rel="external">Instant Run</a>.。<br>例如，以下从<code>build.gradle</code>文件片段，使<code>code shrinking</code>为发布版本</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="section">android</span> &#123;</div><div class="line">    <span class="section">buildTypes</span> &#123;</div><div class="line">        <span class="section">release</span> &#123;</div><div class="line">            <span class="attribute">minifyEnabled</span> <span class="literal">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(‘proguard-android.txt<span class="string">'),</span></div><div class="line">                    'proguard-rules.pro<span class="string">'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>getDefaultProguardFile(‘proguard-android.txt&#39;)</code>默认ProGuard设置来自于Android SDK <code>tools/proguard/</code>中的文件夹</p>
<blockquote>
<p>更多的减少代码可以尝试使用相同位置的<code>proguard-android-optimize.txt</code>文件（这样能让我们的APK又减少了0.5M以上）proguard-rules.pro是你自定义的proguard规则。</p>
</blockquote>
<p>那么我们怎么知道每一次build，删除了和未删除那些资源和代码呢，ProGuard会输出以下文件在<code>/build/outputs/mapping/release/</code>:</p>
<ul>
<li><strong>dump.txt</strong><br>描述.apk文件中所有类文件间的内部结构</li>
<li><strong>mapping.txt</strong><br>列出了原始的类，方法和字段名与混淆后代码间的映射。这个文件很重要，当你从release版本中收到一个bug报告时，可以用它来翻译被混淆的代码。</li>
<li><strong>seeds.txt</strong><br>列出了未被混淆的类和成员</li>
<li><strong>usage.txt</strong><br>列出了从.apk中删除的代码</li>
<li><strong>resources.txt</strong><br>列出resource被保留的资源</li>
</ul>
<h3 id="自定义混淆规则"><a href="#自定义混淆规则" class="headerlink" title="自定义混淆规则"></a>自定义混淆规则</h3><p>在某些情况下，默认的混淆器配置文件<code>proguard-android.txt</code>文件是会移除所有只有未使用的代码，但也有可能会误删除了你需要的代码，所以要注意以下几种情况：</p>
<ul>
<li>在<code>AndroidManifest.xml</code>配置的文件类</li>
<li>使用了JNI 的接口方法</li>
<li>运行时反射调用方法(不过现在ProGuard已经可以处理这种了)</li>
</ul>
<p>添加-keep来忽略一下防止被混淆的代码到proguard-rules.pro文件中，比如：</p>
<p><code>-keep public class MyClass</code></p>
<p>另外也可以使用<a href="https://developer.android.com/reference/android/support/annotation/Keep.html" target="_blank" rel="external">@Keep </a>注解在你的需要忽略的代码中，需要<a href="https://developer.android.com/tools/support-library/features.html#annotations" target="_blank" rel="external">Annotations Support Library</a>的支持</p>
<p>有关自定义proguard-rules.pro文件的更多信息，可以参考<a href="http://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html" target="_blank" rel="external">ProGuard Manual.</a>这里<a href="http://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/troubleshooting.html" target="_blank" rel="external">Troubleshooting</a>列出了一些常见的问题。</p>
<h3 id="清除无用的资源文件"><a href="#清除无用的资源文件" class="headerlink" title="清除无用的资源文件"></a>清除无用的资源文件</h3><p><code>Resource shrinking</code> 需要和<code>Code shrinking</code> 一起使用。在代码中删除所有未使用的代码后，<code>Resource shrinking</code>才可以知道哪些资源APK程序仍然使用，你必须先删除未使用的代码，Resource才会成为无用的，从而被清除掉。</p>
<p>添加<code>shrinkResources</code> <code>true</code>属性在你的 build.gradle文件中，相应代码块如下：</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            shrinkResources <span class="literal">true</span></div><div class="line">            minifyEnabled <span class="literal">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="symbol">'proguard</span>-android.txt'),</div><div class="line">                    <span class="symbol">'proguard</span>-rules.pro'</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>resource shrinker</code> 目前还不支持移除定义在values/目录下的资源文件(strings,dimensions,styles,colors),因为Android Asset Packaging Tool（AAPT）不允许Gradle Plugin指定预定义的版本资源<a href="https://code.google.com/p/android/issues/detail?id=70869" target="_blank" rel="external">[issue 70869]</a></p>
</blockquote>
<h3 id="指定要忽略的资源文件"><a href="#指定要忽略的资源文件" class="headerlink" title="指定要忽略的资源文件"></a>指定要忽略的资源文件</h3><p>如果我们希望保留或丢弃特定的资源，需要在项目中创建一个XML文件，并使用<code>resources</code>标签，并指定每个资源保存在工具中<code>tools:keep</code>和每个资源在工具中丢弃 <code>tools:discard</code>。两个属性都可以使用逗号(,)分隔符声明资源名称列表。也可以使用* 作为匹配符，匹配名称。</p>
<p>相应代码块如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></div><div class="line">    <span class="attr">tools:keep</span>=<span class="string">"@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*"</span></div><div class="line">    <span class="attr">tools:discard</span>=<span class="string">"@layout/unused2"</span> /&gt;</div></pre></td></tr></table></figure>
<p>需要在项目resources目录保存res/raw/keep.xml文件，build的时候该文件不会被打包到APK里面。</p>
<h3 id="启用严格的检测"><a href="#启用严格的检测" class="headerlink" title="启用严格的检测"></a>启用严格的检测</h3><p>通常情况下，<code>resource shrinker</code>可以准确地确定资源使用。如果你使用<code>Resources.getIdentifier()</code>动态获取指定资源的Id，在默认情况下，这样资源具有匹配名称的格式为潜在的使用，无法去除。</p>
<p>例如，下面的代码将导致所有img_前缀的资源都无法去除。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">String name</span> = String.format(<span class="string">"img_%1d"</span>, angle + 1);</div><div class="line"><span class="attribute">res</span> = getResources().getIdentifier(name, <span class="string">"drawable"</span>, getPackageName());</div></pre></td></tr></table></figure>
<p><code>resource shrinker</code> 也通过搜索代码中是否包含资源名来判断是否在build的时候删除。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></div><div class="line">    <span class="attr">tools:shrinkMode</span>=<span class="string">"strict"</span> /&gt;</div></pre></td></tr></table></figure>
<p>在 resource 文件中指定 shrinkMode，你可以指定 Gradle 在处理该资源文件时候的方式，默认的值为 safe，你也可以将它指定为 strict（只会保留有明确引用的资源，以及处理被 <code>tools:keep</code> 和 <code>tools:discard</code> 标注的资源）</p>
<p>在后面<strong>查看资源回收</strong>情况，我们会讲到，会遇到有些xml 无法被清除的问题，使用shrinkMode可以解决这个问题。</p>
<h3 id="清除未使用的替代资源"><a href="#清除未使用的替代资源" class="headerlink" title="清除未使用的替代资源"></a>清除未使用的替代资源</h3><p>Gradle <code>resource shrinker</code> 只删除你在代码中未使用资源，这意味着它不会删除不同的设备配置的可替代资源。如果有必要，你可以使用<code>Android Gradle plugin</code> 的<code>resconfigs</code>属性删除替代资源文件。</p>
<p>例如：我们项目中适配10种国家语言，而项目依赖了v7、v4等其他support包里面包含20种国家语言，那么我们可以通过resconfigs 删除剩余的可替代资源文件，这对于我们APK大小可减少了不少，</p>
<p>以下代码说明了如何限制你的语言资源，只是英语和法语：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class">android </span>&#123;</div><div class="line">    <span class="class">defaultConfig </span>&#123;</div><div class="line">        ...</div><div class="line">        resConfigs <span class="string">"en"</span>, <span class="string">"fr"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像上面那样通过<code>resconfig</code>属性指定的语言。未指定的语言的任何资源都被删除。</p>
<p>同样的图片资源我们也可以这么做，例如：我们提供一套xxhdpi的图片资源，其他的都过滤清除掉，这样大量清除了support，其他第三方library的资源文件，关于这个待会我们在后面会说。</p>
<h3 id="合并重复的资源"><a href="#合并重复的资源" class="headerlink" title="合并重复的资源"></a>合并重复的资源</h3><p>默认情况下，Gradle也将同名的资源，比如相同的名字，可能是在不同的资源文件夹下，这样子不能通过shrinkResources属性来去除。</p>
<p>只有当两个或多个文件共享相同的资源名称、类型和限定符时才发生资源合并，关于资源的合并优先级如下：</p>
<p>Gradle 主要从以下位置合并资源：</p>
<ul>
<li>src/main/res/ 主要资源</li>
<li>Gradle 使用variant(build type 和 build flavors) </li>
<li>Library的依赖使用</li>
</ul>
<p>Gradle合并重复资源优先顺序为：</p>
<p>Dependencies → Main → Build flavor → Build type</p>
<p>例如：如果一个重复的资源在你的mian res中和一个Build flavor指定 ，Gradle 会优先选择Build flavor</p>
<h3 id="查看资源回收"><a href="#查看资源回收" class="headerlink" title="查看资源回收"></a>查看资源回收</h3><p>当你Gradle <code>resource shrinker</code>，Gradle Console 输出日志，移除APK资源的信息。例如:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">:android:shrinkDebugResources</span></div><div class="line">Removed unused resources: Binary resource data reduced from 2570KB to 1711KB: Removed 33%</div><div class="line"><span class="meta">:android:validateDebugSigning</span></div></pre></td></tr></table></figure>
<p>APK构建完成后会Gradle会生成一个resource.txt 在 <module-name>/build/outputs/mapping/release/ 中，这个文件包括详细信息，如资源参考其他资源和使用或删除资源的详细信息等。</module-name></p>
<p>例如：找出为什么<code>@drawable/ic_plus_anim_016</code>，仍然包含在你的APK中，在resource.txt 搜索该文件名，你可能会发现它是被另一个资源引用，如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">16<span class="selector-pseudo">:25</span><span class="selector-pseudo">:48.005</span> <span class="selector-attr">[QUIET]</span> <span class="selector-attr">[system.out]</span> @<span class="keyword">drawable</span>/<span class="keyword">add_schedule_fab_icon_anim</span> : reachable=true</div><div class="line"><span class="number">16</span>:<span class="number">25</span>:<span class="number">48.009</span> [QUIET] [system.out]     @drawable/ic_plus_anim_016</div></pre></td></tr></table></figure>
<p>现在需要知道为什么<code>@drawable/add_schedule_fab_icon_anim</code> 仍然在使用，搜索我们可以知道应该有代码引用着<code>add_schedule_fab_icon_anim</code>。</p>
<p>如果你不使用严格的检查（就是上面讲的<code>shrinkMode</code>），同样的我们如果我们在drawable中使用了字符串’#FFFFFF‘ 这样的使用<code>resource shrinker</code>也不能将他移除在APK中，通常我们可以在Gradle Console中看到以下信息：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>:<span class="number">32</span>:<span class="number">50.590</span> [QUIET] [<span class="keyword">system</span>.out] Marking drawable:ic_plus_anim_016:<span class="number">2130837506</span></div><div class="line">    used because <span class="keyword">it</span> <span class="built_in">format</span>-<span class="keyword">string</span> matches <span class="keyword">string</span> pool <span class="built_in">constant</span> ic_plus_anim_%<span class="number">1</span>$d.</div></pre></td></tr></table></figure>
<p>那么这种情况我们如何解决呢，可以通过以下方法来清理：</p>
<ul>
<li>使用tools:discard，在 tools:shrinkMode=”strict” 的时候生效，指定某资源文件需要删除。在你确定该资源文件无效的时候使用。</li>
<li><p>利用Lint找出未使用的资源并清理掉</p>
<blockquote>
<p>在Android Studio中打开“Analyze” 然后选择”Inspect Code…”，范围选择整个项目，然后点击”OK”</p>
</blockquote>
</li>
</ul>
<p>到这里APK的大小又小了不少。</p>
<h2 id="使用APK-Splits构建APK"><a href="#使用APK-Splits构建APK" class="headerlink" title="使用APK Splits构建APK"></a>使用APK Splits构建APK</h2><p>虽然我们上面很好的使用了<code>resource shrinker</code>可以回收一些未使用的资源(v7、v4、google Service 等Libarry资源)，但有些资源仍然未被清除。</p>
<p>例如：那些未使用的多套替代资源，或者是library内部隐患着引用着的资源而我们却没有使用到。或者是我们要根据用户的手机去提供不同版本的APK，如分辨率(xxhdpi,mhdpi等)，so库等。那么我们可以使用<code>APK Splits</code>大大的减少一些无用的资源，这里我们主要参考了<a href="http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits" target="_blank" rel="external">http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits</a> 文档。</p>
<p><code>APK Splits</code>比起使用 flavors，能让应用程序更有效地构建一些形式的多个apk。</p>
<p>多 apk 只支持以下类型：</p>
<ul>
<li>屏幕密度</li>
<li>ABI</li>
</ul>
<p>使用新的<code>APK Splits</code>，构建同一个应用程序的hdpi版本和mdpi版本，能够共享很多的任务 （如 javac，dx，proguard）。此外，它会被认为是一个单一的variant，并且同一个测试程序将会被用来测试每​​个多APK。</p>
<h3 id="按屏幕密度拆分"><a href="#按屏幕密度拆分" class="headerlink" title="按屏幕密度拆分"></a>按屏幕密度拆分</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">android</span> &#123;</div><div class="line">  ...</div><div class="line">  splits &#123;</div><div class="line">    density &#123;</div><div class="line">      <span class="literal">enable</span> <span class="keyword">true</span></div><div class="line">      <span class="literal">exclude</span> <span class="string">"ldpi"</span>, <span class="string">"tvdpi"</span>, <span class="string">"xxxhdpi"</span></div><div class="line">      compatibleScreens <span class="string">'small'</span>, <span class="string">'normal'</span>, <span class="string">'large'</span>, <span class="string">'xlarge'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>enable： 启用屏幕密度拆分机制</li>
<li>exclude： 默认情况下所有屏幕密度都包括在内，你可以移除一些密度。</li>
<li>include： 表示要包括哪些屏幕密度</li>
<li>reset()： 重置屏幕密度列表为只包含一个空字符串 （这能够实现，在与include一起使用时可以表示使用哪一个屏幕密度，而不是要忽略哪一些屏幕密度）</li>
<li>compatibleScreens：表示兼容屏幕的列表。这将会注入到manifest中匹配的 <compatible-screens> <screen> 节点。这个设置是可选的。</screen></compatible-screens></li>
</ul>
<p>构建完成后可以在out/apk/目录下看到多个版本的APK</p>
<h3 id="按-ABI-拆分"><a href="#按-ABI-拆分" class="headerlink" title="按 ABI 拆分"></a>按 ABI 拆分</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">android</span> &#123;</div><div class="line">  ...</div><div class="line">  splits &#123;</div><div class="line">    abi &#123;</div><div class="line">      <span class="literal">enable</span> <span class="keyword">true</span></div><div class="line">      reset()</div><div class="line">      <span class="literal">include</span> <span class="string">'x86'</span>, <span class="string">'armeabi-v7a'</span>, <span class="string">'mips'</span></div><div class="line">      universalApk <span class="keyword">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>enable： 启用ABI拆分机制</li>
<li>exclude： 默认情况下所有ABI都包括在内，你可以移除一些ABI。</li>
<li>include：指明要包含哪些ABI</li>
<li>reset()：重置ABI列表为只包含一个空字符串（这可以实现，在与include一起使用来可以表示要使用哪一个ABI，而不是要忽略哪一些ABI）</li>
<li>universalApk：指示是否打包一个通用版本（包含所有的ABI）。默认值为 false。</li>
</ul>
<p>例如：我们项目主要提供xxhdpi的图片资源，而项目中引用到了很多第三方库(v7、v4、google Service 等Libarry资源)我们无法使用到，那么我们可以通过这种方法来去除那些资源。这样我们的APK又减小了非常多。</p>
<h3 id="使用多版本的APK"><a href="#使用多版本的APK" class="headerlink" title="使用多版本的APK"></a>使用多版本的APK</h3><p><code>Multiple APK Support</code>是一个在Google Play，可以发布不同的应用程序，分别针对不同的设备配置特征。每个APK是一个完整的、独立的应用程序版本，但他们分享在Google Play相同的应用程序清单，必须共享相同的包名和与签名。Google Play 会自动给你匹配相应的APK，这样我们的APK 就可以是分不同版本构建需要资源文件，从而减小APK的大小。</p>
<p>通过发布有多个APK，我们可以：</p>
<ul>
<li>支持不同OpenGL的APK</li>
<li>支持不同的屏幕尺寸和密度的APK</li>
<li>支持不同的设备功能的APK</li>
<li>支持不同的平台版本的APK</li>
<li><p>支持不同的CPU架构，每个apk（如ARM、x86，MIPS等)的APK</p>
<p>更多相关信息请参考<a href="https://developer.android.com/google/play/publishing/multiple-apks.html#Concepts" target="_blank" rel="external">https://developer.android.com/google/play/publishing/multiple-apks.html#Concepts</a></p>
</li>
</ul>
<p>目前我们基于这个方案做了不同屏幕的APK。</p>
<h2 id="资源动态加载"><a href="#资源动态加载" class="headerlink" title="资源动态加载"></a>资源动态加载</h2><p>我们可以在项目中使用资源动态加载形式，例如：表情，语言，离线库等资源动态加载，减小APK的大小。</p>
<h2 id="依赖库优化"><a href="#依赖库优化" class="headerlink" title="依赖库优化"></a>依赖库优化</h2><ul>
<li>如果应用支持的最低版本是API14，那就不要使用android support库，或者分开使用android support库，用哪个引入哪个库(android-support-ui/android-support-core 等)虽然现在支持还不太好，Google servie 也是如此。</li>
<li>使用更轻量级的库代替，或者优化library的大小，不然自己写更好。</li>
<li>删除armable-v7包下的so、删除x86包下的so，基本上armable的so也是兼容armable-v7的，armable-v7a的库会对图形渲染方面有很大的改进，不过最好的是根据上面我们说的提供多版本APK，对不同的平台精简，再或者动态的加载so。</li>
<li>使用H5编写界面，图片云端获取</li>
<li>资源缓存库不放在assets下，云端获取更新。</li>
</ul>
<h2 id="支持插件化"><a href="#支持插件化" class="headerlink" title="支持插件化"></a>支持插件化</h2><p>未来对于一些独立业务模块，可以做成插件化动态加载，用户需要使用时，只需下载少部分插件。</p>
<h2 id="使用ReDex优化"><a href="#使用ReDex优化" class="headerlink" title="使用ReDex优化"></a>使用ReDex优化</h2><p>ReDex是Facebook开源一个减小安卓app大小以提高性能的工具，内嵌以及清除僵尸代码这样的优化来减小字节码，主要是对Dex进行了优化，能让APK 运行更快，不过需要多测试是否会崩溃。</p>
<p>教程很简单具体更详细的内容请参考：<br><a href="https://code.facebook.com/posts/998080480282805/open-sourcing-redex-making-android-apps-smaller-and-faster/" target="_blank" rel="external">https://code.facebook.com/posts/998080480282805/open-sourcing-redex-making-android-apps-smaller-and-faster/</a></p>
<p>github地址：<br><a href="https://github.com/facebook/redex.git" target="_blank" rel="external">https://github.com/facebook/redex.git</a></p>
<p>关于APK瘦身我们就总结到这了，应该还有很多更好的方案，若有错漏，欢迎补充。</p>
<blockquote>
<ul>
<li>author：傅声华(Silver)</li>
<li>phone：18911630016</li>
<li>e-mail:silverfu@tcl.com</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;让我们的apk文件尽可能更小，移除那些未使用的代码和资源文件。本章节介绍了如何做到让APK更小，性能更好，下载转化率会更高，以及如何指定在构建APK过程中保留或移除项目中的代码和资源，在我们还没有分析APK大小之前，项目中存在一些资源放置处理不当，没有统一的规范，依赖管理不
    
    </summary>
    
      <category term="性能优化" scheme="http://fushenghua.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>EventBus解析</title>
    <link href="http://fushenghua.github.io/archives/5f794a45.html"/>
    <id>http://fushenghua.github.io/archives/5f794a45.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-23T09:17:45.027Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。</p>
<p>作为一个消息总线主要有三个组成部分：</p>
<p>事件（Event）：可以是任意类型的对象。通过事件的发布者将事件进行传递。</p>
<p>事件订阅者（Subscriber）：接收特定的事件。</p>
<p>事件发布者（Publisher）：用于通知 Subscriber 有事件发生。可以在任意线程任意位置发送事件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-42b1c487b9640141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>上图解释了整个EventBus的大概工作流程：事件的发布者（Publisher）将事件（Event）通过post()方法发送。EventBus内部进行处理，找到订阅了该事件（Event）的事件订阅者（Subscriber）。然后该事件的订阅者（Subscriber）通过onEvent()方法接收事件进行相关处理（关于onEvent()在EventBus 3.0中有改动，下面详细说明）。</p>
<h2 id="二、EventBus的简单使用"><a href="#二、EventBus的简单使用" class="headerlink" title="二、EventBus的简单使用"></a>二、EventBus的简单使用</h2><p>1、把EventBus依赖到项目</p>
<p>build.gradle添加引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'de.greenrobot:eventbus:3.0.0-beta1'</span></div></pre></td></tr></table></figure>
<p>2、构造事件（Event）对象。也就是发送消息类<br>每一个消息类，对应一种事件。这里我们定义两个消息发送类。后面讲解具体作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewsEvent</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToastEvent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、注册/解除事件订阅（Subscriber）</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus<span class="selector-class">.getDefault</span>()<span class="selector-class">.register</span>(this);<span class="comment">//注册事件 其中this代表订阅者</span></div></pre></td></tr></table></figure>
<p>具体注册了对什么事件的订阅，这个需要onEvent()方法来说明。在EventBus 3.0之前，onEvent()方法是用来接收指定事件（Event）类型对象，然后进行相关处理操作。在EventBus 3.0之后，onEvent()方法可以自定义方法名，不过要加入注解@Subscribe。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过register(this)来表示该订阅者进行了订阅，通过onToastEvent(ToastEvent event)表示指定对事件ToastEvent的订阅。到这里订阅就完成了。</p>
<p>需要注意的是：一般在onCreate()方法中进行注册订阅。在onDestory()方法中进行解除订阅。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>4 、发送消息<br>订阅已经完成，那么便可以发送订阅了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> ToastEvent(<span class="string">"Toast,发个提示，祝大家新年快乐！"</span>));</div></pre></td></tr></table></figure>
<p>那么onToastEvent(ToastEvent event)会收到事件，并弹出提示。</p>
<p>EventBus的基础使用流程就是这样的。</p>
<p>其实，EventBus还有好多其他的功能。下面我们一个个介绍。</p>
<h2 id="三、EventBus的进阶使用"><a href="#三、EventBus的进阶使用" class="headerlink" title="三、EventBus的进阶使用"></a>三、EventBus的进阶使用</h2><h5 id="1-线程模式ThreadMode"><a href="#1-线程模式ThreadMode" class="headerlink" title="1.线程模式ThreadMode"></a>1.线程模式ThreadMode</h5><p>当你接收的的事件后，如果处于非UI线程，你要更新UI怎么办？如果处于UI线程，你要进行耗时操作，怎么办?等等其他情况，通过ThreadMode统统帮你解决。</p>
<p>用法展示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@Subscribe</span>(threadMode = ThreadMode.MainThread)</div><div class="line">    public void  onNewsEvent(NewsEvent event)&#123;</div><div class="line">        String message = event<span class="selector-class">.getMessage</span>();</div><div class="line">        mTv_message<span class="selector-class">.setText</span>(message);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用起来很简单，通过<code>@Subscribe(threadMode = ThreadMode.MainThread)</code>即可指定。<br>下面具体介绍下ThreadMode。</p>
<p>关于ThreadMode，一共有四种模式PostThread，PostThread，BackgroundThread以及Async。</p>
<p><strong>PostThread：</strong>事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程。</p>
<p><strong>MainThread: </strong>事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的。</p>
<p><strong>BackgroundThread：</strong>如果事件是在UI线程中发布出来的，那么事件处理就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么事件处理直接在该子线程中执行。所有待处理事件会被加到一个队列中，由对应线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。</p>
<p><strong>Async：</strong>事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程。</p>
<h5 id="2-priority事件优先级"><a href="#2-priority事件优先级" class="headerlink" title="2.priority事件优先级"></a>2.priority事件优先级</h5><p>事件的优先级类似广播的优先级，优先级越高优先获得消息。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当多个订阅者（Subscriber）对同一种事件类型进行订阅时，即对应的事件处理方法中接收的事件类型一致，则<strong>优先级高（priority 设置的值越大），则会先接收事件进行处理；优先级低（priority 设置的值越小），则会后接收事件进行处理。</strong></p>
<p>除此之外，EventBus也可以终止对事件继续传递的功能。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">       Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">       EventBus.getDefault().cancelEventDelivery(event);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这样其他优先级比100低，并且订阅了该事件的订阅者就会接收不到该事件。</p>
<h5 id="3-EventBus黏性事件"><a href="#3-EventBus黏性事件" class="headerlink" title="3.EventBus黏性事件"></a>3.EventBus黏性事件</h5><p>EventBus除了普通事件也支持粘性事件。可以理解成：订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅的方法有所不同，需要注解中添加sticky = true。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>,sticky = <span class="keyword">true</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">        EventBus.getDefault().cancelEventDelivery(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这样，假设一个ToastEvent 的事件已经发布，此时还没有注册订阅。当设置了sticky = true，在ToastEvent 的事件发布后，进行注册。依然能够接收到之前发布的事件。</p>
<p>不过这个时候，发布事件的方式就改变了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().postSticky(<span class="keyword">new</span> ToastEvent(<span class="string">"Toast,发个提示，祝大家新年快乐！"</span>));</div></pre></td></tr></table></figure>
<p>我们如果不再需要该粘性事件我们可以移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().removeStickyEvent(ToastEvent.class);</div></pre></td></tr></table></figure>
<p>或者调用移除所有粘性事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().removeAllStickyEvents();</div></pre></td></tr></table></figure>
<h5 id="4-EventBus配置"><a href="#4-EventBus配置" class="headerlink" title="4.EventBus配置"></a>4.EventBus配置</h5><p>EventBus在2.3版本中添加了EventBuilder去配置EventBus的各方各面。</p>
<p>比如：如何去构建一个在发布事件时没有订阅者时保持沉默的EventBus。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventBus eventBus = EventBus.builder()</div><div class="line">.logNoSubscriberMessages(<span class="keyword">false</span>)</div><div class="line">.sendNoSubscriberEvent(<span class="keyword">false</span>)</div><div class="line">.build();</div></pre></td></tr></table></figure>
<p>通过上述设置，当一个事件没有订阅者时，不会输出log信息，也不会发布一条默认信息。</p>
<p>配置默认的EventBus实例，使用EventBus.getDefault()是一个简单的方法。获取一个单例的EventBus实例。EventBusBuilder也允许使用installDefaultEventBus方法去配置默认的EventBus实例。</p>
<p><strong>注意：不同的EventBus 的对象的数据是不共享的。通过一个EventBus 对象去发布事件，只有通过同一个EventBus 对象订阅事件，才能接收该事件。所以以上使用EventBus.getDefault()获得的都是同一个实例。</strong></p>
<h2 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h2><p><code>EventBus</code>实现了观察者模式，使用方法非常简单</p>
<p>下面文章主要讲解EventBus的实现原理。<br>EventBus内部有一个map，当register时往map中增加一个元素(key为事件的类型，value为观察者)，post时根据事件类型找到观察者之后，对其反射调用。<br>下面我们从register方法开始：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span>(<span class="params">Object <span class="keyword">object</span></span>) </span>&#123;</div><div class="line">    Multimap, EventHandler&gt; methodsInListener =</div><div class="line">        finder.findAllHandlers(<span class="keyword">object</span>);</div><div class="line">    handlersByTypeLock.writeLock().<span class="keyword">lock</span>();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      handlersByType.putAll(methodsInListener);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      handlersByTypeLock.writeLock().unlock();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用eventBus.register(new Event())时，会将事件类型及观察者(封装为EventHandler)放置在SetMultimap, EventHandler&gt; handlersByType中，这是一个线程安全的对象容器，卸载事件也是在这个容器中做移除操作。根据事件类型查找观察者时使用了策略模式，HandlerFindingStrategy finder做为策略接口，目前只有一个策略实现AnnotatedHandlerFinder(查找带有Subscribe注解的方法)。<br>有了这样一个map，调用post时只需要根据类型找到观察者就行了：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span>(<span class="params">Object <span class="keyword">event</span></span>) </span>&#123;</div><div class="line">    Set&gt; dispatchTypes = flattenHierarchy(<span class="keyword">event</span>.getClass());</div><div class="line"></div><div class="line">    boolean dispatched = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (Class eventType : dispatchTypes) &#123;</div><div class="line">      handlersByTypeLock.readLock().<span class="keyword">lock</span>();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Set wrappers = handlersByType.<span class="keyword">get</span>(eventType);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!wrappers.isEmpty()) &#123;</div><div class="line">          dispatched = <span class="literal">true</span>;</div><div class="line">          <span class="keyword">for</span> (EventHandler wrapper : wrappers) &#123;</div><div class="line">            enqueueEvent(<span class="keyword">event</span>, wrapper);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        handlersByTypeLock.readLock().unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dispatched &amp;&amp; !(<span class="keyword">event</span> instanceof DeadEvent)) &#123;</div><div class="line">      post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, <span class="keyword">event</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispatchQueuedEvents();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里查找到参数匹配的<code>EventHandler</code>后并没有立刻执行反射调用，而是分发到了事件队列<code>（ThreadLocal&gt; eventsToDispatch）</code>中，当所有事件分发完毕之后，事件队列做统一的事件消费。</p>
<p>下面是一些EventBus源码解析。</p>
<h3 id="getDefault"><a href="#getDefault" class="headerlink" title="getDefault()"></a>getDefault()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">                <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> defaultInstance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过上述代码可以得知，getDefault()中通过双检查锁（DCL）机制实现了EventBus的单例机制，获得了一个默认配置的EventBus对象。<br>下面我们继续看register()方法。</p>
<h3 id="register"><a href="#register" class="headerlink" title="register()"></a>register()</h3><p>在了解register()之前，我们先要了解一下EventBus中的几个关键的成员变量。方便对下面内容的理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Map&lt;订阅事件, 订阅该事件的订阅者集合&gt; */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</div><div class="line"></div><div class="line"><span class="comment">/** Map&lt;订阅者, 订阅事件集合&gt; */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</div><div class="line"></div><div class="line"><span class="comment">/** Map&lt;订阅事件类类型,订阅事件实例对象&gt;. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</div></pre></td></tr></table></figure>
<p>下面看具体的register()中执行的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">        <span class="comment">//订阅者类型</span></div><div class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass(); </div><div class="line">        <span class="comment">//判断该类是不是匿名类，如果是匿名累要使用反射</span></div><div class="line">        <span class="keyword">boolean</span> forceReflection = subscriberClass.isAnonymousClass();</div><div class="line">        <span class="comment">//获取订阅者全部的响应函数信息（即上面的onNewsEvent()之类的方法）</span></div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods =</div><div class="line">                subscriberMethodFinder.findSubscriberMethods(subscriberClass, forceReflection);</div><div class="line">        <span class="comment">//循环每一个事件响应函数，执行 subscribe()方法，更新订阅相关信息</span></div><div class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">            subscribe(subscriber, subscriberMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由此可见，register()第一步获取订阅者的类类型. 第二步,通过SubscriberMethodFinder类来解析订阅者类,获取所有的响应函数集合. 第三步,遍历订阅函数,执行 subscribe()方法，更新订阅相关信息。<br>关于 subscriberMethodFinder这里就不介绍了。先跟着线索，继续看subscribe()方法。<br>subscribe 函数分三步。</p>
<p>第一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//获取订阅的事件类型</span></div><div class="line">  Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line"> <span class="comment">//获取订阅该事件的订阅者集合</span></div><div class="line">  CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line"><span class="comment">//把通过register()订阅的订阅者包装成Subscription 对象</span></div><div class="line">  Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">  <span class="comment">//订阅者集合为空，创建新的集合，并把newSubscription 加入</span></div><div class="line">  <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</div><div class="line">      subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Subscription&gt;();</div><div class="line">      subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//集合中已经有该订阅者，抛出异常。不能重复订阅</span></div><div class="line">      <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">                  + eventType);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="comment">//把新的订阅者按照优先级加入到订阅者集合中。</span></div><div class="line">  <span class="keyword">synchronized</span> (subscriptions) &#123;</div><div class="line">      <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">          <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">              subscriptions.add(i, newSubscription);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>第二步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//根据订阅者，获得该订阅者订阅的事件类型集合</span></div><div class="line"> List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line"><span class="comment">//如果事件类型集合为空，创建新的集合，并加入新订阅的事件类型。</span></div><div class="line"> <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">     subscribedEvents = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</div><div class="line">     typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line"> &#125;</div><div class="line"><span class="comment">//如果事件类型集合不为空，加入新订阅的事件类型</span></div><div class="line"> subscribedEvents.add(eventType);</div></pre></td></tr></table></figure>
<p>第三步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该事件是stick=true。</span></div><div class="line"><span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">            <span class="comment">//响应订阅事件的父类事件</span></div><div class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">                <span class="comment">//循环获得每个stickyEvent事件</span></div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                    <span class="comment">//是该类的父类</span></div><div class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                         <span class="comment">//该事件类型最新的事件发送给当前订阅者。</span></div><div class="line">                        Object stickyEvent = entry.getValue();</div><div class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>由此可见，第一步：通过subscriptionsByEventType得到该事件类型所有订阅者信息队列，根据优先级将当前订阅者信息插入到订阅者队列subscriptionsByEventType中；</p>
<p>第二步：在typesBySubscriber中得到当前订阅者订阅的所有事件队列，将此事件保存到队列typesBySubscriber中，用于后续取消订阅；<br>第三步：检查这个事件是否是 Sticky 事件，如果是则从stickyEvents事件保存队列中取出该事件类型最后一个事件发送给当前订阅者。</p>
<p>到此，便完成了订阅功能。下面是订阅的具体流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-210bce35b60a5481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h3 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取该订阅者所有的订阅事件类类型集合.</span></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">            unsubscribeByEventType(subscriber, eventType);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 从typesBySubscriber删除该&lt;订阅者对象,订阅事件类类型集合&gt;</span></div><div class="line">        typesBySubscriber.remove(subscriber);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Log.e(<span class="string">"EventBus"</span>, <span class="string">"Subscriber to unregister was not registered before: "</span></div><div class="line">                + subscriber.getClass());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取订阅事件对应的订阅者信息集合.</span></div><div class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</div><div class="line">            Subscription subscription = subscriptions.get(i);</div><div class="line">            <span class="comment">// 从订阅者集合中删除特定的订阅者.</span></div><div class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</div><div class="line">                subscription.active = <span class="keyword">false</span>;</div><div class="line">                subscriptions.remove(i);</div><div class="line">                i --;</div><div class="line">                size --;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>unregister()方法比较简单，主要完成了subscriptionsByEventType以及typesBySubscriber两个集合的同步。</p>
<h3 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取当前线程的Posting状态.</span></div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    <span class="comment">// 获取当前线程的事件队列.</span></div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    <span class="comment">//将当前事件添加到其事件队列</span></div><div class="line">    eventQueue.add(event);</div><div class="line">    <span class="comment">//判断新加入的事件是否在分发中</span></div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">        postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 循环处理当前线程eventQueue中的每一个event对象.</span></div><div class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 处理完知乎重置postingState一些标识信息.</span></div><div class="line">            postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">            postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>post 函数会首先得到当前线程的 post 信息PostingThreadState，其中包含事件队列，将当前事件添加到其事件队列中，然后循环调用 postSingleEvent 函数发布队列中的每个事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> </span>&#123;</div><div class="line">   <span class="comment">//分发事件的类型</span></div><div class="line">    Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">   <span class="comment">//响应订阅事件的父类事件</span></div><div class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">        <span class="comment">//找出当前订阅事件类类型eventClass的所有父类的类类型和其实现的接口的类类型</span></div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h ++) &#123;</div><div class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">            <span class="comment">//发布每个事件到每个订阅者</span></div><div class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">    &#125;</div><div class="line">....................................</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 postSingleEventForEventType 函数发布每个事件到每个订阅者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState,</span></span></div><div class="line">                                            Class&lt;?&gt; eventClass) &#123;</div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 获取订阅事件类类型对应的订阅者信息集合.(register函数时构造的集合)</span></div><div class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">            postingState.event = event;</div><div class="line">            postingState.subscription = subscription;</div><div class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 发布订阅事件给订阅函数</span></div><div class="line">                postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                aborted = postingState.canceled;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postingState.event = <span class="keyword">null</span>;</div><div class="line">                postingState.subscription = <span class="keyword">null</span>;</div><div class="line">                postingState.canceled = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (aborted) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 postToSubscription 函数向每个订阅者发布事件。<br>postToSubscription 函数中会判断订阅者的 ThreadMode，从而决定在什么 Mode 下执行事件响应函数。这里就不贴源码了。后续还牵着到反射以及线程调度问题，这里就不展开了。<br>以上就是post的流程，下面是具体的post的流程图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-6567ff2602475d05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。&lt;/p&gt;
&lt;p&gt;作为一个消息总线主要有三个组成部分：&lt;/p&gt;
&lt;p&gt;事件（Event）：可以是任意类型的对象。通过事件的发布者将事件进行
    
    </summary>
    
      <category term="源码" scheme="http://fushenghua.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>版本管理发布流程</title>
    <link href="http://fushenghua.github.io/archives/375726b.html"/>
    <id>http://fushenghua.github.io/archives/375726b.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.655Z</updated>
    
    <content type="html"><![CDATA[<p>为了在多个版本中并行开发，提高开发效率，保证各个版本和各个环境（开发、测试、主干）的独立，避免相互影响，减少最终发布时合并主干出现冲突的概率，降低冲突处理的难度，那么在团队开发过程中就需要一定的规范流程。</p>
<h3 id="版本命名规范"><a href="#版本命名规范" class="headerlink" title="版本命名规范"></a>版本命名规范</h3><p>软件版本号由四部分组成，第一个1为主版本号，第二个1为子版本号，第三个1为阶段版本号，第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有5种，分别为：base、alpha、beta、RC、release。例如：1.1.1.051021_beta。</p>
<h4 id="版本号修改规则"><a href="#版本号修改规则" class="headerlink" title="版本号修改规则"></a>版本号修改规则</h4><p>⑴ 主版本号(1)<br>当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。<br>⑵ 子版本号(1)<br>相对于主版本号而言，子版本号升级对应的是软件功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。<br>⑶ 阶段版本号(1)<br>一般是 Bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本号由项目经理决定是否修改。<br>⑷ 日期版本号(051021)<br>用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。<br>⑸ 希腊字母版本号(beta)<br>此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时需要修改此版本号。此版本号由项目决定是否修改。</p>
<h4 id="软件版本阶段说明"><a href="#软件版本阶段说明" class="headerlink" title="软件版本阶段说明"></a>软件版本阶段说明</h4><p>⑴ Base：<br>此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。<br>⑵ α（Alpha）版：内测版。<br>软件的初级版本，表示该软件在此阶段以实现软件功能为主，通常只在软件开发者 内部交流，或者专业测试人员测试用，一般而言，该版本软件的Bug较多，需要继续修改，是测试版本。测试人员提交Bug经开发人员修改确认之后，发布到测试网址让测试人员测试，此时可将软件版本标注为alpha版。<br>⑶ β（Beta）版：公测版。<br>该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI，供专业爱好者大规模测试用。<br>⑷ RC 版：<br>是 Release Candidate 的缩写，意思是发布倒计时，候选版本，该版本已经相当成熟了，完成全部功能并清除大部分的BUG，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。<br>⑷ Release 版：<br>该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。</p>
<h4 id="版本号修改举例说明"><a href="#版本号修改举例说明" class="headerlink" title="版本号修改举例说明"></a>版本号修改举例说明</h4><p>比如版本号为：1.0.0.0321_alpha ，此时为内部测试阶段<br>⑴ 开发人员修复了测试人员提交的bug并经测试人员测试验证关闭bug之后，发布到外网时，此时就进入了软件的下一个阶段，版本号可改为：1.0.0.0321_beta ，如当前日期跟上一个版本号的日期不一样，版本号可改为：1.0.0.0322_beta。<br>⑵ 如果修复了一些重大Bug 并按照流程发布到外网时就可发布一个修订版，如1.0.1.0322_beta，日期为发布的当前日期。<br>⑶ 如果对软件进行了一些功能上的改进或增强，进行了一些局部变动的时候要修改次版本号，如：1.1.0.0322_beta（上一级有变动时，下级要归零）。<br>⑷ 当功能模块有较大变动，增加模块或整体架构发生变化时要修改主版本号，如新增加了退款功能，则版本号要改为：2.0.0.0322_beta 。<br>⑸ 紧急情况：如果bug比较紧急可跳过一般流程，由开发人员尽快修复bug，测试确认之后直接发布该版本的beta版。</p>
<h4 id="APK-文件命名"><a href="#APK-文件命名" class="headerlink" title="APK 文件命名"></a>APK 文件命名</h4><p>appName_版本号，即中间用“下划线”分割。</p>
<h2 id="持续集成流程"><a href="#持续集成流程" class="headerlink" title="持续集成流程"></a>持续集成流程</h2><p>引用自百科的话来说，持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
<h2 id="项目自动化流程"><a href="#项目自动化流程" class="headerlink" title="项目自动化流程"></a>项目自动化流程</h2><p>在没有自动化的开发过程中，很多事就需要我们人为去做，那就增长我们的时间成本，而且难免会有疏忽的一些问题，比如某个配置文件忘改了，哪个版本出问题，代码的集成，重复构建等一些耗时且易于犯错的问题。</p>
<p>于是我们引入一些自动化的Java构建工具：</p>
<h3 id="Apache-Ant"><a href="#Apache-Ant" class="headerlink" title="Apache Ant"></a>Apache Ant</h3><p>Apache Ant，是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于Java环境中的软件开发。由Apache软件基金会所提供。默认情况下，它的buildfile(XML文件)名为build.xml。每一个buildfile含有一个<project>和至少一个预设的<target>，这些targets包含许多task elements。每一个task element有一个用来被参考的id，此id必须是唯一的</target></project></p>
<p>build.xml 示例：<br><figure class="highlight plain"><figcaption><span>version="1.0" ?> </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;project name=&quot;Hello World&quot; default=&quot;execute&quot;&gt;</div><div class="line"></div><div class="line">	&lt;target name=&quot;init&quot;&gt;</div><div class="line">		&lt;mkdir dir=&quot;build/classes&quot;/&gt;</div><div class="line">		&lt;mkdir dir=&quot;dist&quot;/&gt;</div><div class="line">	&lt;/target&gt;</div><div class="line">	&lt;target name=&quot;compile&quot; depends=&quot;init&quot;&gt;</div><div class="line">		&lt;javac srcdir=&quot;src&quot; destdir=&quot;build/classes&quot;/&gt;</div><div class="line">	&lt;/target&gt;</div><div class="line">	</div><div class="line">	&lt;target name=&quot;compress&quot; depends=&quot;compile&quot;&gt;</div><div class="line">	        &lt;jar destfile=&quot;dist/HelloWorld.jar&quot; basedir=&quot;build/classes&quot;  /&gt;</div><div class="line">	&lt;/target&gt;</div><div class="line"></div><div class="line">	&lt;target name=&quot;execute&quot; depends=&quot;compile&quot;&gt;</div><div class="line">		&lt;java classname=&quot;HelloWorld&quot; classpath=&quot;build/classes&quot;/&gt;</div><div class="line">	&lt;/target&gt;</div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Apache-Maven"><a href="#Apache-Maven" class="headerlink" title="Apache Maven"></a>Apache Maven</h3><p>Apache Maven，是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。<br>Maven也可被用于构建和管理各种项目，例如C#，Ruby，Scala和其他语言编写的项目。Maven曾是Jakarta项目的子项目，现为由Apache软件基金会主持的独立Apache项目</p>
<p>Maven项目使用项目对象模型（Project Object Model，POM）来配置。<br>项目对象模型存储在名为 pom.xml 的文件中。<br>以下是一个简单的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">  &lt;!-- model version is always 4.0.0 for Maven 2.x POMs --&gt;</div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line">  </div><div class="line">  &lt;!-- project coordinates, i.e. a group of values which</div><div class="line">       uniquely identify this project --&gt;</div><div class="line">  </div><div class="line">  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;my-app&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;1.0&lt;/version&gt;</div><div class="line"></div><div class="line">  &lt;!-- library dependencies --&gt;</div><div class="line">  </div><div class="line">  &lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">    </div><div class="line">      &lt;!-- coordinates of the required library --&gt;</div><div class="line">      </div><div class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</div><div class="line">      </div><div class="line">      &lt;!-- this dependency is only used for running and compiling tests --&gt;</div><div class="line">      </div><div class="line">      &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">      </div><div class="line">    &lt;/dependency&gt;</div><div class="line">  &lt;/dependencies&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>引自<a href="https://zh.wikipedia.org/wiki/Apache_Maven介绍" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Apache_Maven介绍</a></p>
<p>目前JavaEE使用Apache_Maven的比较多，而我们选择了Android Studio 内置的封装布署工具，拥有以上工具中优秀特性并且更棒的工具Gradle。</p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。[2]<br>当前其支持的语言限于Java、Groovy和Scala[3]，计划未来将支持更多的语言。</p>
<h4 id="使用-Gradle-的优势"><a href="#使用-Gradle-的优势" class="headerlink" title="使用 Gradle 的优势"></a>使用 Gradle 的优势</h4><pre><code>•    自动处理包相依关系 - 取自 Maven Repos 的概念
•    自动处理布署问题 - 取自 Ant 的概念
•    条件判断写法直觉 - 使用 Groovy 语言
</code></pre><p>过去 Java 开发者常用 Maven 和 Ant 等工具进行封装布署的自动化，或是两者兼用，不过这两个包彼此有优缺点，如果频繁改变相依包版本，使用 Ant 相当麻烦，如果琐碎工作很多，Maven 功能不足，而且两者都使用 XML 描述，相当不利于设计 if、switch 等判段式，即使写了可读性也不佳，而 Gradle 改良了过去 Maven、Ant 带给开发者的问题，至今也成为 Android Studio 内置的封装布署工具。</p>
<h2 id="代码检测流程"><a href="#代码检测流程" class="headerlink" title="代码检测流程"></a>代码检测流程</h2><p>在我们日常开发过程中，使用静态代码检查工具自动进行代码检查，对软件开发者来讲是有利的事情，因为这些工具相比人工方式，能更快捷的查找软件存在的缺陷。但是，在很多情况下，这些工具并没用被开发者所广泛采用。</p>
<p>尽管在我们开发中编译和测试的结果给出了一些产品健康状态的基本报告，但没有提供代码质量的基本报告，也没有任何地方可以查看到我们开发代码质量，产品质量的趋势，来帮助我们发现问题提升产品质量，我们公司内部构建平台会对代码质量，产品质量做一些分析，来推进产品的前进。</p>
<h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><p>在Java中有很多免费和商业的代码覆盖率工具，大多数这些工具都可以集成在我们的构建平台上。这里我们列举几个Gradle比较流行的代码覆盖率工具。</p>
<h4 id="Cobertura"><a href="#Cobertura" class="headerlink" title="Cobertura"></a>Cobertura</h4><p><a href="http://cobertura.sourceforge.net/" target="_blank" rel="external">Cobertura</a> 是一种开源工具，它通过检测基本的代码，并观察在测试包运行时执行了哪些代码和没有执行哪些代码，来测量测试覆盖率。除了找出未测试到的代码并发现 bug 外，Cobertura 还可以通过标记无用的、执行不到的代码来优化代码。</p>
<h4 id="Emma"><a href="#Emma" class="headerlink" title="Emma"></a>Emma</h4><p><a href="http://emma.sourceforge.net/" target="_blank" rel="external">EMMA</a> 是一个开源、面向 Java 程序测试覆盖率收集和报告工具。它通过对编译后的 Java 字节码文件进行插装，在测试执行过程中收集覆盖率信息，并通过支持多种报表格式对覆盖率结果进行展示。 EMMA 所使用的字节码插装不仅保证 EMMA 不会给源代码带来“脏代码”，还确保 EMMA 摆脱了源代码的束缚，这一特点使 EMMA 应用于功能测试成为了可能。</p>
<h4 id="Clover"><a href="#Clover" class="headerlink" title="Clover"></a>Clover</h4><p><a href="https://www.atlassian.com/software/clover" target="_blank" rel="external">Clover</a>是一款量度单元测试代码覆盖率（Code Coverage）的软件，用于检测Java单元测试是否完整覆盖代码中所有可能的路径，能够快速、准确地检测测试是否覆盖代码中的所有路径。</p>
<p>团队成员通过Code review来发现架构、逻辑设计方面、安全缺漏和一些潜在的bug，但随着项目业务的增长，Code review的过程难免也会疏忽很多潜在的bug等问题。</p>
<p>在我们工作中还有一些静态代码检查工具如<a href="http://checkstyle.sourceforge.net/" target="_blank" rel="external">Checkstyle</a>、<a href="http://findbugs.sourceforge.net/" target="_blank" rel="external">Findbugs</a>、<a href="http://pmd.sourceforge.net/" target="_blank" rel="external">PMD</a>等，将他们集成在我们的构建平台上，并成为我们构建流程中的一步骤。</p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>对于开发流程，在不同的项目团队中，开发流程不太一样，但大致可为：<br>每天下班前RD必须把今天工作代码全部提交到Git上。</p>
<p>####</p>
<ul>
<li>使用Jenkins CI ，每天定期会从Git上拉去最新代码，自定编译构建生成APK发出邮件，二维码等到产品维护人员的邮箱，并且将应用更新至公司内测分发平台。</li>
<li>编译构建成功，进行自动化测试、单元测试覆盖率（Cobertura、Emma或Clover等生成）、功能测试结果（如Selenium）、静态代码检查结果（Checkstyle、Findbugs、PMD等）</li>
<li>测试人员对产品进行test，测试中若有紧急问题也可以让开发人员可以随时修改提交代码。并且立即重新构建测试安装包。</li>
</ul>
<h2 id="打包和发布流程"><a href="#打包和发布流程" class="headerlink" title="打包和发布流程"></a>打包和发布流程</h2><p>以上版本管理发布流程只是参考指南，而不是具体规则。你可以根据自己实际情况来选择适合自己的版本管理发布流程或微调来满足自己的需要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了在多个版本中并行开发，提高开发效率，保证各个版本和各个环境（开发、测试、主干）的独立，避免相互影响，减少最终发布时合并主干出现冲突的概率，降低冲突处理的难度，那么在团队开发过程中就需要一定的规范流程。&lt;/p&gt;
&lt;h3 id=&quot;版本命名规范&quot;&gt;&lt;a href=&quot;#版本命名
    
    </summary>
    
      <category term="基础技能" scheme="http://fushenghua.github.io/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>git仓库迁移</title>
    <link href="http://fushenghua.github.io/archives/8e05eece.html"/>
    <id>http://fushenghua.github.io/archives/8e05eece.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.640Z</updated>
    
    <content type="html"><![CDATA[<p>最近又要把公司<code>Stash</code>上的项目在别部门一个私有仓库,平移到自己部门项目组的仓库，要求迁移的时候要保留已有的分支和以前的提交记录，类似的需求经常遇到，刚好做个记录。</p>
<p>1). 从原地址克隆一份裸版本库(纯仓库形式)，比如原本托管于 GitHub。</p>
<p><img src="/images/git--bare.png" alt="git--bare"></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">clone</span> <span class="title">--bare</span> git://github.com/username/project.git</div></pre></td></tr></table></figure>
<blockquote>
<p>–bare 创建的克隆版本库都不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。</p>
</blockquote>
<p>2). 然后到新的 Git 服务器上创建一个新项目，比如 GitCafe。</p>
<p>3). 以镜像推送的方式上传代码到 GitCafe 服务器上。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">cd</span> <span class="selector-tag">project</span><span class="selector-class">.git</span></div><div class="line"><span class="selector-tag">git</span> <span class="selector-tag">push</span> <span class="selector-tag">--mirror</span> <span class="selector-tag">git</span>@<span class="keyword">stash</span>.<span class="keyword">com</span>/<span class="keyword">username</span>/<span class="keyword">newproject</span>.<span class="keyword">git</span></div></pre></td></tr></table></figure>
<p><img src="/images/cd-push.png" alt="cd-push"></p>
<blockquote>
<p>– mirror 克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用git fetch命令和上游版本库进行持续同步。</p>
</blockquote>
<p>4). 到新服务器 Stash 上找到 Clone 地址，直接 Clone 到本地就可以了。</p>
<p><img src="/images/git-clone.png" alt="git-clone"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">git</span> <span class="selector-tag">clone</span> <span class="selector-tag">git</span>@<span class="keyword">Stash</span>.<span class="keyword">com</span>/<span class="keyword">username</span>/<span class="keyword">newproject</span>.<span class="keyword">git</span></div></pre></td></tr></table></figure>
<p>这种方式可以保留原版本库中的所有内容(<code>tag</code>,<code>branch</code>等记录)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又要把公司&lt;code&gt;Stash&lt;/code&gt;上的项目在别部门一个私有仓库,平移到自己部门项目组的仓库，要求迁移的时候要保留已有的分支和以前的提交记录，类似的需求经常遇到，刚好做个记录。&lt;/p&gt;
&lt;p&gt;1). 从原地址克隆一份裸版本库(纯仓库形式)，比如原本托管于 Gi
    
    </summary>
    
      <category term="基础技能" scheme="http://fushenghua.github.io/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>ViewStub原理分析</title>
    <link href="http://fushenghua.github.io/archives/235d5e38.html"/>
    <id>http://fushenghua.github.io/archives/235d5e38.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.646Z</updated>
    
    <content type="html"><![CDATA[<p>ViewStub 是一个看不见的，没有大小，不占布局位置的 View，可以用来懒加载布局。当 ViewStub 变得可见或 <code>inflate()</code> 的时候，布局就会被加载（替换 ViewStub）。因此，ViewStub 一直存在于视图层次结构中直到调用了 <code>setVisibility(int)</code> 或 <code>inflate()</code>。</p>
<p>我们先来看看构造方法：</p>
<p>非常简单的两步，就能做到View的懒加载，非常方便，其原因是什么呢？</p>
<p>接下去深入源码分析一下。</p>
<h2 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a>构造方法分析</h2><p>首先分析一下构造方法，了解一下它是如何创建的。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, @LayoutRes <span class="keyword">int</span> layoutResource)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">// StubbedView的资源id</span></div><div class="line">    mLayoutResource = layoutResource;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context);</div><div class="line">    <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs,</div><div class="line">            R.styleable.ViewStub, defStyleAttr, defStyleRes);</div><div class="line">    <span class="comment">// mInflatedId 存储StubbedView的id</span></div><div class="line">    mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);</div><div class="line">    <span class="comment">// mLayoutResource 为StubbedView的resourceId</span></div><div class="line">    mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, <span class="number">0</span>);</div><div class="line">    <span class="comment">// viewStub 自己的id</span></div><div class="line">    mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);</div><div class="line">    a.recycle();</div><div class="line">    <span class="comment">// 设置为不可见 </span></div><div class="line">    setVisibility(GONE);</div><div class="line">    <span class="comment">// 不绘制本身</span></div><div class="line">    setWillNotDraw(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ViewStub</code>在构造方法里不仅仅获取赋值属性，比较关键的是，还 默认将ViewStub自己设置为不可见（跳过onMeasure与onLayout），不绘制。</p>
<p>这里有一个要点：<strong>在XML里配置ViewStub的可见性是没有用的</strong>。</p>
<h2 id="测量-与-绘制"><a href="#测量-与-绘制" class="headerlink" title="测量 与 绘制"></a>测量 与 绘制</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@Override</span></div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    <span class="comment">// 写死的宽高为0</span></div><div class="line">    setMeasuredDimension(0, 0);</div><div class="line">&#125;</div><div class="line"><span class="variable">@Override</span></div><div class="line">public void draw(Canvas canvas) &#123;</div><div class="line">    <span class="comment">//空方法，不draw任何东西</span></div><div class="line">&#125;</div><div class="line"><span class="variable">@Override</span></div><div class="line">protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line">    <span class="comment">//空方法，不draw任何东西</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="inflate-方法分析"><a href="#inflate-方法分析" class="headerlink" title="inflate()方法分析"></a>inflate()方法分析</h2><p>之前在简单教程里有提到 <code>inflate</code>方法，它是<code>ViewStub</code>实现懒加载的最为关键的方法，接下去去分析一下。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回 StubbedView</span></div><div class="line"><span class="keyword">public</span> View inflate() &#123;</div><div class="line">    <span class="comment">// 尝试去获取 viewParent 第一次调用的时候不为null，而后则为null</span></div><div class="line">    <span class="keyword">final</span> ViewParent viewParent = getParent();</div><div class="line">    <span class="comment">// 当 viewParent 不为null的时候</span></div><div class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup) &#123;</div><div class="line">        <span class="comment">// 我们在xml里配置的layout的资源id 如果id无效，则会报错</span></div><div class="line">        <span class="keyword">if</span> (mLayoutResource != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ViewGroup <span class="keyword">parent</span> = (ViewGroup) viewParent;</div><div class="line">            <span class="comment">// 实例化 LayoutInflater</span></div><div class="line">            <span class="keyword">final</span> LayoutInflater factory;</div><div class="line">            <span class="keyword">if</span> (mInflater != <span class="keyword">null</span>) &#123;</div><div class="line">                factory = mInflater;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                factory = LayoutInflater.from(mContext);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// inflate，StubbedView在这里被实例化</span></div><div class="line">            <span class="keyword">final</span> View view = factory.inflate(mLayoutResource, <span class="keyword">parent</span>,</div><div class="line">                    <span class="keyword">false</span>);</div><div class="line">            <span class="comment">// 可以看到，这里如果我们在XML里写了inflateId，则会设置给StubbedView</span></div><div class="line">            <span class="keyword">if</span> (mInflatedId != NO_ID) &#123;</div><div class="line">                view.setId(mInflatedId);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 注意：这两步步 ViewSutb 找到自己的位置，并从父View中移除了自己</span></div><div class="line">            <span class="comment">// 这会导致 以后调用inflate的时候 再也获取不到 viewParent了</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = <span class="keyword">parent</span>.indexOfChild(this);</div><div class="line">            <span class="keyword">parent</span>.removeViewInLayout(this);</div><div class="line">            <span class="comment">// 拿出ViewStub的LayoutParamas，不为null 则会赋值给 StubbedView</span></div><div class="line">            <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = getLayoutParams();</div><div class="line">            <span class="comment">// 把 StubbedView 添加到ViewStub的父View里</span></div><div class="line">            <span class="keyword">if</span> (layoutParams != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">parent</span>.addView(view, index, layoutParams);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">parent</span>.addView(view, index);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//使用一个弱引用来保存StubbedView</span></div><div class="line">            mInflatedViewRef = <span class="keyword">new</span> WeakReference(view);</div><div class="line">            <span class="comment">//回调listener</span></div><div class="line">            <span class="keyword">if</span> (mInflateListener != <span class="keyword">null</span>) &#123;</div><div class="line">                mInflateListener.onInflate(this, view);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回 StubbedView</span></div><div class="line">            <span class="keyword">return</span> view;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// id无效，则throw一个 IllegalArgumentException</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ViewStub must have a valid layoutResource"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// inflate被调用一次后 就没有了ViewParent，就会报这个错</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ViewStub must have a non-null ViewGroup viewParent"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我在每行代码上都加上了详细的注释，主要的操作就是把StubbedView给Inflate出来，然后把它放到自己的位置，代码非常清晰，非常简单。</p>
<p>总结来说，其实<code>inflate</code>方法是做了一个『偷梁换柱』的操作，把 <code>StubbedView</code>动态的添加到自己原来的位置上，也因此实现了懒加载功能。</p>
<p>这里还需要注意的是 <strong>ViewStub 必须要有一个 Parent，即必须要有父视图！</strong><br>另外值得一提的是：ViewStub还重写了View的<code>setVisibility</code>方法，让我们来分析一下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setVisibility</span><span class="params">(<span class="keyword">int</span> visibility)</span> </span>&#123;</div><div class="line">    <span class="comment">// mInflatedViewRef 保存了 StubbedView还记得吗？ inflate过后它就不是null了 </span></div><div class="line">    <span class="keyword">if</span> (mInflatedViewRef != <span class="keyword">null</span>) &#123;</div><div class="line">        View view = mInflatedViewRef.get();</div><div class="line">        <span class="comment">// 操作 StubbedView</span></div><div class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">            view.setVisibility(visibility);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"setVisibility called on un-referenced view"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 操作ViewStub自己，构造方法里的GONE记得么？</span></div><div class="line">        <span class="keyword">super</span>.setVisibility(visibility);</div><div class="line">        <span class="comment">// 如果是 VISIBLE INVISIBLE 则会去调用 inflate方法！！！！</span></div><div class="line">        <span class="keyword">if</span> (visibility == VISIBLE || visibility == INVISIBLE) &#123;</div><div class="line">            inflate();<span class="comment">//注意这一行代码</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>setVisibility</code>方法中也可能会调用<code>inflate()</code>方法，所以当我们想让StubbedView被加载进来，而我们不需要StubbedView的实例的时候，可以用<code>setVisibility（View.VISIBLE）</code>。</p>
<p>不过需要注意的是 不要再接着调用<code>inflate</code>方法，因为此时的 ViewStub 已经被移除了！</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol>
<li>使用ViewStub，必须指定layoutResourceId(必须是布局文件)</li>
<li>在XML里配置ViewStub的可见性是没有用的</li>
<li>ViewStub 主要原理藏在<code>inflate()</code>方法中，是它把真正要加载的View给加载了进来</li>
<li><code>inflate()</code>方法只能调用一次</li>
<li>ViewStub调用<code>inflate()</code>后就不要再用它了（让它功成身退！）</li>
<li>要小心<code>setVisibility</code>方法，因为它可能会调用<code>inflate()</code></li>
<li>在XML里给ViewStub设置的LayoutParamas(宽高margin等)会传递给StubbedView,所以我们如果要控制StubbedView的LayoutParamas，则需要写在ViewStub里而不是StubbedView！</li>
<li>期待补充</li>
</ol>
<p>好了，主要的都分析完了，知道原理之后就可以自己动手写一个加强版的 ViewStub </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ViewStub 是一个看不见的，没有大小，不占布局位置的 View，可以用来懒加载布局。当 ViewStub 变得可见或 &lt;code&gt;inflate()&lt;/code&gt; 的时候，布局就会被加载（替换 ViewStub）。因此，ViewStub 一直存在于视图层次结构中直到调
    
    </summary>
    
      <category term="性能优化" scheme="http://fushenghua.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 之美 Android 进阶（一）</title>
    <link href="http://fushenghua.github.io/archives/2abed2d6.html"/>
    <id>http://fushenghua.github.io/archives/2abed2d6.html</id>
    <published>2016-04-09T03:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.625Z</updated>
    
    <content type="html"><![CDATA[<p>在前几篇文章中都是讲的基础，大家应该会觉得非常熟悉，但往往我们可能对于基础某些细节认识不够彻底或贯穿不全，我一直认为基础都是比较难的，那么本章节终于到进阶啦，主要讲的是View 的相关知识，在前面<a href="http://blog.csdn.net/vfush/article/details/51534916" target="_blank" rel="external">《Android 面试题总结之Android 基础 (六)》
</a>中已经对View有了一定的了解，由于内容较多且也是<strong>面试必考题</strong>，所以将分两篇继续深入的理解View。</p>
<blockquote>
<p>在阅读过程中有任何问题，请及时联系。如需转载请注明 <a href="http://blog.csdn.net/vfush" target="_blank" rel="external">fuchenxuan de Blog</a><br>  本章系<a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external">《Android 之美 从0到1 – 高手之路》</a>Android进阶（一）自定义View的过程</p>
</blockquote>
<p>[TOC]</p>
<h1 id="掌握"><a href="#掌握" class="headerlink" title="掌握"></a>掌握</h1><ol>
<li>什么是View?</li>
<li>View 坐标的基本概念</li>
<li>View的生命周期</li>
<li>如何自定义View</li>
</ol>
<h1 id="什么是View"><a href="#什么是View" class="headerlink" title="什么是View?"></a>什么是View?</h1><p>android.app.View 就是手机的UI，View 负责绘制UI，处理事件(evnet),Android 利用 View 打造出所 Widgets，利用 Widget 可打造出互动式的使用者介面，每个View 负责一定区域的绘制。</p>
<p>一张图理解常用控件层级关系</p>
<p><img src="http://img.blog.csdn.net/20160608135802023" alt="这里写图片描述"></p>
<h1 id="View-坐标的基本概念"><a href="#View-坐标的基本概念" class="headerlink" title="View 坐标的基本概念"></a>View 坐标的基本概念</h1><p>View的宽高是有top、left、right、bottom参数决定的 而X，Y和translationX，和translationY则负责View位置的改变。</p>
<blockquote>
<p>从Android3.0开始，加入了translation的概念，即相对于父容器的偏移量以及X,Y坐标的概念，X,Y代表左上顶点的横纵坐标。当View在发生平移时，getX，getY，setX，setY<br>get/setTranslationX/Y来获得当前左上点的坐标。</p>
</blockquote>
<p>X=left+translationX Y同理。<br>注意：在View发生改变的过程中，top，left等值代表原始位置，是不会改变的。改变的只有X,Y，translationX/Y。  </p>
<p>一张图理解View的坐标概念<br><img src="http://img.blog.csdn.net/20160608162836872" alt="这里写图片描述"></p>
<h1 id="View的生命周期"><a href="#View的生命周期" class="headerlink" title="View的生命周期"></a>View的生命周期</h1><table>
<thead>
<tr>
<th>Category</th>
<th style="text-align:center">Methods</th>
<th style="text-align:right">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Creation</td>
<td style="text-align:center">Constructors</td>
<td style="text-align:right">几个View的构造函数</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onFinishInflate(" target="_blank" rel="external">onFinishInflate()</a>)</td>
<td style="text-align:right">当系统解析完View之后调用onFinishInflate方法</td>
</tr>
<tr>
<td>Layout</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onMeasure(int,%20int" target="_blank" rel="external">onMeasure(int, int)</a>)</td>
<td style="text-align:right">确定所有子View的大小</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int" target="_blank" rel="external">onLayout(boolean, int, int, int, int)</a>)</td>
<td style="text-align:right">当ViewGroup分配所有的子View的大小和位置时触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onSizeChanged(int,%20int,%20int,%20int" target="_blank" rel="external">onSizeChanged(int, int, int, int)</a>)</td>
<td style="text-align:right">当view的大小发生变化时触发</td>
</tr>
<tr>
<td>Drawing</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onDraw(android.graphics.Canvas" target="_blank" rel="external">onDraw(android.graphics.Canvas)</a>)</td>
<td style="text-align:right">view渲染内容的细节</td>
</tr>
<tr>
<td>Event processing</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onKeyDown(int,%20android.view.KeyEvent" target="_blank" rel="external">onKeyDown(int, KeyEvent)</a>)</td>
<td style="text-align:right">有按键按下后触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onKeyUp(int,%20android.view.KeyEvent" target="_blank" rel="external">onKeyUp(int, KeyEvent)</a>)</td>
<td style="text-align:right">有按键按下后弹起时触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onTrackballEvent(android.view.MotionEvent" target="_blank" rel="external">onTrackballEvent(MotionEvent)</a>)</td>
<td style="text-align:right">轨迹球事件</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onTouchEvent(android.view.MotionEvent" target="_blank" rel="external">onTouchEvent(MotionEvent)</a>)</td>
<td style="text-align:right">触屏事件</td>
</tr>
<tr>
<td>Focus</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onFocusChanged(boolean,%20int,%20android.graphics.Rect" target="_blank" rel="external">onFocusChanged(boolean, int, android.graphics.Rect)</a>)</td>
<td style="text-align:right">当View获取或失去焦点时触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onWindowFocusChanged(boolean" target="_blank" rel="external">onWindowFocusChanged(boolean)</a>)</td>
<td style="text-align:right">当窗口包含的view获取或失去焦点时触发</td>
</tr>
<tr>
<td>Attaching</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onAttachedToWindow(" target="_blank" rel="external">onAttachedToWindow()</a>)</td>
<td style="text-align:right">当view被附着到一个窗口时触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onAttachedToWindow(" target="_blank" rel="external">onDetachedFromWindow()</a>)</td>
<td style="text-align:right">当view离开附着的窗口时触发，该方法和  onAttachedToWindow() 是相反</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onWindowVisibilityChanged(int" target="_blank" rel="external">onWindowVisibilityChanged(int)</a>)</td>
<td style="text-align:right">当窗口中包含的可见的view发生变化时触发</td>
</tr>
</tbody>
</table>
<p>对实现自定义View，不需要重写所有这些方法。事实上，你可以只<a href="https://developer.android.com/reference/android/view/View.html#onDraw(android.graphics.Canvas" target="_blank" rel="external">onDraw(android.graphics.Canvas)</a>)</p>
<h2 id="View-的几个构造函数"><a href="#View-的几个构造函数" class="headerlink" title="View 的几个构造函数"></a>View 的几个构造函数</h2><ul>
<li><p><code>public MyView(Context context)</code><br>java代码直接new一个Custom View实例的时候,会调用第一个构造函数</p>
</li>
<li><p><code>public MyView(Context context, AttributeSet attrs)</code><br>在xml创建但是没有指定style的时候被调用.多了一个AttributeSet类型的参数，自定义属性，在通过布局文件xml创建一个view时，会把XML内的参数通过AttributeSet带入到View内。</p>
</li>
<li><p><code>public MyView(Context context, AttributeSet attrs, int defStyleAttr)</code><br>构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，且只有在明确调用的时候才会调用</p>
</li>
<li><p><code>@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public MyView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)</code><br>该构造函数是在api21的时候才添加上的</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160607171836507" alt="http://blog.csdn.net/vfush"></p>
<h2 id="View-的几个重要方法"><a href="#View-的几个重要方法" class="headerlink" title="View 的几个重要方法"></a>View 的几个重要方法</h2><ul>
<li><p>requestLayout<br>View重新调用一次layout过程</p>
</li>
<li><p>invalidate<br>View重新调用一次draw过程</p>
</li>
<li><p>forceLayout<br>标识View在下一次重绘，需要重新调用layout过程。</p>
</li>
<li><p>postInvalidate<br>这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。</p>
</li>
</ul>
<h1 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h1><h2 id="简单理解View的绘制"><a href="#简单理解View的绘制" class="headerlink" title="简单理解View的绘制"></a>简单理解View的绘制</h2><p>这里我们先简单理解View 的绘制，后续文章我们会深入理解。<br>1.测量——onMeasure()：决定View的大小</p>
<p>2.布局——onLayout()：决定View在ViewGroup中的位置</p>
<p>3.绘制——onDraw()：如何绘制这个View。</p>
<p><img src="http://img.blog.csdn.net/20160608141154933" alt="这里写图片描述"></p>
<h2 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h2><ul>
<li>继承View</li>
<li>继承ViewGroup</li>
<li>继承系统控件(Button,LinearLayout…)</li>
</ul>
<h2 id="自定义View的过程"><a href="#自定义View的过程" class="headerlink" title="自定义View的过程"></a>自定义View的过程</h2><ol>
<li><p>自定义 View 首先要实现一个继承自 View 的类</p>
</li>
<li><p>添加类的构造方法,通常是三个构造方法,不过从 Android5.0 开始构造方法已经添加到 4 个了</p>
</li>
<li><p><code>override</code> 父类的方法,如 <code>onDraw,(onMeasure)</code>等</p>
</li>
<li><p>自定义属性，需要在 values 下建立 <code>attrs.xml</code> 文件,在其中定义属性</p>
<blockquote>
<p>通过context.obtainStyledAttributes将构造函数中的attrs进行解析出来,就可以拿到相对应的属性.<br>TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView);<br>mColor = typedArray.getColor(R.styleable.MyView_myColor, 0XFF00FF00);  </p>
<p><strong>【注意】</strong>三个函数获取尺寸的区别：<br><strong><code>getDimension()</code></strong>是基于当前DisplayMetrics进行转换，获取指定资源id对应的尺寸<br><strong><code>getDimensionPixelSize()</code></strong>与<strong><code>getDimension()</code></strong>功能类似，不同的是将结果转换为int，并且小数部分四舍五入<br><strong><code>getDimensionPixelOffset()</code></strong>与<strong><code>getDimension()</code></strong>功能类似，不同的是将结果转换为int，取整去除小数。举个例子<br>列如<strong><code>getDimension()</code></strong>返回结果是20.5f，那么<strong><code>getDimensionPixelSize()</code></strong>返回结果就是 21，<strong><code>getDimensionPixelOffset()</code></strong>返回结果就是20。</p>
</blockquote>
</li>
<li><p>打开布局文件我们可以看到有很多的以xmlns开头的字段。其实这个就是XML name space 的缩写。我们可以使用<code>res-atuo</code>命名空间,就不用在添加自定义View全类名。<br><code>xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by fuchenxuan on 16/6/4.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mRadius=<span class="number">200</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mColor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line">        <span class="comment">//read custom attrs</span></div><div class="line">        TypedArray t = context.obtainStyledAttributes(attrs,</div><div class="line">                R.styleable.rainbowbar, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">       mRadius = t.getDimensionPixelSize(R.styleable.coutom_radius, (<span class="keyword">int</span>) hSpace);</div><div class="line">        t.getDimensionPixelOffset(R.styleable.coutom_at1, (<span class="keyword">int</span>) vSpace);</div><div class="line">   		mColor=t.getColor(R.styleable.color, barColor);</div><div class="line">        t.recycle();   <span class="comment">// we should always recycle after used</span></div><div class="line">     </div><div class="line">     </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="comment">//super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span></div><div class="line">         <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">        <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="comment">//set size</span></div><div class="line">        setMeasuredDimension(widthMode == MeasureSpec.AT_MOST ? (<span class="keyword">int</span>) mRadius * <span class="number">3</span> : widthSize, heightMode == MeasureSpec.AT_MOST ? (<span class="keyword">int</span>) mRadius * <span class="number">3</span> : heightSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//draw be invoke clire.</span></div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="comment">//super.onDraw(canvas);</span></div><div class="line"> 	     mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mPaint.setColor(mColor);</div><div class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);</div><div class="line">		 canvas.drawCircle(mRadius, mRadius, mRadius, mPaint);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是一个普通的自定义View，里面画了圆，根据不同的模式设置了父View的大小。</p>
<p><strong>关于View重写<code>onMeasure()</code>时机</strong>：<br>如果用了<code>wrap_content</code>。那么在<code>onMeasure()</code>中就要调用<code>setMeasuredDimension()</code>，<br>来指定view的宽高。如果使用的是<code>match_parent</code>或者一个具体的dp值。那么直接使用<code>super.onMeasure()</code>即可。</p>
<h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><h2 id="自定义ViewGroup的过程"><a href="#自定义ViewGroup的过程" class="headerlink" title="自定义ViewGroup的过程"></a>自定义ViewGroup的过程</h2><ol>
<li>自定义 ViewGroup 和自定义View 一样，只是继承自 ViewGroup 的类，和必须实现<code>onLayout()</code>函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * Created by fuchenxuan on 16-6-6.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CostumViewGroup</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CostumViewGroup</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CostumViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            measureChild(childView, widthMeasureSpec, heightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (changed) &#123;</div><div class="line">            <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">                View childView = getChildAt(i);</div><div class="line">                childView.layout(i * childView.getMeasuredWidth(), <span class="number">0</span>, (i + <span class="number">1</span>) * childView.getMeasuredWidth(), childView.getMeasuredHeight());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是一个简单的自定义ViewGroup，实现类似LinearLayout 横向排放子View位置。这就是一个简单的ViewGroup过程。</p>
<h3 id="彻底理解MeasureSpec三种模式"><a href="#彻底理解MeasureSpec三种模式" class="headerlink" title="彻底理解MeasureSpec三种模式"></a>彻底理解MeasureSpec三种模式</h3><p>View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。他们是由 mode+size两部分组成的。widthMeasureSpec和heightMeasureSpec转化成二进制数字表示，他们都是30位的。前两位代表mode(测量模 式)，后面28位才是他们的实际数值（size）;<code>MeasureSpec.getMode()</code>获取模式,<code>MeasureSpec.getSize()</code>获取尺寸<br>测量View大小使用的是onMeasure函数，所以我们需要了解三种测量模式：  </p>
<ul>
<li><code>EXACTLY</code>：一般是设置了明确的值（100dp）或者是<code>MATCH_PARENT</code></li>
<li><code>AT_MOST</code>：表示子布局限制在一个最大值内，一般为<code>WARP_CONTENT</code></li>
<li><code>UNSPECIFIED</code>：表示子布局想要多大就多大，很少使用</li>
</ul>
<p><strong>关于ViewGroup重写<code>onMeasure()</code>时机</strong>：</p>
<ul>
<li><p>首先要先测量子View的宽高:<br><code>getChildAt(int index)</code>可以拿到index上的子view。<br><code>getChildCount()</code>得到子view的个数，再循环遍历出子view。</p>
</li>
<li><p>使用子view自身的测量方法<br>childView.measure(int wSpec, int hSpec); </p>
<p>或<strong>使用viewGroup的测量子view的方法</strong>：</p>
<ul>
<li><p><code>measureChild(subView, int wSpec, int hSpec);</code><br>测量某一个子view，多宽，多高, 内部加上了viewGroup的padding值</p>
</li>
<li><p><code>measureChildren(int wSpec, int hSpec);</code><br>测量所有子view 都是 多宽，多高, 内部调用了measureChild方法    </p>
</li>
<li><code>measureChildWithMargins(subView, intwSpec, int wUsed, int hSpec, int hUsed);</code>测量某一个子view，多宽，多高, 内部加上了viewGroup的padding值、margin值和传入的宽高wUsed、hUsed </li>
</ul>
</li>
</ul>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ol>
<li><p><strong>getWidth()和getMeasuredWidth()的区别？</strong><br>getMeasuredWidth()：只要一执行完 setMeasuredDimension() 方法，就有值了，并且不再改变。<br>getWidth()：必须执行完 onMeasure() 才有值，可能发生改变。<br>如果 onLayout 没有对子 View 实际显示的宽高进行修改，那么 getWidth() 的值 == getMeasuredWidth() 的值。</p>
</li>
<li><p><strong>onLayout() 和Layout()的区别？</strong><br>onLayout() ViewGroup中子View的布局方法，layout()是子View布局的方法</p>
</li>
<li><p><strong>View 里面的 onSavedInstanceState和onRestoreInstanceState的作用？</strong><br>View和Activity一样的，每个View都有onSavedInstanceState和onRestoreInstanceState这两个方法，可用于保存和恢复view的状态。</p>
</li>
</ol>
<p>   在本章节中我们知道什么是View?，View 坐标的基本概念，理解了View的生命周期，学习了如何自定义View？虽然全是理论知识总结，在后续我们会一起来自定义View的实战学习。不管有没有任何疑问，欢迎在下方留言吧。</p>
<p> 更多Android 面试题总结，请点击下方图片哦。</p>
<blockquote>
<p>水平有限，若有错漏，欢迎指正，批评，如需转载，请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a>，谢谢！<br><a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160608162227307" alt="这里写图片描述"></a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前几篇文章中都是讲的基础，大家应该会觉得非常熟悉，但往往我们可能对于基础某些细节认识不够彻底或贯穿不全，我一直认为基础都是比较难的，那么本章节终于到进阶啦，主要讲的是View 的相关知识，在前面&lt;a href=&quot;http://blog.csdn.net/vfush/art
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下安装Android Studio</title>
    <link href="http://fushenghua.github.io/archives/89bbc27f.html"/>
    <id>http://fushenghua.github.io/archives/89bbc27f.html</id>
    <published>2015-09-11T03:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.619Z</updated>
    
    <content type="html"><![CDATA[<pre><code>实在是不喜欢使用Windows了，时间长了就变得卡顿，还是喜欢Linux的文件系统不会像Windows的文件系统一样产生碎片化严重、
</code></pre><p>用Linux开发Android 感觉太好了，Android Studio 美观，编译速度也快，终端好用。这里我使用的是Ubuntu 安装Android Studio<br>非常方便。</p>
<p>##1.百度网盘Android Studio 资源<br>Android集成环境 NDK JDK 总链接 : <a href="http://pan.baidu.com/s/1bnjaDKb" target="_blank" rel="external">http://pan.baidu.com/s/1bnjaDKb</a>;</p>
<p>Android Studio Linux版 : <a href="http://pan.baidu.com/s/1eQjA6MA" target="_blank" rel="external">http://pan.baidu.com/s/1eQjA6MA</a> ;</p>
<p>Adt Bundle windows 64位版 : <a href="http://pan.baidu.com/s/1bnvlVnL" target="_blank" rel="external">http://pan.baidu.com/s/1bnvlVnL</a>;</p>
<p>Adt Bundle Linux 32位版 : <a href="http://pan.baidu.com/s/1jG41dI2" target="_blank" rel="external">http://pan.baidu.com/s/1jG41dI2</a>;</p>
<p>Adt Bundle Linux 64位版  : <a href="http://pan.baidu.com/s/1dDxjHXv" target="_blank" rel="external">http://pan.baidu.com/s/1dDxjHXv</a>;</p>
<p>NDK Linux 32位 : <a href="http://pan.baidu.com/s/1eQtJVe6" target="_blank" rel="external">http://pan.baidu.com/s/1eQtJVe6</a>;</p>
<p>NDK Linux 64位 : <a href="http://pan.baidu.com/s/1bnvRRJL" target="_blank" rel="external">http://pan.baidu.com/s/1bnvRRJL</a>;</p>
<p>NDK Windows 32位 : <a href="http://pan.baidu.com/s/1eQzj9iq" target="_blank" rel="external">http://pan.baidu.com/s/1eQzj9iq</a>;</p>
<p>##2.下载安装JDK<br>第一:</p>
<figure class="highlight plain"><figcaption><span>Ubuntu 中使用 PPA 安装 Java 8 ( 支持 Ubuntu 10.04 - Ubuntu 14.04 ):</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sudo add-apt-repository ppa:webupd8team/java</div><div class="line"></div><div class="line">sudo apt-get update</div><div class="line"></div><div class="line">sudo apt-get install Oracle-java8-installer</div><div class="line"></div><div class="line">完成之后可以通过以下命令来查看版本：</div><div class="line"></div><div class="line">javac -version</div><div class="line"></div><div class="line">安装 Java 8 需要接受许可，如果你想自动安装，那么可以在安装之前运行：</div><div class="line"></div><div class="line">echo oracle-java8-installer shared/accepted-oracle-license-v1-1 select true | sudo /usr/bin/debconf-set-selections</div><div class="line"></div><div class="line">设置 Java 8 环境变量：</div><div class="line"></div><div class="line">sudo apt-get install oracle-java8-set-default</div><div class="line"></div><div class="line">切换为 Java 7 ：</div><div class="line"></div><div class="line">sudo update-java-alternatives -s java-7-oracle</div><div class="line"></div><div class="line">再切换为 Java 8：</div><div class="line"></div><div class="line">sudo update-java-alternatives -s java-8-oracle</div></pre></td></tr></table></figure>
<p>##3.测试</p>
<p>打开一个终端，输入下面命令：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -<span class="built_in">version</span></div></pre></td></tr></table></figure>
<p>显示结果：</p>
<p>java version “1.7.0_05”<br>Java(TM) SE Runtime Environment (build 1.7.0_05-b05)</p>
<p>Java HotSpot(TM) Server VM (build 23.1-b03, mixed mode)</p>
<p>这表示java命令已经可以运行了。</p>
<p>##4.安装Android Studio<br>上面网盘的资源</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、下载<span class="keyword">android </span>studio包<span class="keyword">android-studio-bundle-133.970939-linux.tgz</span></div><div class="line">解压：$ sudo tar zxvf <span class="keyword">android-studio-bundle-133.970939-linux.tgz</span></div><div class="line">解压后文件夹名为<span class="keyword">android-studio。</span></div><div class="line">移动：$ sudo mv <span class="keyword">android-studio </span>/<span class="meta">opt</span>/</div><div class="line">打开文件夹：$ cd /<span class="meta">opt</span>/<span class="keyword">android-studio/bin/</span></div><div class="line">运行：$ sudo studio.sh</div><div class="line"><span class="symbol">oh</span> shit，提示命令不存在，怎么回事？额，恩，不是这么打的吧？！</div><div class="line">再次运行：$ sudo ./studio.sh</div><div class="line"><span class="symbol">OK</span>，打开了。固定到任务栏方便以后打开</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;实在是不喜欢使用Windows了，时间长了就变得卡顿，还是喜欢Linux的文件系统不会像Windows的文件系统一样产生碎片化严重、
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用Linux开发Android 感觉太好了，Android Studio 美观，编译速度也快
    
    </summary>
    
      <category term="linux" scheme="http://fushenghua.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://fushenghua.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>给我们的apk应用瘦身计划</title>
    <link href="http://fushenghua.github.io/archives/6412bd09.html"/>
    <id>http://fushenghua.github.io/archives/6412bd09.html</id>
    <published>2015-09-11T03:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.622Z</updated>
    
    <content type="html"><![CDATA[<h4 id="现在apk越来越大，原因有如下几个："><a href="#现在apk越来越大，原因有如下几个：" class="headerlink" title="现在apk越来越大，原因有如下几个："></a>现在apk越来越大，原因有如下几个：</h4><ul>
<li>1.多dpi支持([l|m|tv|h|x|xx|xxx]dpi)</li>
<li>2.Android开发工具和生态系统的发展</li>
<li>3.为了提高用户体验的高分辨率ui设计</li>
<li>4.无用代码,重复类库的编译</li>
</ul>
<p>随着项目的开发，项目体积不断增长，应用体积也变大了许多,会让很多用户会放弃安装，为了给apk瘦身,翻阅了大片文章,总结一下自己在开发中的经验</p>
<p>我们从一下几个方面去解决:</p>
<ul>
<li>开发阶段代码优化:<br>优化查错瘦身神器之android lint<br>运行Proguard： proguard能够便利你所有的代码路径，把没有用到的代码重apk中剔除。并且能够重命名变量，尽量精简你的代码；<br>使用Lint： 上面的proguard只是分析Java代码。lint工具能够分析你资源文件（/res），使用./gradlew lint就能够检测出没有用的资源文件；</li>
</ul>
<p>什么是ProGuard工具？</p>
<p>ProGuard是android提供的一个免费的工具，它能够移除工程中一些没用的代码，或者使用语义上隐晦的名称来重命名代码中的类、字段和函数等，达到压缩、优化和混淆代码的功能。具体来说，使用ProGuard工具，可以达到下面两个目的：<br>删除了源文件中没有调用的那部分代码，最大化的精简了字节码文件，使得最终生成的apk文件更小。<br>使用语义混淆的命名替换了代码中的类、字段和函数等，使得其他人无法反编译获取源代码，起到对代码的保护作用。</p>
<h4 id="add-Library和add-jars的区别"><a href="#add-Library和add-jars的区别" class="headerlink" title="add Library和add jars的区别?"></a>add Library和add jars的区别?</h4><p>在android项目中调用一些方法需要第三方的jar包，我们习惯做法是在android项目文件夹根目录下加一个lib文件并添加诸如.jar的文件，然后在右击该android项目，点属性(Properties),配置android,Java Build Path等。对于添加的jar文件，我们都是点 add External jars 或者 add jars，目前我还没发现两者的区别。<br>但是如果这样添加，会导致apk包增大至少2M以上，我用的办法是 添加add Library,选择User Library，如果有现成调用过的jar直接选择添加，如果没有则新建后添加，这样生成的apk比原来会减小很多。一般只有几百k左右。</p>
<ul>
<li>使用webP图片格式：</li>
<li>只用一种图片xhdpi</li>
<li>只用一张xhdpi图片放到xhdpi目录时，所有的屏幕密度都能很好的适配， android系统会自动的对你的图片进行缩放， 不用为每个密度都切一版图片的， 经过实际验证我也发现确实是这样的， 于是我将hdpi下的所有和xhdpi目录有重复的图片全部删除掉。 这样下来应用就减少了将近2M ！<br>so库压缩</li>
<li>项目中使用了室内定位功能，，编译成so直接打包在apk里以jni方式调用。 我相信有不少应用对于注重性能或者功能复用的模块都使用了jni方式，带来的问题就是so经常成为apk体积膨胀的一大因素， 以这个室内定位库为例， so文件就有整整8MB。为了适配armeabi和armeabi-v7a两种机型，这个库必须在libs/armeabi目录和libs/armeabi-v7a两个文件夹下各放一份。否则有可能在某种CPU类型的机器上运行出现初始化连接异常（因为找不到so库引起的）。</li>
<li>将so库使用zip压缩，可以压缩到50%~60%，然后 后只放一份到res/raw目录， 在代码里实现： 如果程序是第一次运行，则获取到raw下这个zip文件的输入流，然后将其解压到/data/data/com.xxx.xxx/lib_xxx目录， lib_xxx为你自己建的目录， 然后使用System.load加载库，而不要使用System.loadLibrary.， 这样指定路径加载肯定不会出现找不到so的问题。</li>
</ul>
<ul>
<li><p>项目构建优化:<br> 参考我的Android studio gradle 配置文章中,构建项目的时候,只编译所用代码,自动移除无用资源.</p>
</li>
<li><p>资源文件瘦身:<br>图片资源的优化原则是：在不降低图片效果、保证APK显示效果的前提下缩小图片文件的大小。<br>使用tinypng优化大部分图片资源：<a href="https://tinypng.com/" target="_blank" rel="external">https://tinypng.com/</a></p>
</li>
</ul>
<p>未完待续……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;现在apk越来越大，原因有如下几个：&quot;&gt;&lt;a href=&quot;#现在apk越来越大，原因有如下几个：&quot; class=&quot;headerlink&quot; title=&quot;现在apk越来越大，原因有如下几个：&quot;&gt;&lt;/a&gt;现在apk越来越大，原因有如下几个：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
      <category term="优化" scheme="http://fushenghua.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>用Android Studio Gradle 构建、打包、发布项目</title>
    <link href="http://fushenghua.github.io/archives/c8dd37ec.html"/>
    <id>http://fushenghua.github.io/archives/c8dd37ec.html</id>
    <published>2015-08-12T03:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.615Z</updated>
    
    <content type="html"><![CDATA[<p>Gradle其他好处就不多说，在android应用发布的时候，如果要统计多个渠道，gradle 批量打包的好处就显示出来了,发现确实比Ant打包会方便很多,就说下本篇Gradle作用吧</p>
<p>主要功能：<br>多渠道自动打包<br>beta /debug/relese /多版本打包<br>dex突破65535的限制<br>打包自动命名，提交测试时方便识别，不用每次打包测试 ，重命名啦！<br>自动移除程序LOG_DEBUG调试<br>自动移除无用资源文件，为APK瘦身<br>混淆代码<br>更多强大功能探索中……</p>
<p>Gradle 基本概念</p>
<p>首先我们学习几个gradle 的脚步语法，掌握了这几个语法，你就能非常简单的用gradle构建打包android项目了。 首先，我们来看下一个最简单android build.gradle。</p>
<p>apply plugin: ‘android’//声明构建的项目类型，这里当然是android了<br>buildscript{} //设置脚本的运行环境<br>repositories{}支持java 依赖库管理（maven/ivy）,用于项目的依赖<br>dependencies{}//依赖包的定义。支持maven/ivy，远程，本地库，也支持单文件<br>android{}编译android项目的参数</p>
<p>废话不多说，来一份我在项目中使用的完整的gradle文件配置吧：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    compileSdkVersion <span class="number">22</span></div><div class="line">    buildToolsVersion <span class="string">"22.0.1"</span></div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId <span class="string">"com.rtmap.sample"</span></div><div class="line">        minSdkVersion <span class="number">9</span></div><div class="line">        targetSdkVersion <span class="number">22</span></div><div class="line">        versionCode <span class="number">10</span></div><div class="line">        versionName <span class="string">"1.3"</span></div><div class="line">        <span class="comment">// dex突破65535的限制</span></div><div class="line">              multiDexEnabled <span class="keyword">true</span></div><div class="line">        manifestPlaceholders = [channel_param: <span class="string">"official"</span>]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="comment">//----begin  是为了兼容Eclipse 可忽略</span></div><div class="line">    <span class="keyword">sourceSets</span> &#123;</div><div class="line">        main &#123;</div><div class="line">            manifest.srcFile <span class="string">'AndroidManifest.xml'</span></div><div class="line">            java.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            resources.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            aidl.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            renderscript.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            res.srcDirs = [<span class="string">'res'</span>]</div><div class="line">            assets.srcDirs = [<span class="string">'assets'</span>]</div><div class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">//----end  </span></div><div class="line"></div><div class="line">    buildTypes &#123;</div><div class="line"></div><div class="line">        release &#123;</div><div class="line">            <span class="comment">// 不显示Log</span></div><div class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span></div><div class="line"></div><div class="line">            minifyEnabled <span class="keyword">true</span></div><div class="line">            zipAlignEnabled <span class="keyword">true</span></div><div class="line">            <span class="comment">// 移除无用的resource文件</span></div><div class="line">            shrinkResources <span class="keyword">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line"><span class="comment">//            signingConfig signingConfigs.release</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        beta &#123;</div><div class="line">            <span class="comment">// 不显示Log</span></div><div class="line"><span class="comment">//            buildConfigField "boolean", "LOG_DEBUG", "false"</span></div><div class="line">            versionNameSuffix <span class="string">"-beta"</span></div><div class="line"><span class="comment">//            minifyEnabled true</span></div><div class="line">            zipAlignEnabled <span class="keyword">true</span></div><div class="line">            <span class="comment">// 移除无用的resource文件</span></div><div class="line">            minifyEnabled <span class="keyword">true</span></div><div class="line">            shrinkResources <span class="keyword">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line"><span class="comment">//            signingConfig signingConfigs.release</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        debug &#123;</div><div class="line">            versionNameSuffix <span class="string">"-debug"</span></div><div class="line">            zipAlignEnabled <span class="keyword">true</span></div><div class="line">            <span class="comment">// 移除无用的resource文件</span></div><div class="line">            shrinkResources <span class="keyword">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line"><span class="comment">//            signingConfig signingConfigs.release</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        applicationVariants.all &#123; variant -&gt;</div><div class="line">            variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</div><div class="line">                <span class="keyword">def</span> outputFile = output.outputFile</div><div class="line">                <span class="keyword">if</span> (variant.buildType.name.equals(<span class="string">'release'</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</div><div class="line">                        <span class="comment">// erdoushop_v1.1_release_201508101027</span></div><div class="line">                        <span class="keyword">def</span> fileName = <span class="string">"erdoushop_v$&#123;defaultConfig.versionName&#125;_release_$&#123;getDate()&#125;.apk"</span></div><div class="line">                        output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (variant.buildType.name.equals(<span class="string">'beta'</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</div><div class="line">                        <span class="comment">// erdoushop_v1.1_beta_201508101027</span></div><div class="line">                        <span class="keyword">def</span> fileName = <span class="string">"erdoushop_v$&#123;defaultConfig.versionName&#125;_beta_$&#123;getDate()&#125;.apk"</span></div><div class="line">                        output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">def</span> getDate() &#123;</div><div class="line">    <span class="keyword">def</span> date = <span class="keyword">new</span> Date()</div><div class="line">    <span class="keyword">def</span> formattedDate = date.format(<span class="string">'yyyyMMddHHmm'</span>)</div><div class="line">    <span class="keyword">return</span> formattedDate</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文章目前只讲到了打包，时间喘促，先写到这里，最近都比较忙，没时间写博客，后期博客会整理一下，现在就当作笔记一下 ，怕以后忘记了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gradle其他好处就不多说，在android应用发布的时候，如果要统计多个渠道，gradle 批量打包的好处就显示出来了,发现确实比Ant打包会方便很多,就说下本篇Gradle作用吧&lt;/p&gt;
&lt;p&gt;主要功能：&lt;br&gt;多渠道自动打包&lt;br&gt;beta /debug/reles
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解Handler原理</title>
    <link href="http://fushenghua.github.io/archives/158db06e.html"/>
    <id>http://fushenghua.github.io/archives/158db06e.html</id>
    <published>2015-07-13T04:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.612Z</updated>
    
    <content type="html"><![CDATA[<p>Handler在Android开发中非常重要，最常见的使用场景就是在子线程需要更新UI，用Handler来投递消息到主线程执行UI更新操作。因为 Android系统的View是非线程安全的，所以需要在主线程更新UI。总的来说Handler就是用来做线程间通信，在不同线程之间传递消息。</p>
<p>注：这篇文章所讲到的Handler是在主线程创建的，主线程在开始的时候已经创建了默认的消息循环。后面的文章会讲如何创建自己的消息循环。<br>从图中可以看出，四种颜色分别代表了四个对象，并且大致描述了几个对象之间的关系，以及消息的流转过程，首先Handler通过sendMessage将消息投递给MessageQueue，Looper通过消息循环（loop）不断的从MessageQueue中取出消息，然后消息被Handler的dispatchMessage分发到handleMessage方法消费掉。<br>消息循环中涉及的重要对象</p>
<p>Handler</p>
<p>通过Handler的sendMessage等方法来投递消息到MessageQueue，通过handleMessage来消费Message。Handler必须要有一个已经prepare好的Looper对象，也就是说必须调用了prepare方法(也包括prepareMainLooper方法)，究其根本是初始化一个消息队列，这一过程将在下文中详细分析。</p>
<p>Looper</p>
<p>Looper负责从MessageQueue中取出消息，然后通过执行message.target.dispatchMessage()消费掉这个消息，这里的target就是Handler。</p>
<p>MessageQueue</p>
<p>消息队列，管理Handler投递过来的消息。</p>
<p>Message</p>
<p>用来承载数据的消息，最终被Handler消费掉。</p>
<p>UML类图分析</p>
<p>Handler class diagram</p>
<p>通过上面的类图可以清晰的了解各个类之间的关系。然后再来分析一下源码。<br>Handler的创建</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> Handler(Callback callback, boolean async) &#123;</div><div class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Handler</span>&gt; <span class="title">klass</span> = <span class="title">getClass</span>();</span></div><div class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">Log</span>.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span> Handler(Callback callback, boolean async) &#123;</div><div class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Handler</span>&gt; <span class="title">klass</span> = <span class="title">getClass</span>();</span></div><div class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">Log</span>.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面这段代码中，首先是检查是否存在潜在的内存泄漏，如果该类是匿名内部类，或者是成员类且没有static修饰符时那么打印一个内存泄漏风险警告。这是由于这种类型的class持有外部类的this引用，可能导致外部类无法释放。<br>接下来就是对成员变量mLooper赋值，在文章开头就提到过，这篇文章中提到的handler对象时在主线程（UI线程）中创建，而Android主线已经有一个消息队列了,所以直接将mLooper.mQueue赋给Handler的mQueue。<br>那么主线程中的消息队列是怎么创建的呢？</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        将looper对象装入ThreadLocal中，Handler就是从它里面取出looper对象的</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建消息队列</span></div><div class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        将looper对象装入ThreadLocal中，Handler就是从它里面取出looper对象的</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建消息队列</span></div><div class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面的关键代码，UI线程在创建的时候，会调用prepareMainLooper()这个方法，创建一个不退出的消息队列。所以prepareMainLooper这个方法自己永远也不要调用，它是系统调用的，如果我们需要用自己的消息队列呢？那么就应该调用prepare()方法。</p>
<p>消息怎么被消费的呢？</p>
<p>整个消息循环系统中的几个重要部件的创建都已经明白了，那么消息时怎么循环起来的，又是如何消费的呢？来看看下面是loop源码的一部分关键代码。代码非常简单易懂，就是从消息队列中取出消息，然后通过msg.target.dispatchMessage(msg)将消息投递到Handler。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            msg.<span class="keyword">target</span>.dispatchMessage(msg);</div><div class="line">            msg.recycleUnchecked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            msg.<span class="keyword">target</span>.dispatchMessage(msg);</div><div class="line">            msg.recycleUnchecked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">消息传递的终点</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当消息循环中取出的消息被再次传递给Handler的时候，这个消息就走到了生命的尽头(并不代表对象销毁，有一个消息池来回收消息)，从dispatchMessage方法可以看出，消息最终的归宿有三个，一是消息自身的callback接口，二是handler的callback接口，最后是handleMessage接口。<br>原文地址：<a href="http://vjson.com/wordpress/handler-looper%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" target="_blank" rel="external">http://vjson.com/wordpress/handler-looper%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</a><br>后面我们将继续分析Handler源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler在Android开发中非常重要，最常见的使用场景就是在子线程需要更新UI，用Handler来投递消息到主线程执行UI更新操作。因为 Android系统的View是非线程安全的，所以需要在主线程更新UI。总的来说Handler就是用来做线程间通信，在不同线程之间
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
      <category term="android" scheme="http://fushenghua.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Java动态绑定机制</title>
    <link href="http://fushenghua.github.io/archives/1aa08dc.html"/>
    <id>http://fushenghua.github.io/archives/1aa08dc.html</id>
    <published>2015-04-07T00:55:29.000Z</published>
    <updated>2018-05-02T05:26:33.129Z</updated>
    
    <content type="html"><![CDATA[<p>在Java方法调用的过程中，JVM是如何知道调用的是哪个类的方法源代码？ 这里面到底有什么内幕呢？ 这篇文章我们就将揭露JVM方法调用的<strong>静态(static binding) </strong>和<strong>动态绑定机制(auto binding) </strong>。</p>
<h4 id="静态绑定机制"><a href="#静态绑定机制" class="headerlink" title="静态绑定机制"></a><strong>静态绑定机制</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//被调用的类  </span></div><div class="line"><span class="keyword">package</span> hr.test;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;  </div><div class="line">              System.out.println(<span class="string">"Father— f1()"</span>);  </div><div class="line">      &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//调用静态方法  </span></div><div class="line"><span class="keyword">import</span> hr.test.Father;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCall</span></span>&#123;  </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </div><div class="line">            Father.f1(); <span class="comment">//调用静态方法  </span></div><div class="line">       &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的源代码中执行方法调用的语句(Father.f1())被编译器编译成了一条指令：invokestatic #13。我们看看JVM是如何处理这条指令的</p>
<pre><code>(1) 指令中的#13指的是StaticCall类的常量池中第13个常量表的索引项(关于常量池详见《[Class文件内容及常量池](http://hxraid.iteye.com/blog/687660) 》)。这个常量表(**CONSTATN_Methodref_info** ) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到方法f1所在的类的全限定名: hr.test.Father。

(2) 紧接着JVM会加载、链接和初始化Father类。

(3) 然后在Father类所在的方法区中找到f1()方法的直接地址，并将这个直接地址记录到StaticCall类的常量池索引为13的常量表中。这个过程叫**常量池解析 **，以后再次调用Father.f1()时，将直接找到f1方法的字节码。

(4) 完成了StaticCall类常量池索引项13的常量表的解析之后，JVM就可以调用f1()方法，并开始解释执行f1()方法中的指令了。

通过上面的过程，我们发现经过常量池解析之后，JVM就能够确定要调用的f1()方法具体在内存的什么位置上了。实际上，这个信息在编译阶段就已经在StaticCall类的常量池中记录了下来。这种在编译阶段就能够确定调用哪个方法的方式，我们叫做 **静态绑定机制 **。

除了被static 修饰的静态方法，所有被private 修饰的私有方法、被final 修饰的禁止子类覆盖的方法都会被编译成invokestatic指令。另外所有类的初始化方法和会被编译成invokespecial指令。JVM会采用静态绑定机制来顺利的调用这些方法。
</code></pre><h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a><strong>动态绑定机制</strong></h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> package hr.test;  </div><div class="line"><span class="number">2.</span> <span class="comment">//被调用的父类  </span></div><div class="line"><span class="number">3.</span> <span class="keyword">class</span> <span class="title">Father</span>&#123;  </div><div class="line"><span class="number">4.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;  </div><div class="line"><span class="number">5.</span>         System.<span class="keyword">out</span>.println(<span class="string">"father-f1()"</span>);  </div><div class="line"><span class="number">6.</span>     &#125;  </div><div class="line"><span class="number">7.</span>         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">int</span> i</span>)</span>&#123;  </div><div class="line"><span class="number">8.</span>                 System.<span class="keyword">out</span>.println(<span class="string">"father-f1()  para-int "</span>+i);  </div><div class="line"><span class="number">9.</span>         &#125;  </div><div class="line"><span class="number">10.</span> &#125;  </div><div class="line"><span class="number">11.</span> <span class="comment">//被调用的子类  </span></div><div class="line"><span class="number">12.</span> <span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123;  </div><div class="line"><span class="number">13.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123; <span class="comment">//覆盖父类的方法  </span></div><div class="line"><span class="number">14.</span>         System.<span class="keyword">out</span>.println(<span class="string">"Son-f1()"</span>);  </div><div class="line"><span class="number">15.</span>     &#125;  </div><div class="line"><span class="number">16.</span>         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">char</span> c</span>)</span>&#123;  </div><div class="line"><span class="number">17.</span>                 System.<span class="keyword">out</span>.println(<span class="string">"Son-s1() para-char "</span>+c);  </div><div class="line"><span class="number">18.</span>         &#125;  </div><div class="line"><span class="number">19.</span> &#125;  </div><div class="line"><span class="number">20.</span>   </div><div class="line"><span class="number">21.</span> <span class="comment">//调用方法  </span></div><div class="line"><span class="number">22.</span> import hr.test.*;  </div><div class="line"><span class="number">23.</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutoCall</span>&#123;  </div><div class="line"><span class="number">24.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;  </div><div class="line"><span class="number">25.</span>         Father father=<span class="keyword">new</span> Son(); <span class="comment">//多态  </span></div><div class="line"><span class="number">26.</span>         father.f1(); <span class="comment">//打印结果： Son-f1()  </span></div><div class="line"><span class="number">27.</span>     &#125;  </div><div class="line"><span class="number">28.</span> &#125;</div></pre></td></tr></table></figure>
<pre><code>上面的源代码中有三个重要的概念：**多态(polymorphism) **、**方法覆盖 、方法重载 **。打印的结果大家也都比较清楚，但是JVM是如何知道f.f1()调用的是子类Sun中方法而不是Father中的方法呢？在解释这个问题之前，我们首先简单的讲下JVM管理的一个非常重要的数据结构——**方法表 **。

 在JVM加载类的同时，会在方法区中为这个类存放很多信息(详见《[Java 虚拟机体系结构](http://hxraid.iteye.com/blog/676235) 》)。其中就有一个数据结构叫方法表。它以数组的形式记录了当前类及其所有超类的可见方法字节码在内存中的直接地址 。下图是上面源代码中Father和Sun类在方法区中的方法表：
</code></pre><p><img src="http://hxraid.iteye.com/upload/picture/pic/65417/ab4e5838-83f6-34a4-9dfc-a1b93e1ff02c.jpg" alt=""></p>
<p>上图中的方法表有两个特点：<br>(1) 子类方法表中继承了父类的方法，比如Father extends Object。<br>(2) 相同的方法(相同的方法签名：方法名和参数列表)在所有类的方法表中的索引相同。比如Father方法表中的f1()和Son方法表中的f1()都位于各自方法表的第11项中。<br>对于上面的源代码，编译器首先会把main方法编译成下面的字节码指令：<br>多态调用的字节码指令代码 </p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="number">0</span>  new hr.test.Son [<span class="number">13</span>] <span class="comment">//在堆中开辟一个Son对象的内存空间，并将对象引用压入操作数栈  </span></div><div class="line"><span class="number">2.</span> <span class="number">3</span>  dup    </div><div class="line"><span class="number">3.</span> <span class="number">4</span>  invokespecial #<span class="number">7</span> [<span class="number">15</span>] <span class="comment">// 调用初始化方法来初始化堆中的Son对象   </span></div><div class="line"><span class="number">4.</span> <span class="number">7</span>  astore_1 <span class="comment">//弹出操作数栈的Son对象引用压入局部变量1中  </span></div><div class="line"><span class="number">5.</span> <span class="number">8</span>  aload_1 <span class="comment">//取出局部变量1中的对象引用压入操作数栈  </span></div><div class="line"><span class="number">6.</span> <span class="number">9</span>  invokevirtual #<span class="number">15</span> <span class="comment">//调用f1()方法  </span></div><div class="line"><span class="number">7.</span> <span class="number">12</span>  return</div></pre></td></tr></table></figure>
<p> 其中invokevirtual指令的详细调用过程是这样的：<br> (1) invokevirtual指令中的#15指的是AutoCall类的常量池中第15个常量表的索引项。这个常量表(<strong>CONSTATN_Methodref_info</strong> ) 记录的是方法f1信息的符号引用(包括f1所在的类名，方法名和返回类型)。JVM会首先根据这个符号引用找到调用方法f1的类的全限定名: hr.test.Father。这是因为调用方法f1的类的对象father声明为Father类型。<br>(2) 在Father类型的方法表中查找方法f1，如果找到，则将方法f1在方法表中的索引项11(如上图)记录到AutoCall类的常量池中第15个常量表中(<strong>常量池解析 </strong>)。这里有一点要注意：如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。<br>(3) 在调用invokevirtual指令前有一个aload_1指令，它会将开始创建在堆中的Son对象的引用压入操作数栈。然后invokevirtual指令会根据这个Son对象的引用首先找到堆中的Son对象，然后进一步找到Son对象所属类型的方法表。过程如下图所示：</p>
<pre><code>              ![](/images/4f775e04-3dd2-34bb-bb44-086d5743ee4c.jpg)

(4) 这是通过第(2)步中解析完成的#15常量表中的方法表的索引项11，可以定位到Son类型方法表中的方法f1()，然后通过直接地址找到该方法字节码所在的内存空间。

很明显，根据对象(father)的声明类型(Father)还不能够确定调用方法f1的位置，必须根据father在堆中实际创建的对象类型Son来确定f1方法所在的位置。这种在程序运行过程中，通过动态创建的对象的方法表来定位方法的方式，我们叫做 **动态绑定机制 **。

上面的过程很清楚的反映出在方法覆盖的多态调用的情况下，JVM是如何定位到准确的方法的。但是下面的调用方法JVM是如何定位的呢？(仍然使用上面代码中的Father和Son类型)
</code></pre><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutoCall</span>&#123;  </div><div class="line"><span class="number">2.</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;  </div><div class="line"><span class="number">3.</span>              Father father=<span class="keyword">new</span> Son();  </div><div class="line"><span class="number">4.</span>              <span class="keyword">char</span> c=<span class="string">'a'</span>;  </div><div class="line"><span class="number">5.</span>              father.f1(c); <span class="comment">//打印结果：father-f1()  para-int 97  </span></div><div class="line"><span class="number">6.</span>        &#125;  </div><div class="line"><span class="number">7.</span> &#125;</div></pre></td></tr></table></figure>
<pre><code> 问题是Fahter类型中并没有方法签名为f1(char)的方法呀。但打印结果显示JVM调用了Father类型中的f1(int)方法，并没有调用到Son类型中的f1(char)方法。

 根据上面详细阐述的调用过程，首先可以明确的是：JVM首先是根据对象father声明的类型Father来解析常量池的(也就是用Father方法表中的索引项来代替常量池中的符号引用)。如果Father中没有匹配到&quot;合适&quot; 的方法，就无法进行常量池解析，这在编译阶段就通过不了。

那么什么叫&quot;合适&quot;的方法呢？当然，方法签名完全一样的方法自然是合适的。但是如果方法中的参数类型在声明的类型中并不能找到呢？比如上面的代码中调用father.f1(char)，Father类型并没有f1(char)的方法签名。实际上，JVM会找到一种“凑合”的办法，就是通过 **参数的自动转型 **来找 到“合适”的 方法。比如char可以通过自动转型成int，那么Father类中就可以匹配到这个方法了 (关于Java的自动转型问题可以参见《[【解惑】Java类型间的转型](http://hxraid.iteye.com/blog/466997)》)。但是还有一个问题，如果通过自动转型发现可以“凑合”出两个方法的话怎么办？比如下面的代码：
</code></pre><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="keyword">class</span> <span class="title">Father</span>&#123;  </div><div class="line"><span class="number">2.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params">Object o</span>)</span>&#123;  </div><div class="line"><span class="number">3.</span>         System.<span class="keyword">out</span>.println(<span class="string">"Object"</span>);  </div><div class="line"><span class="number">4.</span>     &#125;  </div><div class="line"><span class="number">5.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">double</span>[] d</span>)</span>&#123;  </div><div class="line"><span class="number">6.</span>         System.<span class="keyword">out</span>.println(<span class="string">"double[]"</span>);  </div><div class="line"><span class="number">7.</span>     &#125;  </div><div class="line"><span class="number">8.</span>       </div><div class="line"><span class="number">9.</span> &#125;  </div><div class="line"><span class="number">10.</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span>&#123;  </div><div class="line"><span class="number">11.</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </div><div class="line"><span class="number">12.</span>         <span class="keyword">new</span> Father().f1(<span class="literal">null</span>); <span class="comment">//打印结果： double[]  </span></div><div class="line"><span class="number">13.</span>     &#125;  </div><div class="line"><span class="number">14.</span> &#125;</div></pre></td></tr></table></figure>
<pre><code>null可以引用于任何的引用类型，那么JVM如何确定“合适”的方法呢。一个很重要的标准就是：如果一个方法可以接受传递给另一个方法的任何参数，那么第一个方法就相对不合适。比如上面的代码: 任何传递给f1(double[])方法的参数都可以传递给f1(Object)方法，而反之却不行，那么f1(double[])方法就更合适。因此JVM就会调用这个更合适的方法。
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>(1) 所有私有方法、静态方法、构造器及初始化方法都是采用静态绑定机制。在编译器阶段就已经指明了调用方法在常量池中的符号引用，JVM运行的时候只需要进行一次常量池解析即可。<br>(2) 类对象方法的调用必须在运行过程中采用动态绑定机制。<br> 首先，根据对象的声明类型(对象引用的类型)找到“合适”的方法。具体步骤如下：<br>① 如果能在声明类型中匹配到方法签名完全一样(参数类型一致)的方法，那么这个方法是最合适的。<br>② 在第①条不能满足的情况下，寻找可以“凑合”的方法。标准就是通过将参数类型进行自动转型之后再进行匹配。如果匹配到多个自动转型后的方法签名f(A)和f(B)，则用下面的标准来确定合适的方法：传递给f(A)方法的参数都可以传递给f(B)，则f(A)最合适。反之f(B)最合适 。<br> ③ 如果仍然在声明类型中找不到“合适”的方法，则编译阶段就无法通过。然后，根据在堆中创建对象的实际类型找到对应的方法表，从中确定具体的方法在内存中的位置。</p>
<h4 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h4><p>一个实例方法可以覆写（override）在其超类中可访问到的具有相同签名的所有实例方法，从而使能了动态分派（dynamic dispatch）；换句话说，VM将基于实例的运行期类型来选择要调用的覆写方法。覆写是面向对象编程技术的基础，并且是唯一没有被普遍劝阻的名字重用形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;  </div><div class="line">      public void f()&#123;&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;  </div><div class="line">      public void f()&#123;&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><p>一个域、静态方法或成员类型可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名)的所有域、静态方法或成员类型。隐藏一个成员将阻止其被继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;  </div><div class="line">	      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">	&#125;  </div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span>  </span>&#123;  </div><div class="line">	       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;   <span class="comment">//hides Base. f()  </span></div><div class="line">	 &#125;</div></pre></td></tr></table></figure>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>在某个类中的方法可以重载（overload）另一个方法，只要它们具有相同的名字和不同的签名。由调用所指定的重载方法是在编译期选定的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">CircuitBreaker</span>&#123;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span> (<span class="params"><span class="keyword">int</span> i</span>)</span>&#123;&#125;    <span class="comment">//int overloading  </span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="params">String s</span>)</span>&#123;&#125;   <span class="comment">//String overloading  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="遮蔽"><a href="#遮蔽" class="headerlink" title="遮蔽"></a>遮蔽</h4><p>一个变量、方法或类型可以分别遮蔽（shadow）在一个闭合的文本范围内的具有相同名字的所有变量、方法或类型。如果一个实体被遮蔽了，那么你用它的简单名是无法引用到它的;根据实体的不同，有时你根本就无法引用到它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class WhoKnows&#123;  </div><div class="line">    <span class="keyword">static</span> <span class="built_in">String</span> sentence=”I don<span class="symbol">'t</span> know.”;  </div><div class="line">    public <span class="keyword">static</span> void main(<span class="built_in">String</span>[] args〕&#123;  </div><div class="line">           <span class="built_in">String</span> sentence=”I don<span class="symbol">'t</span> know.”;  <span class="comment">//shadows static field  </span></div><div class="line">           System.out. println (sentence);  <span class="comment">// prints local variable  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>尽管遮蔽通常是被劝阻的，但是有一种通用的惯用法确实涉及遮蔽。构造器经常将来自其所在类的某个域名重用为一个参数，以传递这个命名域的值。这种惯用法并不是没有风险，但是大多数Java程序员都认为这种风格带来的实惠要超过其风险:</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Belt&#123;  </div><div class="line">      <span class="keyword">private</span> <span class="built_in">find</span> <span class="keyword">int</span> <span class="built_in">size</span> ;  <span class="comment">//Parameter shadows Belt. size  </span></div><div class="line">      <span class="keyword">public</span> Belt (<span class="keyword">int</span> <span class="built_in">size</span>)&#123;  </div><div class="line">           <span class="keyword">this</span>. <span class="built_in">size</span>=<span class="built_in">size</span>;  </div><div class="line">      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="遮掩"><a href="#遮掩" class="headerlink" title="遮掩"></a>遮掩</h4><p>一个变量可以遮掩具有相同名字的一个类型，只要它们都在同一个范围内:如果这个名字被用于变量与类型都被许可的范围，那么它将引用到变量上。相似地，一个变量或一个类型可以遮掩一个包。遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式，这些名字空间包括:变量、包、方法或类型。如果一个类型或一个包被遮掩了，那么你不能通过其简单<br>名引用到它，除非是在这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字。遵守命名习惯就可以极大地消除产生遮掩的可能性:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Obscure&#123;  </div><div class="line">      <span class="keyword">static</span> <span class="keyword">String</span> System;<span class="comment">// Obscures type java.lang.System  </span></div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)  </div><div class="line">            <span class="comment">// Next line won't compile:System refers to static field  </span></div><div class="line">            System. out. <span class="built_in">println</span>(“hello, obscure world!”);  </div><div class="line">      &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java方法调用的过程中，JVM是如何知道调用的是哪个类的方法源代码？ 这里面到底有什么内幕呢？ 这篇文章我们就将揭露JVM方法调用的&lt;strong&gt;静态(static binding) &lt;/strong&gt;和&lt;strong&gt;动态绑定机制(auto binding) &lt;/s
    
    </summary>
    
      <category term="java" scheme="http://fushenghua.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发集合-CopyOnWriteArrayList</title>
    <link href="http://fushenghua.github.io/archives/1aa08dc.html"/>
    <id>http://fushenghua.github.io/archives/1aa08dc.html</id>
    <published>2015-04-07T00:55:29.000Z</published>
    <updated>2018-05-10T03:31:55.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h3><p>文件系统特性 – COW事务，文件系统中常用的事务实现方式。写时复制(COW)是维护数据集合的副本和使用相同数据处理多个任务时管理资源的优化技术。<br>CopyOnWrite容器即写时复制的容器就是COW事务。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>CopyOnWriteArrayList API的定义如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="keyword">extends</span> <span class="title">Object</span></div><div class="line"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>它也属于Java集合框架的一部分，是<strong>ArrayList</strong>的线程安全的变体，跟ArrayList的不同在于：CopyOnWriteArrayList针对数组的修改操作（add、set等）是基于<strong>内部拷贝的一份数据而进行</strong>的。换句话说，即使在一个线程进行遍历操作时有其他线程可能进行插入或删除操作，我们也可以“线程安全”得遍历CopyOnWriteArrayList。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>适合使用在读操作远远大于写操作的场景里</p>
<h4 id="插入（删除）数据的同时进行遍历"><a href="#插入（删除）数据的同时进行遍历" class="headerlink" title="插入（删除）数据的同时进行遍历"></a>插入（删除）数据的同时进行遍历</h4><p>CopyOnWriteArrayList的实现原理是，在一个线程开始遍历（创建Iterator对象）时，内部会创建一个“快照”数组，遍历基于这个快照Iterator进行，在遍历过程中这个快照数组不会改变，也就不会抛出<code>ConcurrentModificationException</code>。如果在遍历的过程中有其他线程尝试改变数组的内容，就会拷贝一份新的数据进行变更，而后面再来访问这个数组的线程，看到的就是变更过的数组。<br>如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.<span class="built_in">Iterator</span>;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.<span class="built_in">List</span>;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListExample</span> </span>&#123;</div><div class="line"></div><div class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">        CopyOnWriteArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">78</span>&#125;);</div><div class="line"></div><div class="line">        <span class="built_in">Iterator</span>&lt;Integer&gt; iterator = numbers.iterator();</div><div class="line">        numbers.add(<span class="number">100</span>);</div><div class="line">        <span class="built_in">List</span>&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        iterator.forEachRemaining(result::add);</div><div class="line">        assertThat(result).containsOnly(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">78</span>);</div><div class="line"></div><div class="line">        <span class="built_in">Iterator</span>&lt;Integer&gt; iterator2 = numbers.iterator();</div><div class="line">        numbers.remove(<span class="number">3</span>);</div><div class="line">        <span class="built_in">List</span>&lt;Integer&gt; result2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        iterator2.forEachRemaining(result2::add);</div><div class="line">        assertThat(result2).containsOnly(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">78</span>, <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h3><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是<strong>需要加锁</strong>的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span>(<span class="params">T e</span>) </span>&#123;</div><div class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</div><div class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"> </div><div class="line">        Object[] elements = getArray();</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> len = elements.length;</div><div class="line">        <span class="comment">// 复制出新数组</span></div><div class="line"> </div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">        <span class="comment">// 把新元素添加到新数组里</span></div><div class="line"> </div><div class="line">        newElements[len] = e;</div><div class="line">        <span class="comment">// 把原数组引用指向新数组</span></div><div class="line"> </div><div class="line">        setArray(newElements);</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"> </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> </div><div class="line">        <span class="keyword">lock</span>.unlock();</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">final <span class="keyword">void</span> <span class="title">setArray</span>(<span class="params">Object[] a</span>) </span>&#123;</div><div class="line">    array = a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> E <span class="built_in">get</span>(<span class="keyword">int</span> index) &#123;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">get</span>(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>CopyOnWriteArrayList</strong>适合使用在读操作远远大于写操作的场景里，比如缓存。发生修改时候做copy，新老版本分离，保证读的高性能，适用于以读为主的情况。</p>
</li>
<li><p><strong>内存占用问题</strong>：因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
</li>
<li><strong>数据一致性问题</strong>：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是CopyOnWrite容器&quot;&gt;&lt;a href=&quot;#什么是CopyOnWrite容器&quot; class=&quot;headerlink&quot; title=&quot;什么是CopyOnWrite容器&quot;&gt;&lt;/a&gt;什么是CopyOnWrite容器&lt;/h3&gt;&lt;p&gt;文件系统特性 – COW事务
    
    </summary>
    
      <category term="java" scheme="http://fushenghua.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络体系分类</title>
    <link href="http://fushenghua.github.io/archives/394d1a7f.html"/>
    <id>http://fushenghua.github.io/archives/394d1a7f.html</id>
    <published>2015-03-07T00:55:29.000Z</published>
    <updated>2018-04-28T02:48:48.257Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是实际使用中的TCP/IP四层模型。</p>
<table>
<thead>
<tr>
<th>OSI七层模型</th>
<th>TCP/IP四层模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td>应用层</td>
</tr>
<tr>
<td>会话层</td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>物理接入层</td>
</tr>
<tr>
<td>物理层</td>
</tr>
</tbody>
</table>
<h1 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h1><p>物理层主要是实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。</p>
<h2 id="通信方式："><a href="#通信方式：" class="headerlink" title="通信方式："></a>通信方式：</h2><ul>
<li><p><strong>单工通信：</strong>只能由A主机向B主机发送消息，通信是单向的。</p>
</li>
<li><p><strong>半双工通信：</strong>同一时间只能是由A主机向B主机或者是B主机向A主机发送信息，不能同时发送消息。</p>
</li>
<li><p><strong>全双工通信：</strong> A主机和B主机可以实现在同一时间内既接收消息，又发送消息，极大的提升了通信效率。</p>
</li>
</ul>
<h2 id="常见引导型传输媒体："><a href="#常见引导型传输媒体：" class="headerlink" title="常见引导型传输媒体："></a>常见引导型传输媒体：</h2><h3 id="双绞线："><a href="#双绞线：" class="headerlink" title="双绞线："></a>双绞线：</h3><p>分为屏蔽双绞线（STP）和非屏蔽双绞线（UTP），屏蔽双绞线就是在非屏蔽双绞线外边又加了一层屏蔽层</p>
<p>tips：为什么双绞线要两根线绞起来，两个线绞起来可以有效的减少相互之间的电磁干扰。</p>
<h3 id="同轴电缆："><a href="#同轴电缆：" class="headerlink" title="同轴电缆："></a>同轴电缆：</h3><p>由内导体铜制芯线，绝缘层，网状编织的外导体屏蔽层，以及塑料保护外层组成。有良好的抗干扰性，被广泛用于较高速率的传输。</p>
<h3 id="光缆："><a href="#光缆：" class="headerlink" title="光缆："></a>光缆：</h3><p>由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通讯柱。可以分为单模光纤和多模光纤。</p>
<h2 id="信道复用技术："><a href="#信道复用技术：" class="headerlink" title="信道复用技术："></a>信道复用技术：</h2><ul>
<li><p><strong>频分复用：</strong>根据传输的波的频率的不同，将不同频段的波用于不同的通信。</p>
</li>
<li><p><strong>时分复用：</strong>将时间分割为时间段，规定在某个时间段内发送什么样的信息，根据时间段来进行信息类别的区分。也称为<strong>同步时分复用</strong></p>
</li>
<li><p><strong>统计时分复用：</strong>基于时分复用的一种改进，由于基本的时分复用并没有考虑到每个时间段内是否有信息发出，例如说每个时间段是20，但是发送消息只占用其中的2，那么剩下的18就处于空闲时间。统计时分复用就是基于这种考虑而设计的，他允许用户有数据时就将数据发送到缓存中，然后会依次扫描输入缓存，把缓存中的数据放入到STMD帧中，若没有就跳过，每当一个帧满了就把这个帧发出去。STMD帧不是分配的固定时序，而是根据需要动态的分配时隙，也称之为<strong>异步时分复用</strong></p>
</li>
<li><p>光分复用：就是光的频分复用，根据光谱中频率的不同，用不同频率的光来携带不同的信息。</p>
</li>
</ul>
<h1 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h1><p>数据链路层主要是将上层的数据转化为数据帧发送到链路上，以及把接受到的帧中的数据取出并交给网络层。</p>
<h2 id="通信方式：-1"><a href="#通信方式：-1" class="headerlink" title="通信方式："></a>通信方式：</h2><ul>
<li><p><strong>点对点通信：</strong>通信方式是点到点的，也就是只能是两个点之间的通信。常见的就是PPP协议</p>
</li>
<li><p><strong>广播通信：</strong>广播通讯，也就是可以同时实现一对多的通信。常见的就是CSMA/CD（载波监听多点访问/冲突检测）</p>
</li>
</ul>
<h2 id="核心要解决的问题："><a href="#核心要解决的问题：" class="headerlink" title="核心要解决的问题："></a>核心要解决的问题：</h2><ul>
<li><p><strong>封装成帧：</strong>在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在接受到后就可以方便准确的确定帧的首尾，也称为帧定界符。同时定义出了最大传输单元（MTU）–表示一次可以传输的最大长度上限。</p>
</li>
<li><p><strong>透明传输：</strong> 由于使用特定的字符来表示帧的开始和结束，所以传输的内容中不能出现和帧定界符相同的字符，但这显然是不可能的，为了解决这个办法，就可以在内容中和帧定界符一样的字符前边加上规定好的转义字符，这种方法称为字符填充或者是字节填充。</p>
</li>
<li><p><strong>差错检测：</strong> 比特在传输过程中可能产生差错，差错检测就是用于检测出现的差错，以便及时的重传，最常用的差错检测算法就是<a href="http://baike.sogou.com/v7730112.htm?fromTitle=CRC%E6%A0%A1%E9%AA%8C" target="_blank" rel="external">CRC（循环冗余检验）</a></p>
</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层主要是向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。</p>
<h2 id="IP协议（网际协议）："><a href="#IP协议（网际协议）：" class="headerlink" title="IP协议（网际协议）："></a>IP协议（网际协议）：</h2><p>IP协议是TCP/IP体系中最主要的协议之一，一切在IP之下，一切又在IP之上。我们常说的应该是IP协议族，还包含配套的协议：</p>
<ul>
<li><p>ARP（地址解析协议）：将网络的IP地址转化为实际的物理地址（MAC地址），并存储在MAC地址表中。</p>
</li>
<li><p>ICMP（网际控制报文协议）：用于进行差错情况和异常情况的反馈，分为询问报文和差错报告报文。</p>
</li>
<li><p>IGMP（网际组管理协议）：用于控制和管理多播和组播的协议。</p>
</li>
</ul>
<p>网络地址（IP地址）主要分为五类：</p>
<ul>
<li><p>A类：前8位为网络位，后24位为主机位，首位为0</p>
</li>
<li><p>B类：前16位为网络位，后16位为主机位，前两位为10</p>
</li>
<li><p>C类：前24位为网络位，后8位位主机位，前三位为110</p>
</li>
<li><p>D类：前四位为1110，用于多播地址</p>
</li>
<li><p>E类：前四位为1111，保留为以后使用</p>
</li>
</ul>
<h2 id="路由选择协议："><a href="#路由选择协议：" class="headerlink" title="路由选择协议："></a>路由选择协议：</h2><p>路由选择协议分为<strong>内部网关协议（IGP）</strong>和<strong>外部网关协议（EGP）</strong></p>
<h3 id="内部网关协议："><a href="#内部网关协议：" class="headerlink" title="内部网关协议："></a>内部网关协议：</h3><p>主要是有RIP协议和OSPF协议</p>
<ul>
<li><p><strong>RIP协议（路由信息协议）：</strong>基于距离矢量的协议</p>
</li>
<li><p><strong>OSPF（开放最短路径优先协议）：</strong>基于链路状态的协议</p>
</li>
</ul>
<h3 id="外部网关协议："><a href="#外部网关协议：" class="headerlink" title="外部网关协议："></a>外部网关协议：</h3><p>主要是<strong>边界网关协议（BGP）</strong>，将一个大的网络分为多个小的自治域，每个自治域内有一个网关路由负责和其他的自治域的网关进行通讯。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>网络层主要是为主机之间提供逻辑通讯，而传输层为应用程序之间提供端到端的逻辑通讯。主要是两种类型的通讯方式，面向连接的TCP协议和面向无连接的UDP。</p>
<h2 id="端口号："><a href="#端口号：" class="headerlink" title="端口号："></a>端口号：</h2><p>端口号按照使用地方的不同分为两大类：服务端端口号，客户端端口号。<br>按照占用时长又可以分为熟知端口号（0~1023），登记端口号（1024~49151），短暂端口号（49152~65535）</p>
<h3 id="常见端口："><a href="#常见端口：" class="headerlink" title="常见端口："></a>常见端口：</h3><ul>
<li><p>FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制</p>
</li>
<li><p>Telnet（远程登录协议）：23 </p>
</li>
<li><p>DNS（域名解析服务）：53</p>
</li>
<li><p>TFTP（简单文件传输协议）：69</p>
</li>
<li><p>HTTP（超文本传输协议）：80</p>
</li>
</ul>
<h2 id="两种协议："><a href="#两种协议：" class="headerlink" title="两种协议："></a>两种协议：</h2><ul>
<li><p><strong>UDP（用户数据报协议）：</strong> </p>
<ul>
<li>UDP是无连接的</li>
<li>UDP使用尽最大努力交付，但是不保证可靠交付</li>
<li>UDP是面向报文的</li>
<li>UDP没有拥塞控制</li>
<li>UDP支持一对一，一对多，多对一，多对一的交互通讯</li>
<li>UDP首部的开销小</li>
</ul>
</li>
<li><p><strong>TCP（传输控制协议）：</strong></p>
<ul>
<li>TCP是面向连接的</li>
<li>每一条TCP连接只能由两个端点，每一条TCP连接只能是点对点的$TCP连接：：= { socket_1,socket_2 } ={ (IP_1:port_1),(IP_2:port_2)}$</li>
<li>TCP提供可靠交付的服务</li>
<li>TCP提供全双工通信</li>
<li>面向字节流</li>
</ul>
</li>
</ul>
<h3 id="可靠传输的实现机制："><a href="#可靠传输的实现机制：" class="headerlink" title="可靠传输的实现机制："></a>可靠传输的实现机制：</h3><ul>
<li><p><strong>停止等待协议：</strong> 每发完一个分组就停止发送，直到收到上一个分组的确认信息。若超过规定时间没有接收到确认信息，边认为是分组丢失，开始重传。</p>
</li>
<li><p><strong>连续ARQ协议：</strong>  发送方采用滑动窗口的形式，处于滑动窗口的分组可以直接发送出去；接收方一般采用累积确认的方式，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认，而发送方每接收到一个确认，窗口就向前滑动一定距离。</p>
</li>
<li><p><strong>流量控制：</strong>协调发送方和接收方的收发速率，利用滑动窗口来协调，使用探测报文来探测当前应该发送的速率，采用<a href="http://baike.sogou.com/v10500918.htm?fromTitle=Nagle%E7%AE%97%E6%B3%95" target="_blank" rel="external">Nagle算法</a></p>
</li>
<li><p><strong>拥塞控制：</strong><br>当网络中某一资源的需求超出了该资源所能提供的可用部分，这时网络的性能就要开始变坏，这种情况就叫做拥塞。而拥塞控制就是为了减少或者避免拥塞对网络性能的影响而做出的一种控制手段。</p>
<ul>
<li><p><strong>拥塞控制思路：</strong>发送方维持一个叫做<strong>拥塞窗口</strong>的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的变化。发送方让自己的发送窗口等于拥塞窗口，如果在考虑接收方的接收能力，一般发送窗口还要小于拥塞窗口。</p>
</li>
<li><p><strong>慢开始：</strong>当主机开始发送数据的时候，由小到大的增大发送窗口，也就是由小到大的增大拥塞窗口。接收方接收到一个报文之后就回传一个确认报文，发送方每接收到一个确认报文，就将拥塞窗口加1，这样每经过一个传输轮次之后，拥塞窗口就增大一倍。</p>
</li>
<li><p><strong>拥塞避免：</strong>思路是让拥塞窗口缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口加1，而不是加倍，这样拥塞窗口就是线性缓慢增加，比慢开始的增长速率缓慢的多。</p>
</li>
<li><p><strong>慢开始门限：</strong>为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个慢开始门限</p>
<ul>
<li>拥塞窗口&lt;慢开始门限时，使用慢开始算法</li>
<li>拥塞窗口&gt;慢开始门限时，使用拥塞避免算法</li>
<li>拥塞窗口=慢开始门限时，两种算法都可以</li>
</ul>
</li>
<li><p><strong>快重传：</strong>要求收到方每收到一个时序的报文段之后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。而发送方只要一连收到三个重复确认就应当立即重传对方尚未接受到的报文，而不必等待为报文设置的重传计时器到期。 </p>
</li>
<li><p><strong>快回复：</strong>与快重传配合使用，当发送方连续收到三个重复确认的时候，就执行“乘法减小”算法，将慢开始门限减半。将拥塞窗口设置为慢开始门限减半之后的值，并开始指向拥塞避免算法。</p>
</li>
</ul>
</li>
</ul>
<h3 id="TCP的连接管理："><a href="#TCP的连接管理：" class="headerlink" title="TCP的连接管理："></a>TCP的连接管理：</h3><h4 id="连接三次握手："><a href="#连接三次握手：" class="headerlink" title="连接三次握手："></a>连接三次握手：</h4><ol>
<li>客户端请求建立连接：SYN=1，seq=x；</li>
<li>服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1</li>
<li>客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1</li>
</ol>
<p><strong>注：</strong> SYN为同步信息，在建立连接过程中始终为1</p>
<h4 id="断开连接四次握手："><a href="#断开连接四次握手：" class="headerlink" title="断开连接四次握手："></a>断开连接四次握手：</h4><ol>
<li>客户端请求断开连接： FIN=1，seq = u；</li>
<li>服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1；</li>
<li>服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1；</li>
<li>客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1；</li>
</ol>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层有多种协议，常用到的就是HTTP以及HTTPS。</p>
<p><strong>HTTP协议报文格式</strong></p>
<table>
<thead>
<tr>
<th>请求报文</th>
<th>相应报文</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求行（用于区分是请求报文还是响应报文，在响应报文中为状态行）</td>
<td>状态行</td>
</tr>
<tr>
<td>首部行（用来说明浏览器，服务器或者是报文主体的一些信息）</td>
<td>首部行</td>
</tr>
<tr>
<td>空行（用于隔开请求实体和首部行）</td>
<td>空行</td>
</tr>
<tr>
<td>实体主体（用于一些请求或者是响应的的参数内容等）</td>
<td>实体主体</td>
</tr>
</tbody>
</table>
<p><strong>常见状态码</strong></p>
<blockquote>
<p>1xx：表示通知信息，例如表示收到或者是正在处理<br>2xx：表示成功，例如表示接受或知道了<br>3xx：表示重定向，例如表示完成请求还需要采取进一步的行动<br>4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成<br>5xx：表示服务器端的差错：例如表示服务器失效无法完成请求</p>
</blockquote>
<p>HTTPS协议就是对HTTP协议的加密，更加安全可靠，采用HTTP+SSL（安全套接字层）来保证数据的安全性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是实际使用中的TCP/IP四层模型。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OSI七层模型&lt;/th&gt;
&lt;th&gt;TCP/IP四层模型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbo
    
    </summary>
    
      <category term="网络" scheme="http://fushenghua.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
