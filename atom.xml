<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fuchenxuan’ blog</title>
  <subtitle>不断提高自己认知，不断的为自己想要的努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fushenghua.github.io/"/>
  <updated>2018-06-06T01:57:07.960Z</updated>
  <id>http://fushenghua.github.io/</id>
  
  <author>
    <name>fushenghua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>调试 ART 垃圾回收</title>
    <link href="http://fushenghua.github.io/archives/59f7e7f7.html"/>
    <id>http://fushenghua.github.io/archives/59f7e7f7.html</id>
    <published>2018-06-06T01:55:40.742Z</published>
    <updated>2018-06-06T01:57:07.960Z</updated>
    
    <content type="html"><![CDATA[<p>本文档介绍如何调试 Android 运行时 (ART) 垃圾回收 (GC) 的正确性和性能问题。本文档解释了如何使用 GC 验证选项、确定 GC 验证失败的解决方案，以及测量并解决 GC 性能问题。</p>
<p>有关处理 ART 的说明，请参阅 <a href="https://source.android.google.cn/devices/tech/dalvik/index.html" target="_blank" rel="external">ART 和 Dalvik</a>、<a href="https://source.android.google.cn/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">Dalvik 可执行格式</a>以及此 <a href="https://source.android.google.cn/devices/tech/dalvik/index.html" target="_blank" rel="external">ART 和 Dalvik</a> 部分的其他页面。有关验证应用行为的其他帮助信息，请参阅<a href="http://developer.android.google.cn/guide/practices/verifying-apps-art.html" target="_blank" rel="external">在 Android 运行时 (ART) 上验证应用行为</a>。</p>
<h2 id="ART-GC-概述"><a href="#ART-GC-概述" class="headerlink" title="ART GC 概述"></a><a href="https://source.android.google.cn/devices/tech/dalvik/gc-debug#top_of_page" target="_blank" rel="external"></a>ART GC 概述</h2><p>ART 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。我们已不再继续维护和提供 Dalvik 运行时，现在 ART 采用了其字节码格式。请注意，本节仅总结 ART 的 GC。有关其他信息，请观看在 Google I/O 2014 上进行的 <a href="https://www.google.com/events/io/io14videos/b750c8da-aebe-e311-b297-00155d5066d7" target="_blank" rel="external">Android 运行时</a>演示。</p>
<p>ART 有多个不同的 GC 方案，这些方案包括运行不同垃圾回收器。默认方案是 CMS（并发标记清除）方案，主要使用粘性 CMS 和部分 CMS。粘性 CMS 是 ART 的不移动分代垃圾回收器。它仅扫描堆中自上次 GC 后修改的部分，并且只能回收自上次 GC 后分配的对象。除 CMS 方案外，当应用将进程状态更改为察觉不到卡顿的进程状态（例如，后台或缓存）时，ART 将执行堆压缩。</p>
<p>除了新的垃圾回收器之外，ART 还引入了一种基于位图的新内存分配程序，称为 RosAlloc（插槽运行分配器）。此新分配器具有分片锁，当分配规模较小时可添加线程的本地缓冲区，因而性能优于 DlMalloc。</p>
<p>与 Dalvik 相比，ART CMS 垃圾回收计划在很多方面都有一定的改善：</p>
<ul>
<li>与 Dalvik 相比，暂停次数从 2 次减少到 1 次。Dalvik 的第一次暂停主要是为了进行根标记，即在 ART 中进行并发标记，让线程标记自己的根，然后马上恢复运行。</li>
<li>与 Dalvik 类似，ART GC 在清除过程开始之前也会暂停 1 次。两者在这方面的主要差异在于：在此暂停期间，某些 Dalvik 环节在 ART 中并发进行。这些环节包括 <code>java.lang.ref.Reference</code> 处理、系统弱清除（例如，jni 弱全局等）、重新标记非线程根和卡片预清理。在 ART 暂停期间仍进行的阶段包括扫描脏卡片以及重新标记线程根，这些操作有助于缩短暂停时间。</li>
<li>相对于 Dalvik，ART GC 改进的最后一个方面是粘性 CMS 回收器增加了 GC 吞吐量。不同于普通的分代 GC，粘性 CMS 不移动。系统会将年轻对象保存在一个分配堆栈（基本上是 <code>java.lang.Object</code> 数组）中，而非为其设置一个专属区域。这样可以避免移动所需的对象以维持低暂停次数，但缺点是容易在堆栈中加入大量复杂对象图像而使堆栈变长。</li>
</ul>
<p>ART GC 与 Dalvik 的另一个主要区别在于 ART GC 引入了移动垃圾回收器。使用移动 GC 的目的在于通过堆压缩来减少后台应用使用的内存。目前，触发堆压缩的事件是 ActivityManager 进程状态的改变。当应用转到后台运行时，它会通知 ART 已进入不再“感知”卡顿的进程状态。此时 ART 会进行一些操作（例如，压缩和监视器压缩），从而导致应用线程长时间暂停。目前正在使用的两个移动 GC 是同构空间压缩和半空间压缩。</p>
<ul>
<li>半空间压缩将对象在两个紧密排列的碰撞指针空间之间进行移动。这种移动 GC 适用于小内存设备，因为它可以比同构空间压缩稍微多节省一点内存。额外节省出的空间主要来自紧密排列的对象，这样可以避免 RosAlloc/DlMalloc 分配器占用开销。由于 CMS 仍在前台使用，且不能从碰撞指针空间中进行收集，因此当应用在前台使用时，半空间还要再进行一次转换。这种情况并不理想，因为它可能引起较长时间的暂停。</li>
<li>同构空间压缩通过将对象从一个 RosAlloc 空间复制到另一个 RosAlloc 空间来实现。这有助于通过减少堆碎片来减少内存使用量。这是目前非低内存设备的默认压缩模式。相比半空间压缩，同构空间压缩的主要优势在于应用从后台切换到前台时无需进行堆转换。</li>
</ul>
<h2 id="GC-验证和性能选项"><a href="#GC-验证和性能选项" class="headerlink" title="GC 验证和性能选项"></a><a href="https://source.android.google.cn/devices/tech/dalvik/gc-debug#top_of_page" target="_blank" rel="external"></a>GC 验证和性能选项</h2><p>如果您是原始设备制造商 (OEM)，就可以更改 GC 类型。要执行该操作，您需要通过 adb 修改系统属性。请记住，这些属性只能在非用户版本或 root 版本上修改。</p>
<h3 id="更改-GC-类型"><a href="#更改-GC-类型" class="headerlink" title="更改 GC 类型"></a>更改 GC 类型</h3><p>您可以采用多种方法来更改 ART 使用的 GC 计划。更改前台 GC 计划的主要方法是更改 <code>dalvik.vm.gctype</code> 属性或传递 <code>-Xgc:</code> 选项。您可以通过以逗号分隔的格式传递多个 GC 选项。</p>
<p>为了导出可用 <code>-Xgc</code> 设置的完整列表，可以键入 <code>adb shell dalvikvm -help</code> 来输出各种运行时命令行选项。</p>
<p>以下是将 GC 更改为半空间并打开 GC 前堆验证的一个示例： <code>adb shell setprop dalvik.vm.gctype SS,preverify</code></p>
<ul>
<li><code>CMS</code> 也是默认值，指定并发标记清除 GC 计划。该计划包括运行粘性分代 CMS、部分 CMS 和完整 CMS。该计划的分配器是适用于可移动对象的 RosAlloc 和适用于不可移动对象的 DlMalloc。</li>
<li><code>SS</code> 指定半空间 GC 计划。该计划有两个适用于可移动对象的半空间和一个适用于不可移动对象的 DlMalloc 空间。可移动对象分配器默认设置为使用原子操作的共享碰撞指针分配器。但是，如果 <code>-XX:UseTLAB</code> 标记也被传入，则分配器使用线程局部碰撞指针分配。</li>
<li><code>GSS</code> 指定分代半空间计划。该计划与半空间计划非常相似，但区别在于其会将存留期较长的对象提升到大型 RosAlloc 空间中。这样就可明显减少典型用例中需复制的对象。</li>
</ul>
<h3 id="验证堆"><a href="#验证堆" class="headerlink" title="验证堆"></a>验证堆</h3><p>堆验证可能是调试 GC 相关错误或堆损坏的最有用的 GC 选项。启用堆验证会使 GC 在垃圾回收过程中在几个点检查堆的正确性。堆验证与更改 GC 类型的选项相同。启用堆验证后，堆验证会验证根，并确保可访问对象仅引用其他可访问对象。通过传入以下 -<code>Xgc</code> 值可以启用 GC 验证：</p>
<ul>
<li>如果启用 GC 验证，<code>[no]preverify</code> 将在 GC 启动之前执行堆验证。</li>
<li>如果启用 GC 验证，<code>[no]presweepingverify</code> 将在启动垃圾回收器清除过程之前执行堆验证。</li>
<li>如果启用 GC 验证，<code>[no]postverify</code> 将在 GC 完成清除后执行堆验证。</li>
<li><code>[no]preverify_rosalloc</code>、<code>[no]postsweepingverify_rosalloc</code> 和 <code>[no]postverify_rosalloc</code> 也是附加 GC 选项，仅验证 RosAlloc 内部计算的状态。验证的主要内容是，魔数值是否与预期常量匹配，以及可用内存块是否已在 <code>free_page_runs_</code> 映射中注册。</li>
</ul>
<h3 id="使用-TLAB-分配器选项"><a href="#使用-TLAB-分配器选项" class="headerlink" title="使用 TLAB 分配器选项"></a>使用 TLAB 分配器选项</h3><p>目前，只有 TLAB 选项可以更改分配器而不影响活动 GC 类型。此选项不可通过系统属性使用，但可以通过将 - <code>XX:UseTLAB</code> 传递给 <code>dalvikvm</code> 来启用。该选项的分配代码路径更短，因此分配速度更快。由于此选项需要使用暂停时间相当长的 SS 或 GSS GC 类型，因此默认情况下不启用。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a><a href="https://source.android.google.cn/devices/tech/dalvik/gc-debug#top_of_page" target="_blank" rel="external"></a>性能</h2><p>评测 GC 性能主要使用两种工具：GC 时间转储和 systrace。评测 GC 性能问题的最直观方法是使用 systrace 确定哪些 GC 会导致长时间暂停或抢占应用线程。尽管 ART GC 效率相对较高，但是过度分配或错误的变异器行为等都能造成性能问题。</p>
<h3 id="人机工程学"><a href="#人机工程学" class="headerlink" title="人机工程学"></a>人机工程学</h3><p>与 Dalvik 相比，ART 在 GC 人机工程学方面存在一些重要差异。与 Dalvik 相比，其中一项重要改进是在我们延后启用并行 GC 时不再分配 GC。但是，此操作存在一个缺点：在某些情况下，不阻止 GC 会导致堆的增长速度比 Dalvik 快。好在 ART 具有堆压缩功能，可在进程变为后台进程状态时对堆进行碎片整理来缓解此问题。</p>
<p>CMS GC 人机工程学有两种定期运行的 GC。理想情况下，GC 人机工程学更多时间运行的是分代粘性 CMS，而非部分 CMS。GC 将一直运行粘性 CMS，直到最后一个 GC 的吞吐量（通过释放的字节数/GC 持续秒数计算得出）小于部分 CMS 的平均吞吐量。发生此情况时，人机工程学将下一个并发 GC 计划为部分 CMS，而非粘性 CMS。部分 CMS 完成后，人机工程学将下一个 GC 更改回粘性 CMS。粘性 CMS 在完成后不会调整堆占用空间限制，这是促使人机工程学发挥作用的一个关键因素。这样，粘性 CMS 的发生频率更高，直到吞吐量低于部分 CMS，最终导致堆增大。</p>
<h3 id="使用-SIGQUIT-获取-GC-性能信息"><a href="#使用-SIGQUIT-获取-GC-性能信息" class="headerlink" title="使用 SIGQUIT 获取 GC 性能信息"></a>使用 SIGQUIT 获取 GC 性能信息</h3><p>通过将 SIGQUIT 发送到已运行的应用，或在启动命令行程序时通过将 -<code>XX:DumpGCPerformanceOnShutdown</code> 传递给 <code>dalvikvm</code>，可以获得应用的 GC 性能时序。当应用获得 ANR 请求信号 (SIGQUIT) 时，它将转储与锁定、线程堆栈和 GC 性能相关的信息。</p>
<p>获取 GC 时序转储的方法是使用以下命令：</p>
<p>adb shell kill -S QUIT PID</p>
<p>该操作将在 <code>/data/anr/</code> 中创建一个 <code>traces.txt</code> 文件。此文件包含一些 ANR 转储信息以及 GC 时序。您可以通过搜索“转储累计 GC 时序”来确定 GC 时序。这些时序会显示一些相关内容。它会显示各 GC 类型的阶段和暂停的直方图信息。暂停信息通常比较重要。例如：</p>
<p>sticky concurrent mark sweep paused:    Sum: 5.491ms 99% C.I. 1.464ms-2.133ms Avg: 1.830ms Max: 2.133ms</p>
<p><code>This</code> 显示暂停的平均时间为 1.83 ms。该值足够低，在大多数应用中不会导致丢帧，因此无需担心。</p>
<p>需要关注的另一个问题是挂起时间。挂起时间测量在 GC 要求某个线程挂起后，线程到达挂起点所需的时间。该时间包含在 GC 暂停中，所以可用于确定长时间暂停是否是由 GC 缓慢或线程挂起缓慢造成。以下是 Nexus 5 上的正常挂起时间示例：</p>
<p>suspend all histogram:    Sum: 1.513ms 99% C.I. 3us-546.560us Avg: 47.281us Max: 601us</p>
<p>还有一些其他要关注的方面，例如总耗时、GC 吞吐量等。示例如下：</p>
<p>Total time spent in GC: 502.251ms<br>Mean GC size throughput: 92MB/s<br>Mean GC object throughput: 1.54702e+06 objects/s</p>
<p>转储已运行应用的 GC 时序的示例如下：</p>
<p><code>adb shell kill -s QUIT &lt;var style=&quot;box-sizing: inherit; color: rgb(236, 64, 122); -webkit-font-smoothing: auto; font-weight: 700;&quot;&gt;PID&lt;/var&gt;</code><br><code>adb pull /data/anr/traces.txt</code></p>
<p>此时，GC 时序包含在 trace.txt 中。Google 地图的输出示例如下：</p>
<p>Start Dumping histograms for 34 iterations for sticky concurrent mark sweep<br>ScanGrayAllocSpaceObjects:    Sum: 196.174ms 99% C.I. 0.011ms-11.615ms Avg: 1.442ms Max: 14.091ms<br>FreeList:    Sum: 140.457ms 99% C.I. 6us-1676.749us Avg: 128.505us Max: 9886us<br>MarkRootsCheckpoint:    Sum: 110.687ms 99% C.I. 0.056ms-9.515ms Avg: 1.627ms Max: 10.280ms<br>SweepArray:    Sum: 78.727ms 99% C.I. 0.121ms-11.780ms Avg: 2.315ms Max: 12.744ms<br>ProcessMarkStack:    Sum: 77.825ms 99% C.I. 1.323us-9120us Avg: 576.481us Max: 10185us<br>(Paused)ScanGrayObjects:    Sum: 32.538ms 99% C.I. 286us-3235.500us Avg: 986us Max: 3434us<br>AllocSpaceClearCards:    Sum: 30.592ms 99% C.I. 10us-2249.999us Avg: 224.941us Max: 4765us<br>MarkConcurrentRoots:    Sum: 30.245ms 99% C.I. 3us-3017.999us Avg: 444.779us Max: 3774us<br>ReMarkRoots:    Sum: 13.144ms 99% C.I. 66us-712us Avg: 386.588us Max: 712us<br>ScanGrayImageSpaceObjects:    Sum: 13.075ms 99% C.I. 29us-2538.999us Avg: 192.279us Max: 3080us<br>MarkingPhase:    Sum: 9.743ms 99% C.I. 170us-518us Avg: 286.558us Max: 518us<br>SweepSystemWeaks:    Sum: 8.046ms 99% C.I. 28us-479us Avg: 236.647us Max: 479us<br>MarkNonThreadRoots:    Sum: 5.215ms 99% C.I. 31us-698.999us Avg: 76.691us Max: 703us<br>ImageModUnionClearCards:    Sum: 2.708ms 99% C.I. 26us-92us Avg: 39.823us Max: 92us<br>ScanGrayZygoteSpaceObjects:    Sum: 2.488ms 99% C.I. 19us-250.499us Avg: 37.696us Max: 295us<br>ResetStack:    Sum: 2.226ms 99% C.I. 24us-449us Avg: 65.470us Max: 452us<br>ZygoteModUnionClearCards:    Sum: 2.124ms 99% C.I. 18us-233.999us Avg: 32.181us Max: 291us<br>FinishPhase:    Sum: 1.881ms 99% C.I. 31us-431.999us Avg: 55.323us Max: 466us<br>RevokeAllThreadLocalAllocationStacks:    Sum: 1.749ms 99% C.I. 8us-349us Avg: 51.441us Max: 377us<br>EnqueueFinalizerReferences:    Sum: 1.513ms 99% C.I. 3us-201us Avg: 44.500us Max: 201us<br>ProcessReferences:    Sum: 438us 99% C.I. 3us-212us Avg: 12.882us Max: 212us<br>ProcessCards:    Sum: 381us 99% C.I. 4us-17us Avg: 5.602us Max: 17us<br>PreCleanCards:    Sum: 363us 99% C.I. 8us-17us Avg: 10.676us Max: 17us<br>ReclaimPhase:    Sum: 357us 99% C.I. 7us-91.500us Avg: 10.500us Max: 93us<br>(Paused)PausePhase:    Sum: 312us 99% C.I. 7us-15us Avg: 9.176us Max: 15us<br>SwapBitmaps:    Sum: 166us 99% C.I. 4us-8us Avg: 4.882us Max: 8us<br>(Paused)ScanGrayAllocSpaceObjects:    Sum: 126us 99% C.I. 14us-112us Avg: 63us Max: 112us<br>MarkRoots:    Sum: 121us 99% C.I. 2us-7us Avg: 3.558us Max: 7us<br>(Paused)ScanGrayImageSpaceObjects:    Sum: 68us 99% C.I. 68us-68us Avg: 68us Max: 68us<br>BindBitmaps:    Sum: 50us 99% C.I. 1us-3us Avg: 1.470us Max: 3us<br>UnBindBitmaps:    Sum: 49us 99% C.I. 1us-3us Avg: 1.441us Max: 3us<br>SwapStacks:    Sum: 47us 99% C.I. 1us-3us Avg: 1.382us Max: 3us<br>RecordFree:    Sum: 42us 99% C.I. 1us-3us Avg: 1.235us Max: 3us<br>ForwardSoftReferences:    Sum: 37us 99% C.I. 1us-2us Avg: 1.121us Max: 2us<br>InitializePhase:    Sum: 36us 99% C.I. 1us-2us Avg: 1.058us Max: 2us<br>FindDefaultSpaceBitmap:    Sum: 32us 99% C.I. 250ns-1000ns Avg: 941ns Max: 1000ns<br>(Paused)ProcessMarkStack:    Sum: 5us 99% C.I. 250ns-3000ns Avg: 147ns Max: 3000ns<br>PreSweepingGcVerification:    Sum: 0 99% C.I. 0ns-0ns Avg: 0ns Max: 0ns<br>Done Dumping histograms<br>sticky concurrent mark sweep paused:    Sum: 63.268ms 99% C.I. 0.308ms-8.405ms<br>Avg: 1.860ms Max: 8.883ms<br>sticky concurrent mark sweep total time: 763.787ms mean time: 22.464ms<br>sticky concurrent mark sweep freed: 1072342 objects with total size 75MB<br>sticky concurrent mark sweep throughput: 1.40543e+06/s / 98MB/s<br>Total time spent in GC: 4.805s<br>Mean GC size throughput: 18MB/s<br>Mean GC object throughput: 330899 objects/s<br>Total number of allocations 2015049<br>Total bytes allocated 177MB<br>Free memory 4MB<br>Free memory until GC 4MB<br>Free memory until OOME 425MB<br>Total memory 90MB<br>Max memory 512MB<br>Zygote space size 4MB<br>Total mutator paused time: 229.566ms<br>Total time waiting for GC to complete: 187.655us</p>
<h2 id="分析-GC-正确性问题的工具"><a href="#分析-GC-正确性问题的工具" class="headerlink" title="分析 GC 正确性问题的工具"></a><a href="https://source.android.google.cn/devices/tech/dalvik/gc-debug#top_of_page" target="_blank" rel="external"></a>分析 GC 正确性问题的工具</h2><p>造成 ART 内部崩溃的原因多种多样。读取或写入对象字段时出现崩溃可能表示存在堆损坏。如果 GC 在运行时崩溃，也可能是由堆损坏造成的。造成堆损坏的原因多种多样，最常见的原因可能是应用代码错误。好在可以使用相关工具调试与 GC 和堆相关的崩溃问题。此类工具包括上面指定的堆验证选项、valgrind 和 CheckJNI。</p>
<h3 id="CheckJNI"><a href="#CheckJNI" class="headerlink" title="CheckJNI"></a>CheckJNI</h3><p>验证应用行为的另一种方法是使用 CheckJNI。CheckJNI 是一种添加额外 JNI 检查的模式；出于性能考虑，这些选项在默认情况下并不会启用。此类检查将捕获一些可能导致堆损坏的错误，例如使用无效/过时的局部和全局引用。启用 CheckJNI 的方法如下：</p>
<p>adb shell setprop dalvik.vm.checkjni true</p>
<p>Forcecopy 模式是 CheckJNI 的另一部分，对检测超出数组区域末端的写入非常有用。启用后，forcecopy 会促使数组访问 JNI 函数时始终返回带有红色区域的副本。红色区域是返回指针结束/开始处的一个区域，该区域具有特殊值，并在数组释放时得到验证。如果红色区域中的值与预期值不匹配，则通常意味着发生缓冲区溢出或欠载。这将导致 CheckJNI 中止。启用 forcecopy 模式的方法如下：</p>
<p>adb shell setprop dalvik.vm.jniopts forcecopy</p>
<p>CheckJNI 应捕获错误的一个示例是超出从 <code>GetPrimitiveArrayCritical</code> 获取的数组末端的写入。该操作很可能会破坏 Java 堆。如果写入位于 CheckJNI 红色区域内，则在调用相应 <code>ReleasePrimitiveArrayCritical</code> 时，CheckJNI 将会捕获该问题。否则，写入将最终损坏 Java 堆中的一些随机对象，并可能会导致之后出现 GC 崩溃。如果崩溃的内存是引用字段，则 GC 可能会捕获错误并输出“Tried to mark not contained by any spaces”这一错误消息。</p>
<p>当 GC 尝试标记无法找到空间的对象时，就会发生此错误。在此检查失败后，GC 会遍历根，并尝试查看无效对象是否为根。结果共有两个选项：对象为根或非根。</p>
<h3 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h3><p>ART 堆支持可选的 valgrind 工具，这款工具提供了一种方法来检测对无效堆地址的读取和写入操作。ART 可检测应用何时在 valgrind 下运行，并在每个对象分配前后插入红色区域。如果对这些红色区域有任何读取或写入错误，valgrind 将输出错误消息。例如，如果您在通过 JNI 直接访问数组时，越过数组元素末端进行读取或写入，就会出现此类错误。由于 AOT 编译器使用隐式 null 检查，因此建议使用 eng 版本运行 valgrind。另外值得一提的是，valgrind 比正常执行速度慢一个数量级。</p>
<p>以下是一个使用示例：</p>
<h1 id="build-and-install"><a href="#build-and-install" class="headerlink" title="build and install"></a>build and install</h1><p><code>mmm external/valgrind</code><br><code>adb remount &amp;&amp; adb sync</code></p>
<h1 id="disable-selinux"><a href="#disable-selinux" class="headerlink" title="disable selinux"></a>disable selinux</h1><p><code>adb shell setenforce 0</code><br><code>adb shell setprop wrap.com.android.calculator2</code><br>“TMPDIR=/data/data/com.android.calculator2 logwrapper valgrind”</p>
<h1 id="push-symbols"><a href="#push-symbols" class="headerlink" title="push symbols"></a>push symbols</h1><p><code>adb shell mkdir /data/local/symbols</code><br><code>adb push $OUT/symbols /data/local/symbols</code><br><code>adb logcat</code></p>
<h3 id="无效的根示例"><a href="#无效的根示例" class="headerlink" title="无效的根示例"></a>无效的根示例</h3><p>如果对象实际上为无效根，则会输出一些有用信息： <code>art E 5955 5955 art/runtime/gc/collector/mark_sweep.cc:383] Tried to mark 0x2 not contained by any spaces</code></p>
<p>art E  5955  5955 art/runtime/gc/collector/mark_sweep.cc:384] Attempting see if<br>it’s a bad root<br>art E  5955  5955 art/runtime/gc/collector/mark_sweep.cc:485] Found invalid<br>root: 0x2<br>art E  5955  5955 art/runtime/gc/collector/mark_sweep.cc:486]<br>Type=RootJavaFrame thread_id=1 location=Visiting method ‘java.lang.Object<br>com.google.gwt.corp.collections.JavaReadableJsArray.get(int)’ at dex PC 0x0002<br>(native PC 0xf19609d9) vreg=1</p>
<p>在这种情况下，<code>vreg 1</code>（在 <code>com.google.gwt.corp.collections.JavaReadableJsArray.get</code>内）应该包含一个堆引用，但实际上却包含了地址 <code>0x2</code> 的一个无效指针。这显然是一个无效根。要调试此问题，下一步是在 oat 文件中使用 <code>oatdump</code>，并查看具有无效根的方法。在这种情况下，结果证明错误在于 x86 后端的编译器错误。修正该错误的更改列表如下：<a href="https://android-review.googlesource.com/#/c/133932/" target="_blank" rel="external">https://android-review.googlesource.com/#/c/133932/</a></p>
<h3 id="损坏的对象示例"><a href="#损坏的对象示例" class="headerlink" title="损坏的对象示例"></a>损坏的对象示例</h3><p>如果对象不是根，则会输出类似于以下输出内容的消息：</p>
<p>01-15 12:38:00.196  1217  1238 E art     : Attempting see if it’s a bad root<br>01-15 12:38:00.196  1217  1238 F art     :<br>art/runtime/gc/collector/mark_sweep.cc:381] Can’t mark invalid object</p>
<p>当堆损坏不是无效根时，将很难进行调试。此错误消息表示堆中至少含有一个指向无效对象的对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文档介绍如何调试 Android 运行时 (ART) 垃圾回收 (GC) 的正确性和性能问题。本文档解释了如何使用 GC 验证选项、确定 GC 验证失败的解决方案，以及测量并解决 GC 性能问题。&lt;/p&gt;
&lt;p&gt;有关处理 ART 的说明，请参阅 &lt;a href=&quot;http
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么说枚举更占内存，枚举原理是什么？</title>
    <link href="http://fushenghua.github.io/archives/3e3728fd.html"/>
    <id>http://fushenghua.github.io/archives/3e3728fd.html</id>
    <published>2018-04-09T07:39:39.000Z</published>
    <updated>2018-04-20T05:25:03.643Z</updated>
    
    <content type="html"><![CDATA[<p>从以前学习java 开始就听说枚举很占内存，然后老版Android开发指南文章也指出，枚举通常需要比静态常量多两倍的内存。你应该严格避免在android上使用枚举。那么究竟为什么说枚举更占内存呢？本文就是通过这种方法来分析枚举为什么占内存的，而不是说拒绝枚举。</p>
<blockquote>
<p>在阅读过程中有任何问题，请及时联系。如需转载请注明 <a href="http://blog.csdn.net/vfush" target="_blank" rel="external">fuchenxuan de Blog</a>  </p>
</blockquote>
<h2 id="关于-Enum"><a href="#关于-Enum" class="headerlink" title="关于 Enum"></a>关于 Enum</h2><p><code>Enum</code> 一般用来表示一组相同类型可列举的常量。如性别、日期、月份、颜色等。对这些属性用常量的好处是显而易见的，不仅可以保证单例，且比较时候可以用 <code>”==”</code> 来替换 <code>equals</code> 。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>看看枚举的基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;   </div><div class="line">  </div><div class="line">  RED , BLUE,GREEN,BLACK ;   </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>通常会使用<code>javap -c Color.class</code> 反编译<code>class</code> 文件，查看生成的字节码，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Compiled from "Color.java"</div><div class="line">public final class org.fast.clean.Color extends java.lang.Enum&lt;org.fast.clean.Color&gt; &#123;</div><div class="line">  public static final org.fast.clean.Color RED;</div><div class="line"></div><div class="line">  public static final org.fast.clean.Color BLUE;</div><div class="line"></div><div class="line">  public static final org.fast.clean.Color GREEN;</div><div class="line"></div><div class="line">  public static final org.fast.clean.Color BLACK;</div><div class="line"></div><div class="line">  public static org.fast.clean.Color[] values();</div><div class="line">    Code:</div><div class="line">       0: getstatic     #1                  // Field $VALUES:[Lorg/fast/clean/Color;</div><div class="line">       3: invokevirtual #2                  // Method "[Lorg/fast/clean/Color;".clone:()Ljava/lang/Object;</div><div class="line">       6: checkcast     #3                  // class "[Lorg/fast/clean/Color;"</div><div class="line">       9: areturn</div><div class="line"></div><div class="line">  public static org.fast.clean.Color valueOf(java.lang.String);</div><div class="line">    Code:</div><div class="line">     ....</div><div class="line">            9: areturn</div><div class="line"></div><div class="line">  static &#123;&#125;;</div><div class="line">    Code:</div><div class="line">       0: new           #4                  // class org/fast/clean/Color</div><div class="line">       3: dup</div><div class="line">       4: ldc           #7                  // String RED</div><div class="line">       6: iconst_0</div><div class="line">       7: invokespecial #8                  // Method "&lt;init&gt;":(Ljava/lang/</div><div class="line">       ....</div><div class="line">      10: putstatic     #9                  // Field RED:Lorg/fast/clean/Color;</div><div class="line">      13: new           #4                  // class org/fast/clean/Color</div><div class="line">      16: dup</div><div class="line">      17: ldc           #10                 // String BLUE</div><div class="line">          83: return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>org.fast.clean.Color</code> 类被编译成继承自继承自<code>java.lang.Enum</code>的<code>final</code>类，其中的成员变量也是final常量，它们都不能被修改的。</p>
<p>下面使用<a href="http://www.javadecompilers.com/jad" target="_blank" rel="external">jad </a>反编译生成jad源码文件， 文件显示每个方法的字节码的实际作用，与源码做出对比。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Color[] values()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (Color[])$VALUES.clone();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Color <span class="title">valueOf</span><span class="params">(String s)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (Color)Enum.valueOf(org/fast/clean/Color, s);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">super</span>(s, i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLACK;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color $VALUES[];</div><div class="line">    <span class="keyword">static</span> </div><div class="line">    &#123;</div><div class="line">        RED = <span class="keyword">new</span> Color(<span class="string">"RED"</span>, <span class="number">0</span>);</div><div class="line">        BLUE = <span class="keyword">new</span> Color(<span class="string">"BLUE"</span>, <span class="number">1</span>);</div><div class="line">        GREEN = <span class="keyword">new</span> Color(<span class="string">"GREEN"</span>, <span class="number">2</span>);</div><div class="line">        BLACK = <span class="keyword">new</span> Color(<span class="string">"BLACK"</span>, <span class="number">3</span>);</div><div class="line">        $VALUES = (<span class="keyword">new</span> Color[] &#123;</div><div class="line">            RED, BLUE, GREEN, BLACK</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过比较字节码和源代码的区别，我们可以知道为什么枚举确实比简单的静态变量占用的内存要更多。</p>
<h2 id="Android-简单替代枚举的方法"><a href="#Android-简单替代枚举的方法" class="headerlink" title="Android 简单替代枚举的方法"></a>Android 简单替代枚举的方法</h2><p>严格来讲，这个使用方法是有很多缺陷的，但是使用下面的方法就能满足需求的话，那么用<code>Java Enum</code>是会带来各种更大的开销。</p>
<ul>
<li><strong>方法一：使用接口变量</strong></li>
</ul>
<p>接口变量默认都是<code>public static final</code>的，个人理解接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展(不同的实现<code>implements</code>)开放，接口是对开闭原则的一种体现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorCode</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ERROR_MANUAL_EXP = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ERROR_MANUAL_BACK = <span class="number">101</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>javap Color.class</code> 反编译<code>class</code> 文件，查看生成的字节码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Compiled from <span class="string">"ErrorCode.java"</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">org</span>.<span class="title">fast</span>.<span class="title">clean</span>.<span class="title">ErrorCode</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_MANUAL_EXP;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_MANUAL_BACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出就是一个<code>public static final</code>的静态变量。</p>
<ul>
<li><strong>方法二：使用support-annotations 注解库</strong></li>
</ul>
<p>从<code>Android Support Library19.1</code>版本开始引入了一个新的注解库，使用 <code>com.android.support:support-annotations</code> ，这个官方的注解支持库中包含了许多很好的注解，可以帮助我们在编译的时候就找到错误。<code>IntDef</code> 和 <code>StringDef</code> 是包含在库中的两个关于常量的注解，我们可以用来代替枚举其中包括了很多有用的元注解，可以用来修饰代码，如<code>@NonNull</code>，<code>@StringRes</code>，<code>@IntDef</code>，<code>@StringDef</code>等等</p>
<p>下面我们使用<code>@IntDef</code>来替代枚举,方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">0</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLUE = <span class="number">1</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="meta">@IntDef</span>(&#123;RED, BLUE, GREEN&#125;)</div><div class="line">  <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line">  <span class="keyword">public</span> <span class="meta">@interface</span> Colors &#123;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>gradle 依赖：</p>
<blockquote>
<p>dependencies { compile ‘com.android.support:support-annotations:24.2.0’ } </p>
</blockquote>
<p>等等还有其他方法。</p>
<h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><p>枚举在单例的使用也是很平常的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleTon &#123;</div><div class="line">       INSTANCE;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">//单例对象的获取：</span></div><div class="line">   SingleTon instance = SingleTon.INSTANCE;</div></pre></td></tr></table></figure></p>
<p>通过查看<code>java.lang.Enum</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * prevent default deserialization</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,</span></div><div class="line">       ClassNotFoundException &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>对于单例是否安全，主要考虑以下两方面：序列化和反序列方面、线程安全方面。</p>
<ul>
<li><p>对于序列化和反序列化，因为每一个枚举类型和枚举变量在JVM中都是唯一的，即Java在序列化和反序列化枚举时做了特殊的规定，枚举的<code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法是被编译器禁用的，因此也不存在实现序列化接口后调用<code>readObject</code>会破坏单例的问题。</p>
</li>
<li><p>对于线程安全方面，类似于普通的饿汉模式，通过在第一次调用时的静态初始化创建的对象是线程安全的。</p>
</li>
</ul>
<p>所以使用枚举也是一种比较好的单例模式，通过反编译我们知道，缺点就是不能够继承，因为<code>final</code>了。</p>
<p>通过上面的分析枚举，我们只是讨论为什么说枚举更占内存，枚举原理是什么，而不是让我们拒绝使用枚举，因为就几个枚举，让应用内存开销大，那就实在是太可怕了。。。更重要的是通过比较字节码和源代码，我们可以发现很多的问题，一个很重要的作用就是了解很多编译器内部的工作机制。</p>
<p> 更多java 学习总结，请点击下方图片哦。</p>
<blockquote>
<p>水平有限，若有错漏，欢迎指正，批评，如需转载，请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a>，谢谢！<br><a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160608162227307" alt="这里写图片描述"></a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从以前学习java 开始就听说枚举很占内存，然后老版Android开发指南文章也指出，枚举通常需要比静态常量多两倍的内存。你应该严格避免在android上使用枚举。那么究竟为什么说枚举更占内存呢？本文就是通过这种方法来分析枚举为什么占内存的，而不是说拒绝枚举。&lt;/p&gt;
&lt;b
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>在Pypi上发布自己的Python包</title>
    <link href="http://fushenghua.github.io/archives/ed6915f6.html"/>
    <id>http://fushenghua.github.io/archives/ed6915f6.html</id>
    <published>2018-04-09T07:39:39.000Z</published>
    <updated>2018-04-20T05:25:03.649Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python编程的都知道，Python的包安装非常的方便，一般都是可以<strong>pip</strong>来安装搞定：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sudo pip <span class="keyword">install</span></div></pre></td></tr></table></figure>
<p>pip的安装请移步：<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="external">https://pip.pypa.io/en/stable/installing/</a></p>
<p>在<a href="https://github.com/fushenghua/gitbook-plugin-summary" target="_blank" rel="external">gitbook-plugin-summary</a> 需要，发布了一个自己的pypi Python包，这里我大致分享如何发布自己的Pypi包一般过程。</p>
<p>打包工作主要依赖python的一个叫setuptools的包来完成，在进行下面操作前请使用pip安装它：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip <span class="keyword">install</span> setuptools</div></pre></td></tr></table></figure>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul>
<li>注册</li>
</ul>
<p><a href="https://pypi.python.org/pypi" target="_blank" rel="external">https://pypi.python.org/pypi</a>注册自己的用户, 点击“Register”，填写自己的用户名，密码，邮件地址后，就成功了，我是直接用Google 账户。</p>
<p><img src="/images/15236887893053.jpg" alt=""></p>
<p>记住自己的用户名和密码，后面上传的时候要输入的</p>
<h3 id="准备setup-py-setup-conf文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier-等等，下面是我自己包的一个setup-py文件的内容，基本上只需要在这个上面修改就行了，具体如下："><a href="#准备setup-py-setup-conf文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier-等等，下面是我自己包的一个setup-py文件的内容，基本上只需要在这个上面修改就行了，具体如下：" class="headerlink" title="准备setup.py/setup.conf文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier)等等，下面是我自己包的一个setup.py文件的内容，基本上只需要在这个上面修改就行了，具体如下："></a>准备setup.py/setup.conf文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier)等等，下面是我自己包的一个setup.py文件的内容，基本上只需要在这个上面修改就行了，具体如下：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">!/usr/bin/env python <span class="meta"># coding=utf-8</span></div><div class="line"></div><div class="line">from setuptools <span class="keyword">import</span> <span class="built_in">setup</span>, find_packages</div><div class="line"></div><div class="line"><span class="built_in">setup</span>(</div><div class="line">    name=<span class="string">''</span>,</div><div class="line">    version=,</div><div class="line">    description=( <span class="string">''</span> ),</div><div class="line">    long_description=<span class="built_in">open</span>(<span class="string">'README.rst'</span>).<span class="built_in">read</span>(),</div><div class="line">    author=<span class="string">''</span>,</div><div class="line">    author_email=<span class="string">''</span>,</div><div class="line">    maintainer=<span class="string">''</span>,</div><div class="line">    maintainer_email=<span class="string">''</span>,</div><div class="line">    license=<span class="string">'BSD License'</span>,</div><div class="line">    packages=find_packages(),</div><div class="line">    platforms=[<span class="string">"all"</span>],</div><div class="line">    url=<span class="string">''</span>,</div><div class="line">    classifiers=[ <span class="string">'Development Status :: 4 - Beta'</span>, <span class="string">'Operating System :: OS Independent'</span>, <span class="string">'Intended Audience :: Developers'</span>, <span class="string">'License :: OSI Approved :: BSD License'</span>, <span class="string">'Programming Language :: Python'</span>, <span class="string">'Programming Language :: Python :: Implementation'</span>, <span class="string">'Programming Language :: Python :: 2'</span>, <span class="string">'Programming Language :: Python :: 2.7'</span>, <span class="string">'Programming Language :: Python :: 3'</span>, <span class="string">'Programming Language :: Python :: 3.4'</span>, <span class="string">'Programming Language :: Python :: 3.5'</span>, <span class="string">'Programming Language :: Python :: 3.6'</span>, <span class="string">'Topic :: Software Development :: Libraries'</span> ],</div><div class="line">)</div></pre></td></tr></table></figure>
<p>需要注意的上面的字段：</p>
<ul>
<li><strong>version</strong> - 这个简单，就是包的发布的版本，可以直接写在这，也可以从其他地方引用过来。</li>
<li><strong>long_description</strong> - 必须是rst（reStructuredText )格式的，因为这个里面的内容是显示在pypi包首页上，具体rst的语法可以参考：<a href="http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html" target="_blank" rel="external">http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html</a></li>
</ul>
<p>　　　我的long_description是同目录下的README.rst的内容，同时这个README也是我的github项目首页。</p>
<ul>
<li><strong>packages</strong> - 申明你的包里面要包含的目录，比如  [‘mypackage’, ‘mypackage_test’]  可以是这种使用我的示例，让setuptools自动决定要包含哪些包</li>
<li><strong>install_requires</strong> - 申明依赖包，安装包时pip会自动安装：格式如下（我上面的setup.py没有这个参数，因为我不依赖第三方包:)）：</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">install_requires</span>=[ <span class="string">'Twisted&gt;=13.1.0'</span>, <span class="string">'w3lib&gt;=1.17.0'</span>, <span class="string">'queuelib'</span>, <span class="string">'lxml'</span>, <span class="string">'pyOpenSSL'</span>, <span class="string">'cssselect&gt;=0.9'</span>, <span class="string">'six&gt;=1.5.2'</span>, <span class="string">'parsel&gt;=1.1'</span>, <span class="string">'PyDispatcher&gt;=2.0.5'</span>, <span class="string">'service_identity'</span>,]</div></pre></td></tr></table></figure>
<h3 id="准备requirements-txt-和-test-requirements-txt，这个申明包的依赖包和跑自动化测试的测试依赖包，具体格式示例如下："><a href="#准备requirements-txt-和-test-requirements-txt，这个申明包的依赖包和跑自动化测试的测试依赖包，具体格式示例如下：" class="headerlink" title="准备requirements.txt 和 test-requirements.txt，这个申明包的依赖包和跑自动化测试的测试依赖包，具体格式示例如下："></a>准备requirements.txt 和 test-requirements.txt，这个申明包的依赖包和跑自动化测试的测试依赖包，具体格式示例如下：</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mock&gt;=<span class="number">2.0</span><span class="number">.0</span></div><div class="line">flake8&gt;=<span class="number">3.2</span><span class="number">.1</span> eventlet&gt;=<span class="number">0.19</span><span class="number">.0</span></div><div class="line">nose2&gt;=<span class="number">0.6</span><span class="number">.5</span> cov_core&gt;=<span class="number">1.15</span><span class="number">.0</span></div><div class="line">virtualenv&gt;=<span class="number">15.1</span><span class="number">.0</span></div></pre></td></tr></table></figure>
<p>以上是我的test-requirements.txt的内容，requirements.txt的格式个上面一样。</p>
<p><strong>准备这个两个文件不是必须的。</strong></p>
<p>但是，有了它们，用户可以自己手动安装依赖包</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`<span class="javascript">pip&lt;span&gt; <span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span>``<span class="javascript">install</span>` `<span class="javascript">-r requirements.txt</span>`</div></pre></td></tr></table></figure>
<p>有了它们，结合tox等工具，可以非常方便的加入自动化测试。　</p>
<h3 id="准备一个项目的README-rst文件-前面也提到了它的格式要求，第一次发包，可以直接copy别人的格式，这东西熟能生巧，多写就会了。"><a href="#准备一个项目的README-rst文件-前面也提到了它的格式要求，第一次发包，可以直接copy别人的格式，这东西熟能生巧，多写就会了。" class="headerlink" title="准备一个项目的README.rst文件,前面也提到了它的格式要求，第一次发包，可以直接copy别人的格式，这东西熟能生巧，多写就会了。"></a>准备一个项目的README.rst文件,前面也提到了它的格式要求，第一次发包，可以直接copy别人的格式，这东西熟能生巧，多写就会了。</h3><p>README的截图就不放了，以免广告嫌疑。有兴趣可以到参考<a href="http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html" target="_blank" rel="external">http://rest-sphinx-memo.readthedocs.io/en/latest/ReST.html</a></p>
<h3 id="准备好上面的步骤，一个包就基本完整了，剩下的就是打包了-cd到包的根目录-："><a href="#准备好上面的步骤，一个包就基本完整了，剩下的就是打包了-cd到包的根目录-：" class="headerlink" title="准备好上面的步骤，一个包就基本完整了，剩下的就是打包了(cd到包的根目录)："></a>准备好上面的步骤，一个包就基本完整了，剩下的就是打包了(cd到包的根目录)：</h3><p>可以使用下面命令打包一个源代码的包:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> sdist build</div></pre></td></tr></table></figure>
<p>这样在当前目录的dist文件夹下，就会多出一个以tar.gz结尾的包了：</p>
<p>也可以打包一个wheels格式的包，使用下面的命令搞定：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> bdist_wheel --universal</div></pre></td></tr></table></figure>
<p>这样会在dist文件夹下生成一个whl文件，</p>
<h3 id="上传生成的包，可以使用setuptools-或者twine上传-推荐使用twine上次，因为使用setuptools上传时，你的用户名和密码是明文或者未加密传输，安全起见还是使用twine吧"><a href="#上传生成的包，可以使用setuptools-或者twine上传-推荐使用twine上次，因为使用setuptools上传时，你的用户名和密码是明文或者未加密传输，安全起见还是使用twine吧" class="headerlink" title="上传生成的包，可以使用setuptools,或者twine上传,推荐使用twine上次，因为使用setuptools上传时，你的用户名和密码是明文或者未加密传输，安全起见还是使用twine吧"></a>上传生成的包，可以使用setuptools,或者twine上传,推荐使用twine上次，因为使用setuptools上传时，你的用户名和密码是明文或者未加密传输，安全起见还是使用twine吧</h3><h1 id="上传source-包"><a href="#上传source-包" class="headerlink" title="上传source 包"></a>上传source 包</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> sdist upload</div></pre></td></tr></table></figure>
<h1 id="上传pre-compiled包"><a href="#上传pre-compiled包" class="headerlink" title="上传pre-compiled包"></a>上传pre-compiled包</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> bdist_wheel upload</div></pre></td></tr></table></figure>
<p>使用twine上传,先安装twine</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo pip <span class="keyword">install</span> twine</div><div class="line"></div><div class="line">twine upload dist/*</div></pre></td></tr></table></figure>
<p>上次前都会提示你前面注册的用户名和密码。一切搞定，你的包现在可以通过pip在任何地方安装了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python编程的都知道，Python的包安装非常的方便，一般都是可以&lt;strong&gt;pip&lt;/strong&gt;来安装搞定：&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;d
    
    </summary>
    
      <category term="python" scheme="http://fushenghua.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>配置ART</title>
    <link href="http://fushenghua.github.io/archives/59f7e7f7.html"/>
    <id>http://fushenghua.github.io/archives/59f7e7f7.html</id>
    <published>2018-04-02T00:55:29.000Z</published>
    <updated>2018-06-05T01:54:59.292Z</updated>
    
    <content type="html"><![CDATA[<p>本页面介绍了如何配置 ART 及其编译选项。讨论的主题包括：系统映像预编译配置、dex2oat 编译选项，以及如何在系统分区空间、数据分区空间和性能这三者之间取得平衡。</p>
<p>请参阅 <a href="https://source.android.google.cn/devices/tech/dalvik/index.html" target="_blank" rel="external">ART 和 Dalvik</a>、<a href="https://source.android.google.cn/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">Dalvik 可执行文件格式</a>，以及 source.android.com 上的其他页面，了解如何使用 ART。请参阅<a href="http://developer.android.google.cn/guide/practices/verifying-apps-art.html" target="_blank" rel="external">在 Android Runtime (ART) 上验证应用行为</a>，了解如何确保您的应用能够正常运行。</p>
<h2 id="ART-的运作方式"><a href="#ART-的运作方式" class="headerlink" title="ART 的运作方式"></a><a href="https://source.android.google.cn/devices/tech/dalvik/configure#top_of_page" target="_blank" rel="external"></a>ART 的运作方式</h2><p>ART 使用预先 (AOT) 编译，并且从 Android 7.0（代号 Nougat，简称 N）开始结合使用 AOT、即时 (JIT) 编译和配置文件引导型编译。所有这些编译模式的组合均可配置，我们将在本部分中对此进行介绍。例如，Pixel 设备配置了以下编译流程：</p>
<ol>
<li>最初安装应用时不进行任何 AOT 编译。应用前几次运行时，系统会对其进行解译，并对经常执行的方法进行 JIT 编译。</li>
<li>当设备闲置和充电时，编译守护进程会运行，以便根据在应用前几次运行期间生成的配置文件对常用代码进行 AOT 编译。</li>
<li>下一次重新启动应用时将会使用配置文件引导型代码，并避免在运行时对已经过编译的方法进行 JIT 编译。在应用后续运行期间进行了 JIT 编译的方法将会被添加到配置文件中，然后编译守护进程将会对这些方法进行 AOT 编译。</li>
</ol>
<p>ART 包括一个编译器（<code>dex2oat</code> 工具）和一个为启动 Zygote 而加载的运行时 (<code>libart.so</code>)。<code>dex2oat</code> 工具接受一个 APK 文件，并生成一个或多个编译工件文件，然后运行时将会加载这些文件。文件的个数、扩展名和名称会因版本而异，但在 Android O 版本中，将会生成以下文件：</p>
<ul>
<li><code>.vdex</code>：其中包含 APK 的未压缩 DEX 代码，另外还有一些旨在加快验证速度的元数据。</li>
<li><code>.odex</code>：其中包含 APK 中已经过 AOT 编译的方法代码。</li>
<li><code>.art (optional)</code>：其中包含 APK 中列出的某些字符串和类的 ART 内部表示，用于加快应用启动速度。</li>
</ul>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a><a href="https://source.android.google.cn/devices/tech/dalvik/configure#top_of_page" target="_blank" rel="external"></a>编译选项</h2><p>ART 的编译选项分为以下两个类别：</p>
<ol>
<li>系统 ROM 配置：编译系统映像时，会对哪些代码进行 AOT 编译。</li>
<li>运行时配置：ART 如何在设备上编译和运行应用。</li>
</ol>
<p>用于配置这两个类别的一个核心 ART 选项是“编译过滤器”。编译过滤器可控制 ART 如何编译 DEX 代码，是一个传递给 <code>dex2oat</code> 工具的选项。从 Android O 开始，有四个官方支持的过滤器：</p>
<ul>
<li>verify：只运行 DEX 代码验证。</li>
<li>quicken：运行 DEX 代码验证，并优化一些 DEX 指令，以获得更好的解译器性能。</li>
<li>speed：运行 DEX 代码验证，并对所有方法进行 AOT 编译。</li>
<li>speed-profile：运行 DEX 代码验证，并对配置文件中列出的方法进行 AOT 编译。</li>
</ul>
<h3 id="系统-ROM-配置"><a href="#系统-ROM-配置" class="headerlink" title="系统 ROM 配置"></a>系统 ROM 配置</h3><p>有一些 ART 编译选项可用于配置系统 ROM。如何配置这些选项取决于 <code>/system</code> 的可用存储空间以及预先安装的应用数量。编译到系统 ROM 中的 JAR/APK 可以分为以下四个类别：</p>
<ul>
<li>启动类路径代码：默认使用 speed 编译过滤器进行编译。</li>
<li>系统服务器代码：默认使用 speed 编译过滤器进行编译。</li>
<li>产品专属的核心应用：默认使用 speed 编译过滤器进行编译。</li>
<li>所有其他应用：默认使用 quicken 编译过滤器进行编译。</li>
</ul>
<h4 id="Makefile-选项"><a href="#Makefile-选项" class="headerlink" title="Makefile 选项"></a>Makefile 选项</h4><ul>
<li><code>WITH_DEXPREOPT</code></li>
</ul>
<p>是否对系统映像上安装的 DEX 代码调用 <code>dex2oat</code>。默认处于启用状态。</p>
<ul>
<li><code>DONT_DEXPREOPT_PREBUILTS</code>（从 Android 5.0 开始）</li>
</ul>
<p>启用 <code>DONT_DEXPREOPT_PREBUILTS</code> 可防止对预编译的应用进行预先优化。这些都是在 <code>Android.mk</code> 中指定了 <code>include $(BUILD_PREBUILT)</code> 的应用，例如 Gmail。不对这些很可能要通过 Google Play 进行更新的预编译应用进行预先优化可以节省 <code>/system</code> 的空间，但是会增加首次启动时间。</p>
<ul>
<li><code>WITH_DEXPREOPT_BOOT_IMG_AND_SYSTEM_SERVER_ONLY</code>（Android O MR1 中的新增选项）</li>
</ul>
<p>如果启用 <code>WITH_DEXPREOPT_BOOT_IMG_AND_SYSTEM_SERVER_ONLY</code>，将只会对启动类路径和系统服务器 JAR 进行预先优化。</p>
<ul>
<li><code>LOCAL_DEX_PREOPT</code></li>
</ul>
<p>通过在模块定义中指定 <code>LOCAL_DEX_PREOPT</code> 选项，还可以针对个别应用启用或停用预先优化功能。这有助于避免对那些可能会立即收到 Google Play 更新的应用进行预先优化，因为更新之后，对系统映像中的代码所做的预先优化都成了无用功。此外，这还有助于在进行重大版本 OTA 升级时节省空间，因为用户的数据分区中可能已经有了更高版本的应用。</p>
<p><code>LOCAL_DEX_PREOPT</code> 支持分别使用值“true”和“false”来启用和停用预先优化功能。此外，如果在预先优化过程中不应将 <code>classes.dex</code> 文件从 APK 或 JAR 文件中剥离出来，则可以指定“nostripping”。通常情况下，该文件会被剥离出来，因为在进行预先优化之后将不再需要该文件；但若要使第三方 APK 签名仍保持有效，则必须使用最后这个选项。</p>
<ul>
<li><code>PRODUCT_DEX_PREOPT_BOOT_FLAGS</code></li>
</ul>
<p>将选项传递给 <code>dex2oat</code> 以控制如何编译启动映像。该选项可用于指定自定义映像类列表、已编译类列表，以及编译过滤器。</p>
<ul>
<li><code>PRODUCT_DEX_PREOPT_DEFAULT_FLAGS</code></li>
</ul>
<p>将选项传递给 <code>dex2oat</code> 以控制如何编译除启动映像之外的所有内容。</p>
<ul>
<li><code>PRODUCT_DEX_PREOPT_MODULE_CONFIGS</code></li>
</ul>
<p>用于为特定模块和产品配置传递 <code>dex2oat</code> 选项。可以在产品的 <code>device.mk</code> 文件中通过 <code>$(call add-product-dex-preopt-module-config,&lt;modules&gt;,&lt;option&gt;)</code> 设置该选项，其中 <code>&lt;modules&gt;</code> 是一个列表，用于列出 JAR 和 APK 文件各自的 LOCAL_MODULE 和 LOCAL_PACKAGE 名称。</p>
<ul>
<li><code>PRODUCT_DEXPREOPT_SPEED_APPS (New in Android O)</code></li>
</ul>
<p>一个应用列表，用于列出哪些应用已被确定为产品的核心应用并且应使用 speed 编译过滤器对其进行编译。例如，常驻应用（如 SystemUI）只有在下次系统重新启动时才有机会使用配置文件引导型编译，因此对于产品来说，让这些应用始终采用 AOT 编译可能会更好。</p>
<ul>
<li><code>PRODUCT_SYSTEM_SERVER_APPS (New in Android O)</code></li>
</ul>
<p>系统服务器加载的应用的列表。这些应用将默认使用 speed 编译过滤器进行编译。</p>
<ul>
<li><code>PRODUCT_ART_TARGET_INCLUDE_DEBUG_BUILD(Post Android O)</code></li>
</ul>
<p>是否在设备上包含 ART 的调试版本。默认情况下，系统会针对 userdebug 和 eng 细分版本启用该选项。可以通过将该选项明确设为“true”或“false”来覆盖此行为。</p>
<p>默认情况下，设备将使用非调试版本 (<em>libart.so</em>)。要进行切换，请将系统属性 <code>persist.sys.dalvik.vm.lib.2</code> 设为 libartd.so。</p>
<ul>
<li><code>WITH_DEXPREOPT_PIC (Removed in Android O)</code></li>
</ul>
<p>从 Android 5.1.0 到 Android 6.0.1 的所有版本中，都可以指定 <code>WITH_DEXPREOPT_PIC</code> 来启用位置无关代码 (PIC)。这样一来，就不必将来自映像的编译代码从 /system 迁移到 /data/dalvik-cache，因此可以节省数据分区中的空间。不过，因为该选项会停用根据位置相关代码进行的优化，所以会对运行时产生轻微的影响。通常情况下，需要节省 /data 空间的设备应启用 PIC 编译。</p>
<p>在 Android 7.0 中，PIC 编译默认处于启用状态。</p>
<ul>
<li><code>WITH_DEXPREOPT_BOOT_IMG_ONLY</code>（已在 Android O MR1 中移除）</li>
</ul>
<p>此选项已被 WITH_DEXPREOPT_BOOT_IMG_AND_SYSTEM_SERVER_ONLY 取代，后者还会预先优化系统服务器 JAR。</p>
<h4 id="启动类路径配置"><a href="#启动类路径配置" class="headerlink" title="启动类路径配置"></a>启动类路径配置</h4><ul>
<li>预加载类列表</li>
</ul>
<p>预加载类列表列出了 zygote 将在启动时初始化的类。利用该列表，每个应用无需单独运行这些类初始化程序，从而可以更快地启动并共享内存中的页面。预加载类列表文件默认位于 frameworks/base/preloaded-classes 中，其中包含一个针对典型手机使用场景优化的列表。其他设备（如穿戴式设备）可能不适合使用此列表，而应进行相应调整。做调整时应格外小心，因为添加太多的类会造成加载未用到的类而浪费内存；而添加的类太少又会导致每个应用都各有一份副本，同样会造成内存浪费。</p>
<p>使用示例（在产品的 device.mk 中）：</p>
<p>PRODUCT_COPY_FILES += :system/etc/preloaded-classes</p>
<p><strong>注意</strong>：如果有任何从 <code>build/target/product/base.mk</code> 提取默认值的产品配置 Makefile，此行必须放在沿用此类 Makefile 的行之前。</p>
<ul>
<li>映像类列表</li>
</ul>
<p>映像类列表列出了 dex2oat 预先初始化并存储在 boot.art 文件中的类。利用该列表，zygote 可以在启动时从 boot.art 文件中加载这些结果，而无需在预加载期间自行运行这些类的初始化程序。这种做法的一个重要特点是，从映像加载并在进程之间共享的页面是干净的，因此可在内存不足的情况下轻松将它们交换出去。在 L 版本中，默认情况下，映像类列表和预加载类列表是同一个列表。从 L 之后的 AOSP 版本开始，可使用以下选项指定自定义映像类列表：</p>
<p>PRODUCT_DEX_PREOPT_BOOT_FLAGS</p>
<p>使用示例（在产品的 <code>device.mk</code> 中）：</p>
<p>PRODUCT_DEX_PREOPT_BOOT_FLAGS += –image-classes=</p>
<ul>
<li>已编译类列表</li>
</ul>
<p>在 L 之后的 AOSP 版本中，可使用此列表来指定一个启动类路径的类子集，以便在预先优化期间编译这些类。如果设备存储空间非常紧张，无法完整容纳经过预先优化的启动映像，此选项就很有帮助。不过请注意，此列表未指定的类将不会被编译（即使在设备上也不会被编译），而必须对其进行解译，这可能会影响运行时性能。默认情况下，dex2oat 会在 $OUT/system/etc/compiled-classes 中查找已编译类列表，因此，可以通过 device.mk 将自定义类列表复制到该位置。也可使用以下选项指定文件位置：</p>
<p>PRODUCT_DEX_PREOPT_BOOT_FLAGS</p>
<p>使用示例（在产品的 <code>device.mk</code> 中）：</p>
<p>PRODUCT_COPY_FILES += :system/etc/compiled-classes</p>
<p><strong>注意</strong>：如果有任何从 <code>build/target/product/base.mk</code> 提取默认值的产品配置 Makefile，此行必须放在沿用此类 Makefile 的行之前。</p>
<h3 id="运行时配置"><a href="#运行时配置" class="headerlink" title="运行时配置"></a>运行时配置</h3><h4 id="Jit-选项"><a href="#Jit-选项" class="headerlink" title="Jit 选项"></a>Jit 选项</h4><p>仅在 ART JIT 编译器可用的情况下，以下选项才会影响 Android 版本。</p>
<ul>
<li>dalvik.vm.usejit：是否启用 JIT。</li>
<li>dalvik.vm.jitinitialsize（默认为 64K）：代码缓存初始容量。代码缓存将定期进行垃圾回收 (GC)，并将视需要增加容量。</li>
<li>dalvik.vm.jitmaxsize（默认为 64M）：代码缓存最大容量。</li>
<li>dalvik.vm.jitthreshold（默认为 10000）：方法的“热度”计数器必须超过该阈值，系统才会对方法进行 JIT 编译。“热度”计数器是运行时的内部指标。它的影响因素包括调用次数、后向分支及其他因素。</li>
<li>dalvik.vm.usejitprofiles：是否启用 JIT 配置文件；即使 dalvik.vm.usejit 为 false，也可以使用该选项。请注意，如果该选项为 false，编译过滤器 speed-profile 将不会对任何方法进行 AOT 编译，效果与 quicken 相同。</li>
<li>dalvik.vm.jitprithreadweight（默认为 dalvik.vm.jitthreshold/20）：应用界面线程的 JIT“样本”（请参阅 jitthreshold）的权重。用于加快以下方法的编译速度：当用户与应用交互时，会直接影响用户体验的方法。</li>
<li>dalvik.vm.jittransitionweight（默认为 dalvik.vm.jitthreshold/10）：调用时需要在编译代码和解译器之间进行转换的方法的权重。这有助于确保对所涉及的方法进行编译以尽可能减少转换（转换需要很大开销）。</li>
</ul>
<h4 id="软件包管理器选项"><a href="#软件包管理器选项" class="headerlink" title="软件包管理器选项"></a>软件包管理器选项</h4><p>从 Android 7.0 开始，系统提供了一种通用方式来指定各个阶段的编译/验证级别。编译级别通过系统属性来配置，默认值如下：</p>
<ul>
<li>pm.dexopt.install=quicken</li>
</ul>
<p>这是通过 Google Play 安装应用时使用的编译过滤器。要加快安装速度，可以尝试使用 quicken 编译过滤器。</p>
<ul>
<li>pm.dexopt.bg-dexopt=speed-profile</li>
</ul>
<p>这是在设备闲置、充电以及充满电时使用的编译过滤器。要充分利用配置文件引导型编译并节省存储空间，可以尝试使用 <em>speed-profile</em> 编译过滤器。</p>
<ul>
<li>pm.dexopt.boot=verify</li>
</ul>
<p>OTA 更新后使用的编译过滤器。对于该选项，我们<strong>强烈</strong>建议使用 verify 编译过滤器，以免启动时间过长。</p>
<ul>
<li>pm.dexopt.first-boot=quicken</li>
<li>在设备初次启动时使用的编译过滤器。此过滤器只会影响出厂后第一次启动的时间。我们建议使用 quicken 过滤器，以免用户在首次使用手机时需要花很长时间等待手机启动。请注意，如果 <code>/system</code> 中的所有应用都已使用 quicken 编译过滤器进行编译，或者已使用 speed 或 speed-profile 编译过滤器进行编译，<code>pm.dexopt.first-boot</code> 将不会产生任何影响。</li>
</ul>
<h4 id="Dex2oat-选项"><a href="#Dex2oat-选项" class="headerlink" title="Dex2oat 选项"></a>Dex2oat 选项</h4><p>请注意，这些选项在设备编译期间以及预先优化期间都会影响 <code>dex2oat</code>，但是前面讨论的大多数选项都只会影响预先优化。</p>
<p>在 <code>dex2oat</code> 编译启动映像时对其进行控制：</p>
<ul>
<li>dalvik.vm.image-dex2oat-Xms：初始堆大小</li>
<li>dalvik.vm.image-dex2oat-Xmx：最大堆大小</li>
<li>dalvik.vm.image-dex2oat-filter：编译过滤器选项</li>
<li>dalvik.vm.image-dex2oat-threads：要使用的线程数</li>
</ul>
<p>在 <code>dex2oat</code> 编译除启动映像之外的所有内容时对其进行控制：</p>
<ul>
<li>dalvik.vm.dex2oat-Xms：初始堆大小</li>
<li>dalvik.vm.dex2oat-Xmx：最大堆大小</li>
<li>dalvik.vm.dex2oat-filter：编译过滤器选项</li>
</ul>
<p>Android 6.0 之前的版本提供了一个适用于编译除启动映像之外的所有内容的附加选项：</p>
<ul>
<li>dalvik.vm.dex2oat-threads：要使用的线程数</li>
</ul>
<p>自 Android 6.1 起，该选项变成了两个适用于编译除启动映像之外的所有内容的附加选项：</p>
<ul>
<li>dalvik.vm.boot-dex2oat-threads：启动时要使用的线程数</li>
<li>dalvik.vm.dex2oat-threads：启动后要使用的线程数</li>
</ul>
<p>Android 7.1 及之后的版本提供了两个选项来控制编译除启动映像之外的所有内容时的内存使用方式：</p>
<ul>
<li>dalvik.vm.dex2oat-very-large：停用 AOT 编译的最小总 dex 文件大小（以字节为单位）</li>
<li>dalvik.vm.dex2oat-swap：使用 dex2oat 交换文件（用于内存较小的设备）</li>
</ul>
<p>不应减小用于控制 <code>dex2oat</code> 初始堆大小和最大堆大小的选项数值，因为它们可能会限制可对哪些应用进行编译。</p>
<h2 id="A-B-专有配置"><a href="#A-B-专有配置" class="headerlink" title="A/B 专有配置"></a><a href="https://source.android.google.cn/devices/tech/dalvik/configure#top_of_page" target="_blank" rel="external"></a>A/B 专有配置</h2><h3 id="ROM-配置"><a href="#ROM-配置" class="headerlink" title="ROM 配置"></a>ROM 配置</h3><p>从 Android 7.0 开始，设备可以使用两个系统分区来实现 <a href="https://source.android.google.cn/devices/tech/ota/ab_updates.html" target="_blank" rel="external">A/B 系统更新</a>。为了减小系统分区大小，可以将经过预先优化的文件安装在未使用的第二个系统分区中。在系统首次启动时，这些文件会被复制到数据分区。</p>
<p>使用示例（在 <code>device-common.mk</code> 中）：</p>
<p>PRODUCT_PACKAGES += \<br>     cppreopts.sh<br>PRODUCT_PROPERTY_OVERRIDES += \<br>     ro.cp_system_other_odex=1</p>
<p>在设备的 <code>BoardConfig.mk</code> 中：</p>
<p>BOARD_USES_SYSTEM_OTHER_ODEX := true</p>
<p>请注意，启动类路径代码、系统服务器代码以及产品专属的核心应用始终会被编译到系统分区中。默认情况下，所有其他应用都会被编译到未使用的第二个系统分区中。可以使用 <code>SYSTEM_OTHER_ODEX_FILTER</code> 控制此行为，其值默认为：</p>
<p>SYSTEM_OTHER_ODEX_FILTER ?= app/% priv-app/%</p>
<h3 id="后台-dexopt-OTA"><a href="#后台-dexopt-OTA" class="headerlink" title="后台 dexopt OTA"></a>后台 dexopt OTA</h3><p>在启用了 A/B 的设备上，可以在后台对应用进行编译，以更新到新的系统映像。如需在系统映像中选择性地加入编译脚本和二进制文件，请参阅<a href="https://source.android.google.cn/devices/tech/ota/ab_updates.html#compilation" target="_blank" rel="external">在后台编译应用</a>。可通过以下选项控制用于此类编译的编译过滤器：</p>
<p>pm.dexopt.ab-ota=speed-profile</p>
<p>我们建议使用 speed-profile，以利用配置文件引导型编译并节省存储空间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本页面介绍了如何配置 ART 及其编译选项。讨论的主题包括：系统映像预编译配置、dex2oat 编译选项，以及如何在系统分区空间、数据分区空间和性能这三者之间取得平衡。&lt;/p&gt;
&lt;p&gt;请参阅 &lt;a href=&quot;https://source.android.google.cn
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>INSTALL_FAILED_TEST_ONLY的原因</title>
    <link href="http://fushenghua.github.io/archives/af68deab.html"/>
    <id>http://fushenghua.github.io/archives/af68deab.html</id>
    <published>2018-04-02T00:55:29.000Z</published>
    <updated>2018-05-28T09:24:12.812Z</updated>
    
    <content type="html"><![CDATA[<p>有一天给测试同学打了个deubg 包发现无法安装，提示无法解析，使用adb install 安装后提示<code>INSTALL_FAILED_TEST_ONLY</code>，原来是<code>Android Studio 3.0</code>会在debug apk的<code>manifest</code>文件<code>application</code>标签里自动添加 <code>android:testOnly=&quot;true&quot;</code>属性</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在Android Studio进行开发的时候，生成的debug apk手动使用adb install无法安装，提示错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  apk adb <span class="keyword">install</span> <span class="string">'/home/silver/桌面/share/apk/app-android-debug.apk'</span> </div><div class="line">adb <span class="keyword">server</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> date.  killing...</div><div class="line">* daemon started successfully *</div><div class="line"><span class="number">5347</span> KB/s (<span class="number">8754206</span> <span class="keyword">bytes</span> <span class="keyword">in</span> <span class="number">1.598</span>s)</div><div class="line">	pkg: /<span class="keyword">data</span>/<span class="keyword">local</span>/tmp/app-android-debug.apk</div><div class="line"><span class="keyword">Failure</span> [INSTALL_FAILED_TEST_ONLY]</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>但是使用Android Studio开发过程中发现可以直接安装成功。经过查询资料发现在<code>AndroidManifest.xml</code>文件中添加了属性<code>testOnly=true</code>， </p>
<p><a href="https://developer.android.com/guide/topics/manifest/application-element" target="_blank" rel="external">https://developer.android.com/guide/topics/manifest/application-element</a></p>
<p><img src="http://7xrk8u.com1.z0.glb.clouddn.com/15263540381830.jpg" alt=""></p>
<p>反编译当前apk发现的确清单文件中的确新加了这个属性，研究发现原来是<code>Android Studio 3.0</code>会在debug apk的<code>manifest</code>文件<code>application</code>标签里自动添加 <code>android:testOnly=&quot;true&quot;</code>属性，导致IDE中run跑出的apk在大部分手机上只能用adb install -t <apk>来安装。</apk></p>
<h3 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h3><p>在项目中的<code>gradle.properties</code>全局配置中设置：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android<span class="selector-class">.injected</span><span class="selector-class">.testOnly</span>=false</div></pre></td></tr></table></figure>
<h3 id="解决方法二，加-t-："><a href="#解决方法二，加-t-：" class="headerlink" title="解决方法二，加 -t ：　　"></a>解决方法二，加 -t ：　　</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb <span class="keyword">install </span>-t app-<span class="built_in">debug</span>.apk</div></pre></td></tr></table></figure>
<p><img src="http://7xrk8u.com1.z0.glb.clouddn.com/15263543802023.jpg" alt=""></p>
<p>通过方法一设置后，反编译就没有属性<code>testOnly=true</code>了。</p>
<hr>
<p>title: INSTALL_FAILED_TEST_ONLY的原因<br>categories: android<br>comments: true</p>
<h2 id="date-2018-04-02-08-55-29"><a href="#date-2018-04-02-08-55-29" class="headerlink" title="date: 2018-04-02 08:55:29"></a>date: 2018-04-02 08:55:29</h2><p>有一天给测试同学打了个deubg 包发现无法安装，提示无法解析，使用adb install 安装后提示<code>INSTALL_FAILED_TEST_ONLY</code>，原来是<code>Android Studio 3.0</code>会在debug apk的<code>manifest</code>文件<code>application</code>标签里自动添加 <code>android:testOnly=&quot;true&quot;</code>属性。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>在Android Studio进行开发的时候，生成的debug apk手动使用adb install无法安装，提示错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  apk adb <span class="keyword">install</span> <span class="string">'/home/silver/桌面/share/apk/app-android-debug.apk'</span> </div><div class="line">adb <span class="keyword">server</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> date.  killing...</div><div class="line">* daemon started successfully *</div><div class="line"><span class="number">5347</span> KB/s (<span class="number">8754206</span> <span class="keyword">bytes</span> <span class="keyword">in</span> <span class="number">1.598</span>s)</div><div class="line">	pkg: /<span class="keyword">data</span>/<span class="keyword">local</span>/tmp/app-android-debug.apk</div><div class="line"><span class="keyword">Failure</span> [INSTALL_FAILED_TEST_ONLY]</div></pre></td></tr></table></figure>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>但是使用Android Studio开发过程中发现可以直接安装成功。经过查询资料发现在<code>AndroidManifest.xml</code>文件中添加了属性<code>testOnly=true</code>， </p>
<p><a href="https://developer.android.com/guide/topics/manifest/application-element" target="_blank" rel="external">https://developer.android.com/guide/topics/manifest/application-element</a></p>
<p><img src="http://7xrk8u.com1.z0.glb.clouddn.com/15263540381830.jpg" alt=""></p>
<p>反编译当前apk发现的确清单文件中的确新加了这个属性，研究发现原来是<code>Android Studio 3.0</code>会在debug apk的<code>manifest</code>文件<code>application</code>标签里自动添加 <code>android:testOnly=&quot;true&quot;</code>属性，导致IDE中run跑出的apk在大部分手机上只能用adb install -t <apk>来安装。</apk></p>
<h3 id="解决方法一-1"><a href="#解决方法一-1" class="headerlink" title="解决方法一"></a>解决方法一</h3><p>在项目中的<code>gradle.properties</code>全局配置中设置：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android<span class="selector-class">.injected</span><span class="selector-class">.testOnly</span>=false</div></pre></td></tr></table></figure>
<h3 id="解决方法二，加-t-：-1"><a href="#解决方法二，加-t-：-1" class="headerlink" title="解决方法二，加 -t ：　　"></a>解决方法二，加 -t ：　　</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb <span class="keyword">install </span>-t app-<span class="built_in">debug</span>.apk</div></pre></td></tr></table></figure>
<p><img src="http://7xrk8u.com1.z0.glb.clouddn.com/15263543802023.jpg" alt=""></p>
<p>通过方法一设置后，反编译就没有属性<code>testOnly=true</code>了。</p>
<blockquote>
<p>水平有限，若有错漏，欢迎指正，批评，如需转载，请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a>，谢谢！</p>
</blockquote>
<p><a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160608234402229" alt="这里写图片描述"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一天给测试同学打了个deubg 包发现无法安装，提示无法解析，使用adb install 安装后提示&lt;code&gt;INSTALL_FAILED_TEST_ONLY&lt;/code&gt;，原来是&lt;code&gt;Android Studio 3.0&lt;/code&gt;会在debug apk的&lt;c
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>实现 ART 即时 (JIT) 编译器</title>
    <link href="http://fushenghua.github.io/archives/3dbdbf17.html"/>
    <id>http://fushenghua.github.io/archives/3dbdbf17.html</id>
    <published>2018-04-02T00:55:29.000Z</published>
    <updated>2018-06-04T02:18:10.626Z</updated>
    
    <content type="html"><![CDATA[<p>Android 运行时 (ART) 包含一个具备代码分析功能的即时 (JIT) 编译器，该编译器可以在 Android 应用运行时持续提高其性能。JIT 编译器补充了 ART 当前的预先 (AOT) 编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速度。相较于 AOT 编译器，JIT 编译器的优势也更为明显，因为它不会在应用自动更新期间或重新编译应用（在无线下载 (OTA) 更新期间）时拖慢系统速度。</p>
<p>尽管 JIT 和 AOT 使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT 会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 (OSR) 编译成为可能，而这一切都会使其生成的代码略有不同。</p>
<h2 id="JIT-架构"><a href="#JIT-架构" class="headerlink" title="JIT 架构"></a>JIT 架构</h2><p><img src="/images/jit-arch.png" alt="JIT 架构"></p>
<p><strong>图 1.</strong> JIT 架构。</p>
<h2 id="JIT-编译"><a href="#JIT-编译" class="headerlink" title="JIT 编译"></a>JIT 编译</h2><p>JIT 编译涉及以下活动：</p>
<p><img src="/images/jit-profile-comp.png" alt="配置文件引导的编译"></p>
<p><strong>图 2.</strong> 配置文件引导的编译。</p>
<ol>
<li><p>用户运行应用，而这随后就会触发 ART 加载 <code>.dex</code> 文件。</p>
<ul>
<li>如果有 <code>.oat</code> 文件（即 <code>.dex</code> 文件的 AOT 二进制文件），则 ART 会直接使用该文件。虽然 <code>.oat</code> 文件会定期生成，但文件中不一定会包含经过编译的代码（即 AOT 二进制文件）。</li>
<li><p>如果没有 <code>.oat</code> 文件，则 ART 会通过 JIT 或解释器执行 <code>.dex</code> 文件。</p>
<p><code>.oat</code></p>
<p><code>.dex</code></p>
</li>
</ul>
</li>
<li><p>针对任何未根据 <code>speed</code> 编译过滤器编译的应用启用 JIT（也就是说，要尽可能多地编译应用中的代码）。</p>
</li>
<li>将 JIT 配置文件数据转存到只限应用访问的系统目录内的文件中。</li>
<li><p>AOT 编译 (<code>dex2oat</code>) 守护进程通过解析该文件来推进其编译。</p>
<p> <img src="/images/jit-daemon.png" alt="JIT 守护进程"></p>
<p> <strong>图 3.</strong> JIT 守护进程活动。</p>
</li>
</ol>
<p>举例来说，Google Play 服务就是一种由其他应用使用的类似于共享库的服务。</p>
<h2 id="JIT-工作流程"><a href="#JIT-工作流程" class="headerlink" title="JIT 工作流程"></a>JIT 工作流程</h2><p><img src="/images/jit-workflow.png" alt="JIT 架构"></p>
<p><strong>图 4.</strong> JIT 数据流。</p>
<ul>
<li>分析信息会存储在代码缓存中，并会在内存紧张时作为垃圾被回收。<ul>
<li>无法保证在应用处于后台运行状态时所捕获的快照能够包含完整的数据（即 JIT 编译的所有内容）。</li>
<li>该过程不会尝试确保记录所有内容（因为这将影响运行时性能）。</li>
</ul>
</li>
<li>方法可能有三种不同的状态：<ul>
<li>已经过解释（dex 代码）</li>
<li>已经过 JIT 编译</li>
<li>已经过 AOT 编译如果同时存在 JIT 和 AOT 代码（例如，由于反复进行逆优化），经过 JIT 编译的代码将是首选代码。</li>
</ul>
</li>
<li>在不影响前台应用性能的情况下运行 JIT 所需的内存取决于相关应用。大型应用比小型应用需要更多内存。一般来说，大型应用所需的内存稳定维持在 4 MB 左右。</li>
</ul>
<h2 id="开启-JIT-日志记录"><a href="#开启-JIT-日志记录" class="headerlink" title="开启 JIT 日志记录"></a>开启 JIT 日志记录</h2><p>要开启 JIT 日志记录，请运行以下命令：</p>
<p><code>adb root</code><br><code>adb shell stop</code><br><code>adb shell setprop dalvik.vm.extra-opts -verbose:jit</code><br><code>adb shell start</code></p>
<h2 id="停用-JIT"><a href="#停用-JIT" class="headerlink" title="停用 JIT"></a>停用 JIT</h2><p>要停用 JIT，请运行以下命令：</p>
<p><code>adb root</code><br><code>adb shell stop</code><br><code>adb shell setprop dalvik.vm.usejit false</code><br><code>adb shell start</code></p>
<h2 id="强制编译"><a href="#强制编译" class="headerlink" title="强制编译"></a>强制编译</h2><p>要强制编译，请运行以下命令：</p>
<p>adb shell cmd package compile</p>
<p>强制编译特定软件包的常见用例：</p>
<ul>
<li><p>基于配置文件：</p>
<p>  adb shell cmd package compile -m speed-profile -f my-package</p>
</li>
</ul>
<ul>
<li><p>全面：</p>
<p>  adb shell cmd package compile -m speed -f my-package</p>
</li>
</ul>
<p>强制编译所有软件包的常见用例：</p>
<ul>
<li><p>基于配置文件：</p>
<p>  adb shell cmd package compile -m speed-profile -f -a</p>
</li>
</ul>
<ul>
<li><p>全面：</p>
<p>  adb shell cmd package compile -m speed -f -a</p>
</li>
</ul>
<h2 id="清除配置文件数据"><a href="#清除配置文件数据" class="headerlink" title="清除配置文件数据"></a>清除配置文件数据</h2><p>要清除配置文件数据并移除经过编译的代码，请运行以下命令：</p>
<ul>
<li><p>针对一个软件包：</p>
<p>  adb shell cmd package compile –reset my-package</p>
</li>
</ul>
<ul>
<li><p>针对所有软件包：</p>
<p>  adb shell cmd package compile –reset -a</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 运行时 (ART) 包含一个具备代码分析功能的即时 (JIT) 编译器，该编译器可以在 Android 应用运行时持续提高其性能。JIT 编译器补充了 ART 当前的预先 (AOT) 编译器的功能，有助于提高运行时性能，节省存储空间，以及加快应用及系统更新速
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 8.0 中的 ART 功能改进</title>
    <link href="http://fushenghua.github.io/archives/3b12125.html"/>
    <id>http://fushenghua.github.io/archives/3b12125.html</id>
    <published>2018-04-02T00:55:29.000Z</published>
    <updated>2018-05-07T08:39:05.326Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 8.0 版本中，Android Runtime (ART) 有了极大改进。下面的列表总结了设备制造商可以在 ART 中获得的增强功能。</p>
<h2 id="并发压缩式垃圾回收器"><a href="#并发压缩式垃圾回收器" class="headerlink" title="并发压缩式垃圾回收器"></a>并发压缩式垃圾回收器</h2><p>正如 Google 在 Google I/O 大会上所宣布的那样，ART 在 Android 8.0 中提供了新的并发压缩式垃圾回收器 (GC)。该回收器会在每次执行 GC 时以及应用正在运行时对堆进行压缩，且仅在处理线程根时短暂停顿一次。该回收器具有以下优势：</p>
<ul>
<li>GC 始终会对堆进行压缩：堆的大小平均比 Android 7.0 中的小 32%。</li>
<li>得益于压缩，系统现可实现线程局部碰撞指针对象分配：分配速度比 Android 7.0 中的快 70%。</li>
<li>H2 基准的停顿次数比 Android 7.0 GC 的少 85%。</li>
<li>停顿次数不再随堆的大小而变化，应用在使用较大的堆时也无需担心造成卡顿。</li>
<li>GC 实现细节 - 读取屏障：<ul>
<li>读取屏障是在读取每个对象字段时所做的少量工作。</li>
<li>它们在编译器中经过了优化，但可能会减慢某些用例的速度。</li>
</ul>
</li>
</ul>
<h2 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h2><p>在 Android 8.0 版本中，ART 采取了多种循环优化措施，具体如下：</p>
<ul>
<li>消除边界检查<ul>
<li>静态：在编译时证明范围位于边界内</li>
<li>动态：运行时测试确保循环始终位于边界内（否则不进行优化）</li>
</ul>
</li>
<li>消除归纳变量<ul>
<li>移除无用归纳</li>
<li>用封闭式表达式替换仅在循环后使用的归纳</li>
</ul>
</li>
<li>消除循环主体内的无用代码，移除整个死循环</li>
<li>强度降低</li>
<li>循环转换：逆转、交换、拆分、展开、单模等</li>
<li>SIMDization（也称为矢量化）</li>
</ul>
<p>循环优化器位于 ART 编译器中一个独立的优化环节中。大多数循环优化与其他方面的优化和简化类似。由于大多数 CFG 实用工具（请参阅 nodes.h）侧重于编译而不是重写 CFG，因此通过更复杂（与平时相比）的方式进行一些重写 CFG 的优化时，会面临挑战。</p>
<h2 id="类层次结构分析"><a href="#类层次结构分析" class="headerlink" title="类层次结构分析"></a>类层次结构分析</h2><p>在 Android 8.0 中，ART 会使用类层次结构分析 (CHA)，这是一种编译器优化，可基于通过分析类层次结构所生成的信息，将虚拟调用去虚拟化为直接调用。虚拟调用代价高昂，因为它们围绕 vtable 查找来实现，且会占用几个依赖负载。另外，虚拟调用也不能内嵌。</p>
<p>以下是对相关增强功能的总结：</p>
<ul>
<li>动态单一实现方法状态更新 - 在类关联时间结束时，如果 vtable 已被填充，ART 会按条目对超类的 vtable 进行比较。</li>
<li>编译器优化 - 编译器会利用某种方法的单一实现信息。如果方法 A.foo 设置了单一实现标记，则编译器会将虚拟调用去虚拟化为直接调用，并借此进一步尝试内嵌直接调用。</li>
<li>已编译代码无效 - 另外，在类关联时间结束时，如果单一实现信息进行了更新，且方法 A.foo 之前拥有单一实现，但该状态现已变为无效，则依赖方法 A.foo 拥有单一实现这一假设的所有已编译代码都需要变为无效代码。</li>
<li>去优化 - 对于堆栈上已编译的有效代码，系统会启动去优化功能，以强制使已编译无效代码进入解释器模式，从而确保正确性。系统会采用结合了同步和异步去优化的全新去优化机制。</li>
</ul>
<h2 id="oat-文件中的内嵌缓存"><a href="#oat-文件中的内嵌缓存" class="headerlink" title=".oat 文件中的内嵌缓存"></a>.oat 文件中的内嵌缓存</h2><p>ART 现在采用内嵌缓存，并对有足够数据可用的调用站点进行优化。内嵌缓存功能会将额外的运行时信息记录到配置文件中，并利用这类信息将动态优化添加到预先编译中。</p>
<h2 id="Dexlayout"><a href="#Dexlayout" class="headerlink" title="Dexlayout"></a>Dexlayout</h2><p>Dexlayout 是在 Android 8.0 中引入的一个库，用于分析 dex 文件，并根据配置文件对其进行重新排序。Dexlayout 旨在使用运行时配置信息对 dex 文件的各个部分进行重新排序（在设备的空闲维护编译期间）。通过将经常一起访问的部分 dex 文件集中在一起，程序可以因改进文件位置而拥有更好的内存访问模式，从而节省 RAM 并缩短启动时间。</p>
<p>由于配置文件信息目前仅在运行应用后可用，因此系统会在空闲维护期间将 dexlayout 集成到 dex2oat 的设备编译中。</p>
<h2 id="Dex-缓存移除"><a href="#Dex-缓存移除" class="headerlink" title="Dex 缓存移除"></a>Dex 缓存移除</h2><p>在 Android 7.0 及更早版本中，DexCache 对象拥有四个大型数组，与 DexFile 中特定元素的数量成正比，即：</p>
<ul>
<li>字符串（每个 DexFile::StringId 一个引用），</li>
<li>类型（每个 DexFile::TypeId 一个引用），</li>
<li>方法（每个 DexFile::MethodId 一个原生指针），</li>
<li>字段（每个 DexFile::FieldId 一个原生指针）。</li>
</ul>
<p>这些数组用于快速检索我们以前解析的对象。在 Android 8.0 中，除方法数组外，所有数组都已移除。</p>
<h2 id="解释器性能"><a href="#解释器性能" class="headerlink" title="解释器性能"></a>解释器性能</h2><p>通过引入 Mterp（一种解释器，具有以汇编语言编写的核心提取/解码/解释机制），Android 7.0 版本中的解释器性能得以显著提升。Mterp 模仿了快速 Dalvik 解释器，并支持 arm、arm64、x86、x86_64、mips 和 mips64。对于计算代码而言，ART 的 Mterp 大致相当于 Dalvik 的快速解释器。不过，有时候，它的速度可能会显著变慢，甚至急剧变慢：</p>
<ol>
<li>调用性能。</li>
<li>字符串操作和 Dalvik 中其他被视为内嵌函数的高频用户方法。</li>
<li>堆栈内存使用量较高。</li>
</ol>
<p>Android 8.0 解决了这些问题。</p>
<h2 id="详细了解内嵌"><a href="#详细了解内嵌" class="headerlink" title="详细了解内嵌"></a>详细了解内嵌</h2><p>从 Android 6.0 开始，ART 可以内嵌同一个 dex 文件中的任何调用，但只能内嵌来自其他 dex 文件的叶方法。此项限制具有以下两个原因：</p>
<ol>
<li>从其他 dex 文件进行内嵌需要使用该 dex 文件的 dex 缓存，这与同一 dex 文件内嵌（只能重复使用调用程序的 dex 缓存）有所不同。已编译代码中需要具有 dex 缓存，以便执行一系列指令，例如静态调用、字符串加载或类加载。</li>
<li>堆栈映射只对当前 dex 文件中的方法索引进行编码。</li>
</ol>
<p>为了应对这些限制，Android 8.0 做出了以下改进：</p>
<ol>
<li>从已编译代码中移除 dex 缓存访问（另请参阅“Dex 缓存移除”部分）</li>
<li>扩展堆栈映射编码。</li>
</ol>
<h2 id="同步方面的改进"><a href="#同步方面的改进" class="headerlink" title="同步方面的改进"></a>同步方面的改进</h2><p>ART 团队调整了 MonitorEnter/MonitorExit 代码路径，并减少了我们对 ARMv8 上传统内存屏障的依赖，尽可能将其替换为较新的（获取/释放）指令。</p>
<h2 id="更快速的原生方法"><a href="#更快速的原生方法" class="headerlink" title="更快速的原生方法"></a>更快速的原生方法</h2><p>使用 <a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java" target="_blank" rel="external"><code>@FastNative</code></a> 和 <a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/CriticalNative.java" target="_blank" rel="external"><code>@CriticalNative</code></a> 注解可实现对 Java 原生接口 (JNI) 更快速的原生调用。这种内置的 ART 运行时优化加快了 JNI 转换，并取代了现在已弃用的 !<em>bang JNI 标记。</em>注解对非原生方法没有任何影响，并且仅适用于 <code>bootclasspath</code> 上的平台 Java 语言代码（无 Play 商店更新）。</p>
<p><code>@FastNative</code> 注解支持非静态方法。如果某种方法将 <code>jobject</code> 作为参数或返回值进行访问，请使用此注解。</p>
<p>利用 <code>@CriticalNative</code> 注解，可更快速地运行原生方法，但存在以下限制：</p>
<ul>
<li>方法必须是静态的 - 没有参数、返回值或隐式 <code>this</code> 的对象。</li>
<li>仅将基元类型传递给原生方法。</li>
<li>原生方法在其函数定义中不使用 <code>JNIEnv</code> 和 <code>jclass</code> 参数。</li>
<li>该方法必须是使用 <code>RegisterNatives</code> 注册的，而不是依靠动态 JNI 链接。</li>
</ul>
<p><code>@FastNative</code> 和 <code>@CriticalNative</code> 注解在执行原生方法时会停用垃圾回收。请勿使用运行时间较长的方法，包括通常很快但一般不受控制的方法。</p>
<p>停顿垃圾回收可能会导致死锁。如果锁尚未得到本地释放（即尚未返回受管理代码），请勿在原生快速调用期间获取锁。此要求不适用于常规的 JNI 调用，因为 ART 将正执行的原生代码视为已暂停的状态。</p>
<p><code>@FastNative</code> 可以使原生方法的性能提升高达 3 倍，<code>@CriticalNative</code> 则可以提升高达 5 倍。例如，在 Nexus 6P 设备上测量的 JNI 转换如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Java 原生接口 (JNI) 调用</th>
<th>执行时间（以纳秒计）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>常规 JNI</td>
<td>115</td>
<td></td>
</tr>
<tr>
<td></td>
<td><em>!bang JNI</em></td>
<td>60</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>&lt;span style=&quot;box-sizing: inherit;&quot;&gt;@FastNative&lt;/span&gt;</code></td>
<td>35</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>&lt;span style=&quot;box-sizing: inherit;&quot;&gt;@CriticalNative&lt;/span&gt;</code></td>
<td>25</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Android 8.0 版本中，Android Runtime (ART) 有了极大改进。下面的列表总结了设备制造商可以在 ART 中获得的增强功能。&lt;/p&gt;
&lt;h2 id=&quot;并发压缩式垃圾回收器&quot;&gt;&lt;a href=&quot;#并发压缩式垃圾回收器&quot; class=&quot;header
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>ART 和 Dalvik的区别</title>
    <link href="http://fushenghua.github.io/archives/a9cc5307.html"/>
    <id>http://fushenghua.github.io/archives/a9cc5307.html</id>
    <published>2017-03-07T00:55:29.000Z</published>
    <updated>2018-05-05T15:30:46.808Z</updated>
    
    <content type="html"><![CDATA[<p>Android Runtime (ART) 是 Android 上的应用和部分系统服务使用的托管式运行时。ART 及其前身 Dalvik 最初是专为 Android 项目打造的。作为运行时的 ART 可执行 Dalvik 可执行文件并遵循 Dex 字节码规范。</p>
<p>ART 和 Dalvik 是运行 Dex 字节码的兼容运行时，因此针对 Dalvik 开发的应用也能在 ART 环境中运作。不过，Dalvik 采用的一些技术并不适用于 ART。有关最重要问题的信息，请参阅在 Android Runtime (ART) 上验证应用行为。</p>
<h2 id="ART-功能"><a href="#ART-功能" class="headerlink" title="ART 功能"></a>ART 功能</h2><p>以下是 ART 实现的一些主要功能。</p>
<h3 id="预先-AOT-编译"><a href="#预先-AOT-编译" class="headerlink" title="预先 (AOT) 编译"></a>预先 (AOT) 编译</h3><p>ART 推出了预先 (AOT) 编译，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。</p>
<p>在安装时，ART 使用设备自带的 <strong>dex2oat</strong> 工具来编译应用。该实用工具接受 <a href="https://source.android.google.cn/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">DEX</a> 文件作为输入，并针对目标设备生成已编译的应用可执行文件。该实用工具应能够毫不费力地编译所有有效的 DEX 文件。但是，一些后处理工具会生成无效文件，Dalvik 可以接受这些文件，但 ART 无法编译这些文件。有关详情，请参阅<a href="http://developer.android.google.cn/guide/practices/verifying-apps-art.html#GC_Migration" target="_blank" rel="external">解决垃圾回收问题</a>。</p>
<h3 id="优化的垃圾回收"><a href="#优化的垃圾回收" class="headerlink" title="优化的垃圾回收"></a>优化的垃圾回收</h3><p>垃圾回收 (GC) 可能会损害应用的性能，从而导致显示不稳定、界面响应速度缓慢以及其他问题。ART 通过以下几种方式优化垃圾回收：</p>
<ul>
<li>采用一个而非两个 GC 暂停</li>
<li>在 GC 保持暂停状态期间并行处理</li>
<li>采用总 GC 时间更短的回收器清理最近分配的短时对象这种特殊情况</li>
<li>优化了垃圾回收人机工程学，能够更加及时地进行并行垃圾回收，这使得 <a href="http://developer.android.google.cn/tools/debugging/debugging-memory.html#LogMessages" target="_blank" rel="external"><code>GC_FOR_ALLOC</code></a> 事件在典型用例中极为罕见</li>
<li>压缩 GC 以减少后台内存使用和碎片</li>
</ul>
<h3 id="开发和调试优化"><a href="#开发和调试优化" class="headerlink" title="开发和调试优化"></a>开发和调试优化</h3><p>ART 提供了大量功能来优化应用开发和调试。</p>
<h4 id="支持采样分析器"><a href="#支持采样分析器" class="headerlink" title="支持采样分析器"></a>支持采样分析器</h4><p>一直以来，开发者都使用 <a href="http://developer.android.google.cn/tools/help/traceview.html" target="_blank" rel="external">Traceview</a> 工具（旨在跟踪应用执行）作为分析器。虽然 Traceview 可提供有用的信息，但其根据每次方法调用开销得出的 Dalvik 分析结果会出现偏差，而且使用该工具明显会影响运行时性能。</p>
<p>ART 添加了对没有这些限制的专用采样分析器的支持，从而更准确地了解应用执行情况，而不会明显减慢速度。KitKat 版本为 Dalvik 的 Traceview 添加了采样支持。</p>
<h4 id="支持更多调试功能"><a href="#支持更多调试功能" class="headerlink" title="支持更多调试功能"></a>支持更多调试功能</h4><p>ART 支持许多新的调试选项，特别是与监控和垃圾回收相关的功能。例如，您可以：</p>
<ul>
<li>查看堆栈跟踪中保留了哪些锁，然后跳转到持有锁的线程。</li>
<li>询问指定类的当前活动的实例数、请求查看实例，以及查看使对象保持有效状态的参考。</li>
<li>过滤特定实例的事件（如断点）。</li>
<li>查看方法退出（使用“method-exit”事件）时返回的值。</li>
<li>设置字段观察点，以在访问和/或修改特定字段时暂停程序执行。</li>
</ul>
<h4 id="优化了异常和崩溃报告中的诊断详细信息"><a href="#优化了异常和崩溃报告中的诊断详细信息" class="headerlink" title="优化了异常和崩溃报告中的诊断详细信息"></a>优化了异常和崩溃报告中的诊断详细信息</h4><p>当发生运行时异常时，ART 会为您提供尽可能多的上下文和详细信息。ART 会提供 <code>[java.lang.ClassCastException](http://developer.android.google.cn/reference/java/lang/ClassCastException.html)</code>、<code>[java.lang.ClassNotFoundException](http://developer.android.google.cn/reference/java/lang/ClassNotFoundException.html)</code> 和 <code>[java.lang.NullPointerException](http://developer.android.google.cn/reference/java/lang/NullPointerException.html)</code> 的更多异常详细信息。 （更高版本的 Dalvik 提供 <code>[java.lang.ArrayIndexOutOfBoundsException](http://developer.android.google.cn/reference/java/lang/ArrayIndexOutOfBoundsException.html)</code> 和 <code>[java.lang.ArrayStoreException](http://developer.android.google.cn/reference/java/lang/ArrayStoreException.html)</code> 的更多异常详细信息，这些信息现在包括数组大小和超出范围的偏移量；ART 也提供这类信息。）</p>
<p>例如，<code>[java.lang.NullPointerException](http://developer.android.google.cn/reference/java/lang/NullPointerException.html)</code> 现在会显示有关应用尝试处理 null 指针时所执行操作的信息（例如应用尝试写入的字段或尝试调用的方法）。一些典型示例如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">java.lang.NullPointerException: Attempt <span class="keyword">to</span> <span class="keyword">write</span> <span class="keyword">to</span> field <span class="string">'int</span></div><div class="line">android.accessibilityservice.AccessibilityServiceInfo.flags' <span class="keyword">on</span> a null object</div><div class="line"><span class="keyword">reference</span></div><div class="line"></div><div class="line">java.lang.NullPointerException: Attempt <span class="keyword">to</span> invoke <span class="keyword">virtual</span> <span class="function"><span class="keyword">method</span></span></div><div class="line">'<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span>.<span class="title">toString</span><span class="params">()</span>' <span class="title">on</span> <span class="title">a</span> <span class="title">null</span> <span class="title">object</span> <span class="title">reference</span></div></pre></td></tr></table></figure>
<p>ART 还通过纳入 Java 和原生堆栈信息在应用原生代码崩溃报告中提供优化的上下文信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Runtime (ART) 是 Android 上的应用和部分系统服务使用的托管式运行时。ART 及其前身 Dalvik 最初是专为 Android 项目打造的。作为运行时的 ART 可执行 Dalvik 可执行文件并遵循 Dex 字节码规范。&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>优化Gradle 依赖使用方式</title>
    <link href="http://fushenghua.github.io/archives/c66eed35.html"/>
    <id>http://fushenghua.github.io/archives/c66eed35.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.653Z</updated>
    
    <content type="html"><![CDATA[<p>经历过模块化后,项目依赖变的错综复杂,以至于编译速度过慢,部分模块依赖不合理导致包增大等。所以清理了一些不必要的依赖及重复依赖详见 <strong>commit</strong>：</p>
<blockquote>
<p><a href="http://stash.lab.tclclouds.com/projects/CLEAN/repos/cleaner_module/commits/d374e1c36d5e7a44c3b1d817216f3b6a04a9f318" target="_blank" rel="external">commits/d374e1c36d5e7a44c3b1d817216f3b6a04a9f318</a></p>
</blockquote>
<p>现在仍有些问题,比如 <strong>SpaceBase</strong> 依赖了 <strong>VirusEngine</strong> 等问题。</p>
<h3 id="全新的依赖方式"><a href="#全新的依赖方式" class="headerlink" title="全新的依赖方式"></a>全新的依赖方式</h3><h4 id="需要那个开那个"><a href="#需要那个开那个" class="headerlink" title="需要那个开那个"></a>需要那个开那个</h4><p>修改项目中 <code>module.properties</code> 的配置, <code>true</code> 代表以<code>Project</code> 方式引入,反之则是<code>aar</code>方式,<strong>该配置已被忽略,只对当前工程配置有效。</strong></p>
<p>如果你确实想提交修改,请使用 <code>git add -f module.properties</code> 命令强制添加。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="params">...</span></div><div class="line">isBoostengineDebug=<span class="literal">false</span></div><div class="line">isAppmgrDebug=<span class="literal">false</span></div><div class="line">isCpuDebug=<span class="literal">false</span></div><div class="line">isNotifyboxDebug=<span class="literal">false</span></div><div class="line">isHardwareDebug=<span class="literal">false</span></div><div class="line">isAntivirusDebug=<span class="literal">false</span></div><div class="line">isJunkDebug=<span class="literal">false</span></div><div class="line">isAllDebug=<span class="literal">false</span><span class="comment">// 全部 Debug，即编译Project模式</span></div></pre></td></tr></table></figure>
<h4 id="添加新的模块依赖"><a href="#添加新的模块依赖" class="headerlink" title="添加新的模块依赖"></a>添加新的模块依赖</h4><p>如果你需要添加新的模块依赖,请按照以下方法,在 <code>module.gradle</code> 脚本中新增 <code>compile_*</code> 方法,如下:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> compile_junk(<span class="keyword">Project</span> projectModule)&#123;</div><div class="line">    projectModule.<span class="keyword">dependencies</span>&#123;</div><div class="line">        <span class="keyword">if</span> (isAllDebug.toBoolean() || isJunkDebug.toBoolean()) &#123;</div><div class="line">            <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':junk'</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">compile</span>(name: <span class="string">'junk'</span>, ext: <span class="string">'aar'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后通过闭包形式传递出去,在 <code>module.gradle</code> 脚本中有<code>ext</code> 扩展属性 ，添加如下：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class">ext </span>&#123;</div><div class="line">  compile_junk = this.<span class="variable">&amp;compile_junk</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终通过以下方式使用</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile_junk(<span class="name">getProject</span>())</div></pre></td></tr></table></figure>
<h3 id="模块公用的Libs库"><a href="#模块公用的Libs库" class="headerlink" title="模块公用的Libs库"></a>模块公用的Libs库</h3><p>在工程目录的顶级 <code>libs</code> 文件夹中存放着各个模块的 <code>aar</code> ,如果需要更新,可以通过脚本进行<br>全量更新,或者各模块部分更新。</p>
<h3 id="更新AAR"><a href="#更新AAR" class="headerlink" title="更新AAR"></a>更新AAR</h3><p>在<code>cleaner</code> 工程目录下，在你每次<strong>运行</strong>程序时 <code>update-aar.gradle</code>会自动更新<strong>已开启</strong>模块(如<code>isJunkDebug=true</code>)的<code>aar</code> 到 公用<code>libs</code>库中，你所需要做的就是 <code>commit</code>，这样能保证各位小伙伴使用的都是较新的<code>aar</code>。</p>
<p>同样的你也可以手动触发<code>Task</code>来更新<code>aar</code>，相应<code>Task</code> 如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">task</span> updateAAR &lt;&lt; &#123;</div><div class="line">    eachLibsAAR()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><p>如果需要全部通过 <code>Project</code> 形式构建<strong>版本发布</strong>,只需添加动态参数 <code>isAllDebug=true</code> ，比如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew -PisAllDebug=<span class="literal">true</span> hello</div></pre></td></tr></table></figure>
<p>同样的可以添加更多的模块参数,来表示某些模块通过 <code>Project</code> 形式构建，比如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew -PisAppmgrDebug=<span class="literal">true</span> -PisJunkDebug=<span class="literal">true</span> hello</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: 默认都是以引入<code>aar</code> 形式构建(除<strong>SpaceBase</strong>),所以如果不添加参数,需要及时更新<code>aar</code></p>
</blockquote>
<h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><h4 id="2017-4-21-优化Gradle编译速度，最快3s。"><a href="#2017-4-21-优化Gradle编译速度，最快3s。" class="headerlink" title="2017/4/21 优化Gradle编译速度，最快3s。"></a>2017/4/21 优化Gradle编译速度，最快3s。</h4><blockquote>
<p>1、修改<strong><code>isAllDebug</code></strong> 作用域，由原存放在<code>module.properties</code> 修改存放在<code>gradle.properties</code>中。<br>2、可选模块<strong>include</strong>，只有在<code>module.properties</code>配置文件中开关为<strong>true</strong> 的模块，才会被Android Studio 所<strong>include</strong>。<br>3、新增<code>task</code> 耗时监听，方便查看耗时<code>task</code>，在<em>Gradle Console</em> 中输出。<br>4、区分测试开发输出，新增<strong><code>dev</code></strong> <code>productFlavors</code>,同时关闭一些不用的<code>productFlavors</code>，其中<strong><code>dev</code></strong> 用于测试Jenkins 输出apk <code>flavors</code>，<strong><code>buildVersion</code></strong> 用于研发本地输出apk，<strong>minSdkVersion=21</strong>，关闭<strong>fabric</strong> 在<strong><code>buildVersion</code></strong> 中上报初始化，同时也优化了其他模块的依赖。<br>5、本地默认只有<strong><code>buildVersion</code></strong><code>flavors</code>，只有在<code>isAllDebug=true</code>的情况，才会开启其他的<code>flavors</code>。以便获得更好的编译体验。<strong>还有修改完gradle配置文件后记得点build sync<img src="/images/toolbar-sync-gradle.png" alt="Alt text">进行同步一下。</strong></p>
</blockquote>
<h4 id="2017-5-27-添加自动合并多语言task"><a href="#2017-5-27-添加自动合并多语言task" class="headerlink" title="2017/5/27  添加自动合并多语言task"></a>2017/5/27  添加自动合并多语言task</h4><blockquote>
<p>1 、使用<code>Python</code>脚本自动化合入多语言的<code>task</code>，所以在使用前需要有<code>Python</code>环境，相应代码块如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">task mergeLanguage(<span class="built_in">type</span>: Exec) &#123;</div><div class="line">    workingDir <span class="string">'./'</span></div><div class="line">    <span class="built_in">command</span>Line <span class="string">"python"</span>, <span class="string">"merge_strs.py"</span>,</div><div class="line"><span class="string">"/home/silver/ssd/AndroidStudioProjects/cleaner_module/spaceplus_android/junk/src/main/res/"</span>,</div><div class="line">            <span class="string">"/home/silver/桌面/清理缓存0502-多语言/"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中第一个参数是需要添入多语言模块文件目录，第二个参数是存放多语言文件目录。修改参数 执行<strong><code>mergeLanguage</code></strong> <code>task</code>即可合并多语言。<br><img src="/images/2017-05-27 19:26:37屏幕截图.png" alt="Alt text"></p>
<h4 id="2017-5-31-Auto-Update-Librarys-AAR"><a href="#2017-5-31-Auto-Update-Librarys-AAR" class="headerlink" title="2017/5/31  Auto Update Librarys AAR"></a>2017/5/31  Auto Update Librarys AAR</h4><blockquote>
<p>1 、<strong><code>quartz-robot</code></strong>会在<strong>每周一至周五(8,12,16,20h)</strong>准时自动更新<code>aar</code>到git repos。</p>
</blockquote>
<h4 id="2017-5-1-更新说明"><a href="#2017-5-1-更新说明" class="headerlink" title="2017/5/1  更新说明"></a>2017/5/1  更新说明</h4><p>以上是模块化后解决过渡时期编译速度慢,方便开发调试等各种便利的方案,各位研发大拿体验<br>下,感受如丝般顺滑,如有问题及时沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历过模块化后,项目依赖变的错综复杂,以至于编译速度过慢,部分模块依赖不合理导致包增大等。所以清理了一些不必要的依赖及重复依赖详见 &lt;strong&gt;commit&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://stash.lab.
    
    </summary>
    
      <category term="基础技能" scheme="http://fushenghua.github.io/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>ViewStub原理分析</title>
    <link href="http://fushenghua.github.io/archives/235d5e38.html"/>
    <id>http://fushenghua.github.io/archives/235d5e38.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-05-29T01:33:39.995Z</updated>
    
    <content type="html"><![CDATA[<p>ViewStub 是一个看不见的，没有大小，不占布局位置的 View，可以用来懒加载布局。当 ViewStub 变得可见或 <code>inflate()</code> 的时候，布局就会被加载（替换 ViewStub）。因此，ViewStub 一直存在于视图层次结构中直到调用了 <code>setVisibility(int)</code> 或 <code>inflate()</code>。</p>
<p>我们先来看看构造方法：</p>
<p>非常简单的两步，就能做到View的懒加载，非常方便，其原因是什么呢？</p>
<p>接下去深入源码分析一下。</p>
<h2 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a>构造方法分析</h2><p>首先分析一下构造方法，了解一下它是如何创建的。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, @LayoutRes <span class="keyword">int</span> layoutResource)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">// StubbedView的资源id</span></div><div class="line">    mLayoutResource = layoutResource;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context);</div><div class="line">    <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs,</div><div class="line">            R.styleable.ViewStub, defStyleAttr, defStyleRes);</div><div class="line">    <span class="comment">// mInflatedId 存储StubbedView的id</span></div><div class="line">    mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);</div><div class="line">    <span class="comment">// mLayoutResource 为StubbedView的resourceId</span></div><div class="line">    mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, <span class="number">0</span>);</div><div class="line">    <span class="comment">// viewStub 自己的id</span></div><div class="line">    mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);</div><div class="line">    a.recycle();</div><div class="line">    <span class="comment">// 设置为不可见 </span></div><div class="line">    setVisibility(GONE);</div><div class="line">    <span class="comment">// 不绘制本身</span></div><div class="line">    setWillNotDraw(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ViewStub</code>在构造方法里不仅仅获取赋值属性，比较关键的是，还 默认将ViewStub自己设置为不可见（跳过onMeasure与onLayout），不绘制。</p>
<p>这里有一个要点：<strong>在XML里配置ViewStub的可见性是没有用的</strong>。</p>
<h2 id="测量-与-绘制"><a href="#测量-与-绘制" class="headerlink" title="测量 与 绘制"></a>测量 与 绘制</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@Override</span></div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    <span class="comment">// 写死的宽高为0</span></div><div class="line">    setMeasuredDimension(0, 0);</div><div class="line">&#125;</div><div class="line"><span class="variable">@Override</span></div><div class="line">public void draw(Canvas canvas) &#123;</div><div class="line">    <span class="comment">//空方法，不draw任何东西</span></div><div class="line">&#125;</div><div class="line"><span class="variable">@Override</span></div><div class="line">protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line">    <span class="comment">//空方法，不draw任何东西</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="inflate-方法分析"><a href="#inflate-方法分析" class="headerlink" title="inflate()方法分析"></a>inflate()方法分析</h2><p>之前在简单教程里有提到 <code>inflate</code>方法，它是<code>ViewStub</code>实现懒加载的最为关键的方法，接下去去分析一下。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回 StubbedView</span></div><div class="line"><span class="keyword">public</span> View inflate() &#123;</div><div class="line">    <span class="comment">// 尝试去获取 viewParent 第一次调用的时候不为null，而后则为null</span></div><div class="line">    <span class="keyword">final</span> ViewParent viewParent = getParent();</div><div class="line">    <span class="comment">// 当 viewParent 不为null的时候</span></div><div class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup) &#123;</div><div class="line">        <span class="comment">// 我们在xml里配置的layout的资源id 如果id无效，则会报错</span></div><div class="line">        <span class="keyword">if</span> (mLayoutResource != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ViewGroup <span class="keyword">parent</span> = (ViewGroup) viewParent;</div><div class="line">            <span class="comment">// 实例化 LayoutInflater</span></div><div class="line">            <span class="keyword">final</span> LayoutInflater factory;</div><div class="line">            <span class="keyword">if</span> (mInflater != <span class="keyword">null</span>) &#123;</div><div class="line">                factory = mInflater;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                factory = LayoutInflater.from(mContext);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// inflate，StubbedView在这里被实例化</span></div><div class="line">            <span class="keyword">final</span> View view = factory.inflate(mLayoutResource, <span class="keyword">parent</span>,</div><div class="line">                    <span class="keyword">false</span>);</div><div class="line">            <span class="comment">// 可以看到，这里如果我们在XML里写了inflateId，则会设置给StubbedView</span></div><div class="line">            <span class="keyword">if</span> (mInflatedId != NO_ID) &#123;</div><div class="line">                view.setId(mInflatedId);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 注意：这两步步 ViewSutb 找到自己的位置，并从父View中移除了自己</span></div><div class="line">            <span class="comment">// 这会导致 以后调用inflate的时候 再也获取不到 viewParent了</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = <span class="keyword">parent</span>.indexOfChild(this);</div><div class="line">            <span class="keyword">parent</span>.removeViewInLayout(this);</div><div class="line">            <span class="comment">// 拿出ViewStub的LayoutParamas，不为null 则会赋值给 StubbedView</span></div><div class="line">            <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = getLayoutParams();</div><div class="line">            <span class="comment">// 把 StubbedView 添加到ViewStub的父View里</span></div><div class="line">            <span class="keyword">if</span> (layoutParams != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">parent</span>.addView(view, index, layoutParams);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">parent</span>.addView(view, index);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//使用一个弱引用来保存StubbedView</span></div><div class="line">            mInflatedViewRef = <span class="keyword">new</span> WeakReference(view);</div><div class="line">            <span class="comment">//回调listener</span></div><div class="line">            <span class="keyword">if</span> (mInflateListener != <span class="keyword">null</span>) &#123;</div><div class="line">                mInflateListener.onInflate(this, view);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回 StubbedView</span></div><div class="line">            <span class="keyword">return</span> view;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// id无效，则throw一个 IllegalArgumentException</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ViewStub must have a valid layoutResource"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// inflate被调用一次后 就没有了ViewParent，就会报这个错</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ViewStub must have a non-null ViewGroup viewParent"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我在每行代码上都加上了详细的注释，主要的操作就是把StubbedView给Inflate出来，然后把它放到自己的位置，代码非常清晰，非常简单。</p>
<p>总结来说，其实<code>inflate</code>方法是做了一个『偷梁换柱』的操作，把 <code>StubbedView</code>动态的添加到自己原来的位置上，也因此实现了懒加载功能。</p>
<p>这里还需要注意的是 <strong>ViewStub 必须要有一个 Parent，即必须要有父视图！</strong><br>另外值得一提的是：ViewStub还重写了View的<code>setVisibility</code>方法，让我们来分析一下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setVisibility</span><span class="params">(<span class="keyword">int</span> visibility)</span> </span>&#123;</div><div class="line">    <span class="comment">// mInflatedViewRef 保存了 StubbedView还记得吗？ inflate过后它就不是null了 </span></div><div class="line">    <span class="keyword">if</span> (mInflatedViewRef != <span class="keyword">null</span>) &#123;</div><div class="line">        View view = mInflatedViewRef.get();</div><div class="line">        <span class="comment">// 操作 StubbedView</span></div><div class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">            view.setVisibility(visibility);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"setVisibility called on un-referenced view"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 操作ViewStub自己，构造方法里的GONE记得么？</span></div><div class="line">        <span class="keyword">super</span>.setVisibility(visibility);</div><div class="line">        <span class="comment">// 如果是 VISIBLE INVISIBLE 则会去调用 inflate方法！！！！</span></div><div class="line">        <span class="keyword">if</span> (visibility == VISIBLE || visibility == INVISIBLE) &#123;</div><div class="line">            inflate();<span class="comment">//注意这一行代码</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>setVisibility</code>方法中也可能会调用<code>inflate()</code>方法，所以当我们想让StubbedView被加载进来，而我们不需要StubbedView的实例的时候，可以用<code>setVisibility（View.VISIBLE）</code>。</p>
<p>不过需要注意的是 不要再接着调用<code>inflate</code>方法，因为此时的 ViewStub 已经被移除了！</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol>
<li>使用ViewStub，必须指定layoutResourceId(必须是布局文件)</li>
<li>在XML里配置ViewStub的可见性是没有用的</li>
<li>ViewStub 主要原理藏在<code>inflate()</code>方法中，是它把真正要加载的View给加载了进来</li>
<li><code>inflate()</code>方法只能调用一次</li>
<li>ViewStub调用<code>inflate()</code>后就不要再用它了（让它功成身退！）</li>
<li>要小心<code>setVisibility</code>方法，因为它可能会调用<code>inflate()</code></li>
<li>在XML里给ViewStub设置的LayoutParamas(宽高margin等)会传递给StubbedView,所以我们如果要控制StubbedView的LayoutParamas，则需要写在ViewStub里而不是StubbedView！</li>
<li>期待补充</li>
</ol>
<p>好了，主要的ViewStub都分析完了，知道原理之后就可以自己动手写一个加强版的 ViewStub 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ViewStub 是一个看不见的，没有大小，不占布局位置的 View，可以用来懒加载布局。当 ViewStub 变得可见或 &lt;code&gt;inflate()&lt;/code&gt; 的时候，布局就会被加载（替换 ViewStub）。因此，ViewStub 一直存在于视图层次结构中直到调
    
    </summary>
    
      <category term="性能优化" scheme="http://fushenghua.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>APK 瘦身，减少APK体积的大小</title>
    <link href="http://fushenghua.github.io/archives/db6d97a8.html"/>
    <id>http://fushenghua.github.io/archives/db6d97a8.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.634Z</updated>
    
    <content type="html"><![CDATA[<p>让我们的apk文件尽可能更小，移除那些未使用的代码和资源文件。本章节介绍了如何做到让APK更小，性能更好，下载转化率会更高，以及如何指定在构建APK过程中保留或移除项目中的代码和资源，在我们还没有分析APK大小之前，项目中存在一些资源放置处理不当，没有统一的规范，依赖管理不合理，资源重叠，dex方法数过多、文件过大等问题，导致整个APK文件也比较大，对于下载转化率必然有一定的影响。</p>
<p>[TOC]</p>
<h1 id="分析APK的大小"><a href="#分析APK的大小" class="headerlink" title="分析APK的大小"></a>分析APK的大小</h1><p>古人云：工欲善其事，必先利其器，我们得先有利器，下面就是我们常用的分析APK大小工具的利器做一些简单的介绍和使用，帮助我们分析造成APK体积较大的元凶，以便于我们从那些方面入手优化。</p>
<h3 id="使用Android-Studio-2-2"><a href="#使用Android-Studio-2-2" class="headerlink" title="使用Android Studio 2.2"></a>使用Android Studio 2.2</h3><p>Android Studio 2.2 新功能直接能分析APK的大小，双击打开就能看到那些占用APK比例大，方法数等。</p>
<p><img src="http://img.blog.csdn.net/20160821125248173" alt="这里写图片描述"></p>
<ul>
<li>分析任何的APK</li>
<li>查看APK下载包的大小，解压后的实际大小</li>
<li>反编译资源文件，还原layout中的资源id，代码</li>
<li>分析dex，显示每部分的方法数，直接查看那些library体积比较大</li>
</ul>
<p>使用方法：Build -&gt; Analyz APK</p>
<p>有了<code>Analyz APK</code>这个利器，以下工具也可以基本不用了</p>
<h3 id="NimbleDroid"><a href="#NimbleDroid" class="headerlink" title="NimbleDroid"></a>NimbleDroid</h3><p><a href="https://nimbledroid.com/" target="_blank" rel="external">NimbleDroid</a> 是美国哥伦比亚大学的博士创业团队研发出来的自动化分析Android app性能指标的系统，分析的方式有静态和动态两种方式，其中静态分析可以分析出APK安装包中大文件排行榜，各种知名SDK的大小以及占代码整体的比例，各种类型文件的大小以及占排行，各种知名SDK的方法数以及占所有dex中方法数的比例,针对缓慢的方法，缓慢的第三方SDK和内存泄漏。<br>测量生成的速度、网络、内存和磁盘使用率。总之有非常多分析App性能的功能，如果要做性能优化，也可以尝试使用<a href="https://nimbledroid.com/" target="_blank" rel="external">NimbleDroid</a>。</p>
<p>查看详细的方法耗时</p>
<p><img src="https://nimbledroid.com/assets/home/img-2nd-section-a313c4d4a955152934fbc2999bbbb266.png" alt=""></p>
<p>具体使用方法请看官网：<br><a href="https://nimbledroid.com/" target="_blank" rel="external">https://nimbledroid.com/</a></p>
<p>不过需要注意的是<a href=""><strong>不要上传任何未发布的产品</strong></a>。</p>
<h3 id="ClassShark"><a href="#ClassShark" class="headerlink" title="ClassShark"></a>ClassShark</h3><p>ClassShark 是一款查看Android执行文件（apk）的浏览工具，目前有两个android App（Apk）和桌面（jar）的版本。<br>使用这款工具，可以很方便的打开APK/Class/Jar/res<br>等 文件和分析里面的内容。</p>
<p><img src="https://github.com/borisf/classyshark-user-guide/raw/master/images/5%20ClassesDexData.png" alt=""></p>
<p>具体源码与使用方法详细在github中：<br><a href="https://github.com/google/android-classyshark" target="_blank" rel="external">https://github.com/google/android-classyshark</a></p>
<p>通过以上任一工具分析我们知道我们项目中主要是以下文件占用APK大小：</p>
<ul>
<li><p><strong>classes.dex</strong><br>   classes.dex是java源码编译后生成的java字节码文件，</p>
</li>
<li><p><strong>res</strong><br>  主要是存放我们的图片资源</p>
</li>
<li><p><strong>resources.arsc</strong><br>  编译后的二进制资源文件，非常多无效资源文件(语言)</p>
</li>
<li><p><strong>assets</strong><br>  主要存放了我们的缓存数据文件，已做最优化压缩，我们考虑能否云端存放。</p>
</li>
<li><p><strong>lib</strong></p>
<pre><code>主要是存放我们的so库，目前我们已经优化了
</code></pre></li>
</ul>
<p>既然知道了那些数据导致我们APK体积大，那么我们就着手瘦身了。</p>
<h1 id="对APK进行瘦身"><a href="#对APK进行瘦身" class="headerlink" title="对APK进行瘦身"></a>对APK进行瘦身</h1><h2 id="对资源进行极限压缩"><a href="#对资源进行极限压缩" class="headerlink" title="对资源进行极限压缩"></a>对资源进行极限压缩</h2><p>对资源进行极限压缩，主要是对如：res里面用到的图片资源文件和assets文件夹下的一些html，db等一些缓存预留在APK的数据文件</p>
<ul>
<li>assets资源压缩，使用7zip或者lzma压缩方式最高，把文件打包压缩</li>
<li>res 图片资源的压缩，使用tinypng优化Android的资源图片，通常我们可以在保证图片不失真的情况下，多压缩几次。目前tinypng已经支持png和jpg图片、.9图的压缩  </li>
<li>将非alpha的图转换成jpg形式</li>
</ul>
<p>通过以上方法我们图片降低了79%的大小。</p>
<h3 id="使用WEBP，SVG图片资源格式"><a href="#使用WEBP，SVG图片资源格式" class="headerlink" title="使用WEBP，SVG图片资源格式"></a>使用WEBP，SVG图片资源格式</h3><ul>
<li>WebP是谷歌研发出来的一种图片数据格式，它是一种支持有损压缩和无损压缩的图片文件格式，如果应用支持到Android 4.0+，那么我们可以使用WebP格式代替PNG，我们的资源大小能降低50%多。或者有些资源可以使用SVG图片资源更小。<br>以下是他们的对比图：</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160821131133417" alt="这里写图片描述"></p>
<p>  这里提供方便转换的WEBP资源的工具：</p>
<ul>
<li><a href="https://isparta.github.io/" target="_blank" rel="external">https://isparta.github.io/</a></li>
<li><a href="https://imageoptim.com/mac" target="_blank" rel="external">https://imageoptim.com/mac</a></li>
</ul>
<ul>
<li>使用VectorDrawable和SVG图片来替换原有图片<br>  使用SVG不用考虑屏幕适配问题，体积非常小。</li>
</ul>
<h3 id="利用AndResGuard资源压缩打包工具"><a href="#利用AndResGuard资源压缩打包工具" class="headerlink" title="利用AndResGuard资源压缩打包工具"></a>利用AndResGuard资源压缩打包工具</h3><p>微信中的资源混淆工具主要为了混淆资源ID长度(例如将res/drawable/icon.png,png变成混淆为r/s/a.png)，同时利用7z深度压缩、对png的存储方式做了改变占用内存更小，大大减少了安装包体积</p>
<p>具体源码与使用方法详细在github中：</p>
<p><a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="external">https://github.com/shwenzhang/AndResGuard</a></p>
<h2 id="清除你的代码和资源"><a href="#清除你的代码和资源" class="headerlink" title="清除你的代码和资源"></a>清除你的代码和资源</h2><p>通过上面的图片资源极限压缩能对APK减小不少，但这往往这些还是不够的，项目里还有很多未使用的资源文件，重复的资源等，这里主要参考Google官方文档<a href="https://developer.android.com/studio/build/shrink-code.html#shrink-code" target="_blank" rel="external">https://developer.android.com/studio/build/shrink-code.html#shrink-code</a> 部分，利用Android Plugin开启gradle 的<code>Code shrinking</code>和<code>ProGuard</code>结合使用。</p>
<ul>
<li><p><code>ProGuard</code>能够检测和删除未使用的类，字段，方法，和从你的打包应用程序的属性，包括那些包含代码库，<a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html" target="_blank" rel="external">ProGuard</a>是一个混淆优化字节码的工具,能够删除一些未使用的代码，混淆使用的类，字段，方法和短名称，经过混淆处理也能够使APK源代码得到保护</p>
</li>
<li><p><code>Code shrinking</code>是一个Android Plugin for Gradle，从您的打包的应用程序中删除未使用的资源，包括代码库中的未使用的资源。它工作在与代码缩小，这样，一旦未使用的代码已被删除，任何资源不再引用可以安全地删除。</p>
</li>
</ul>
<p>该功能需要依赖于：</p>
<ul>
<li>SDK Tools 25.0.10 或更高</li>
<li>Android Plugin for Gradle 2.0.0 或更高</li>
</ul>
<h3 id="清除无用代码"><a href="#清除无用代码" class="headerlink" title="清除无用代码"></a>清除无用代码</h3><p>code shrinking需要结合ProGuard使用，添加<code>minifyEnabled</code> <code>true</code>在你的<code>build.gradle</code>文件中。</p>
<blockquote>
<p>需要注意code shrinking会减慢Gradle 编译，应避免使用它在您的调试版本中使用它。Android Studio禁用ProGuard使用 <a href="https://developer.android.com/tools/building/building-studio.html#instant-run" target="_blank" rel="external">Instant Run</a>.。<br>例如，以下从<code>build.gradle</code>文件片段，使<code>code shrinking</code>为发布版本</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="section">android</span> &#123;</div><div class="line">    <span class="section">buildTypes</span> &#123;</div><div class="line">        <span class="section">release</span> &#123;</div><div class="line">            <span class="attribute">minifyEnabled</span> <span class="literal">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(‘proguard-android.txt<span class="string">'),</span></div><div class="line">                    'proguard-rules.pro<span class="string">'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>getDefaultProguardFile(‘proguard-android.txt&#39;)</code>默认ProGuard设置来自于Android SDK <code>tools/proguard/</code>中的文件夹</p>
<blockquote>
<p>更多的减少代码可以尝试使用相同位置的<code>proguard-android-optimize.txt</code>文件（这样能让我们的APK又减少了0.5M以上）proguard-rules.pro是你自定义的proguard规则。</p>
</blockquote>
<p>那么我们怎么知道每一次build，删除了和未删除那些资源和代码呢，ProGuard会输出以下文件在<code>/build/outputs/mapping/release/</code>:</p>
<ul>
<li><strong>dump.txt</strong><br>描述.apk文件中所有类文件间的内部结构</li>
<li><strong>mapping.txt</strong><br>列出了原始的类，方法和字段名与混淆后代码间的映射。这个文件很重要，当你从release版本中收到一个bug报告时，可以用它来翻译被混淆的代码。</li>
<li><strong>seeds.txt</strong><br>列出了未被混淆的类和成员</li>
<li><strong>usage.txt</strong><br>列出了从.apk中删除的代码</li>
<li><strong>resources.txt</strong><br>列出resource被保留的资源</li>
</ul>
<h3 id="自定义混淆规则"><a href="#自定义混淆规则" class="headerlink" title="自定义混淆规则"></a>自定义混淆规则</h3><p>在某些情况下，默认的混淆器配置文件<code>proguard-android.txt</code>文件是会移除所有只有未使用的代码，但也有可能会误删除了你需要的代码，所以要注意以下几种情况：</p>
<ul>
<li>在<code>AndroidManifest.xml</code>配置的文件类</li>
<li>使用了JNI 的接口方法</li>
<li>运行时反射调用方法(不过现在ProGuard已经可以处理这种了)</li>
</ul>
<p>添加-keep来忽略一下防止被混淆的代码到proguard-rules.pro文件中，比如：</p>
<p><code>-keep public class MyClass</code></p>
<p>另外也可以使用<a href="https://developer.android.com/reference/android/support/annotation/Keep.html" target="_blank" rel="external">@Keep </a>注解在你的需要忽略的代码中，需要<a href="https://developer.android.com/tools/support-library/features.html#annotations" target="_blank" rel="external">Annotations Support Library</a>的支持</p>
<p>有关自定义proguard-rules.pro文件的更多信息，可以参考<a href="http://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html" target="_blank" rel="external">ProGuard Manual.</a>这里<a href="http://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/troubleshooting.html" target="_blank" rel="external">Troubleshooting</a>列出了一些常见的问题。</p>
<h3 id="清除无用的资源文件"><a href="#清除无用的资源文件" class="headerlink" title="清除无用的资源文件"></a>清除无用的资源文件</h3><p><code>Resource shrinking</code> 需要和<code>Code shrinking</code> 一起使用。在代码中删除所有未使用的代码后，<code>Resource shrinking</code>才可以知道哪些资源APK程序仍然使用，你必须先删除未使用的代码，Resource才会成为无用的，从而被清除掉。</p>
<p>添加<code>shrinkResources</code> <code>true</code>属性在你的 build.gradle文件中，相应代码块如下：</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            shrinkResources <span class="literal">true</span></div><div class="line">            minifyEnabled <span class="literal">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="symbol">'proguard</span>-android.txt'),</div><div class="line">                    <span class="symbol">'proguard</span>-rules.pro'</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>resource shrinker</code> 目前还不支持移除定义在values/目录下的资源文件(strings,dimensions,styles,colors),因为Android Asset Packaging Tool（AAPT）不允许Gradle Plugin指定预定义的版本资源<a href="https://code.google.com/p/android/issues/detail?id=70869" target="_blank" rel="external">[issue 70869]</a></p>
</blockquote>
<h3 id="指定要忽略的资源文件"><a href="#指定要忽略的资源文件" class="headerlink" title="指定要忽略的资源文件"></a>指定要忽略的资源文件</h3><p>如果我们希望保留或丢弃特定的资源，需要在项目中创建一个XML文件，并使用<code>resources</code>标签，并指定每个资源保存在工具中<code>tools:keep</code>和每个资源在工具中丢弃 <code>tools:discard</code>。两个属性都可以使用逗号(,)分隔符声明资源名称列表。也可以使用* 作为匹配符，匹配名称。</p>
<p>相应代码块如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></div><div class="line">    <span class="attr">tools:keep</span>=<span class="string">"@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*"</span></div><div class="line">    <span class="attr">tools:discard</span>=<span class="string">"@layout/unused2"</span> /&gt;</div></pre></td></tr></table></figure>
<p>需要在项目resources目录保存res/raw/keep.xml文件，build的时候该文件不会被打包到APK里面。</p>
<h3 id="启用严格的检测"><a href="#启用严格的检测" class="headerlink" title="启用严格的检测"></a>启用严格的检测</h3><p>通常情况下，<code>resource shrinker</code>可以准确地确定资源使用。如果你使用<code>Resources.getIdentifier()</code>动态获取指定资源的Id，在默认情况下，这样资源具有匹配名称的格式为潜在的使用，无法去除。</p>
<p>例如，下面的代码将导致所有img_前缀的资源都无法去除。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">String name</span> = String.format(<span class="string">"img_%1d"</span>, angle + 1);</div><div class="line"><span class="attribute">res</span> = getResources().getIdentifier(name, <span class="string">"drawable"</span>, getPackageName());</div></pre></td></tr></table></figure>
<p><code>resource shrinker</code> 也通过搜索代码中是否包含资源名来判断是否在build的时候删除。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></div><div class="line">    <span class="attr">tools:shrinkMode</span>=<span class="string">"strict"</span> /&gt;</div></pre></td></tr></table></figure>
<p>在 resource 文件中指定 shrinkMode，你可以指定 Gradle 在处理该资源文件时候的方式，默认的值为 safe，你也可以将它指定为 strict（只会保留有明确引用的资源，以及处理被 <code>tools:keep</code> 和 <code>tools:discard</code> 标注的资源）</p>
<p>在后面<strong>查看资源回收</strong>情况，我们会讲到，会遇到有些xml 无法被清除的问题，使用shrinkMode可以解决这个问题。</p>
<h3 id="清除未使用的替代资源"><a href="#清除未使用的替代资源" class="headerlink" title="清除未使用的替代资源"></a>清除未使用的替代资源</h3><p>Gradle <code>resource shrinker</code> 只删除你在代码中未使用资源，这意味着它不会删除不同的设备配置的可替代资源。如果有必要，你可以使用<code>Android Gradle plugin</code> 的<code>resconfigs</code>属性删除替代资源文件。</p>
<p>例如：我们项目中适配10种国家语言，而项目依赖了v7、v4等其他support包里面包含20种国家语言，那么我们可以通过resconfigs 删除剩余的可替代资源文件，这对于我们APK大小可减少了不少，</p>
<p>以下代码说明了如何限制你的语言资源，只是英语和法语：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class">android </span>&#123;</div><div class="line">    <span class="class">defaultConfig </span>&#123;</div><div class="line">        ...</div><div class="line">        resConfigs <span class="string">"en"</span>, <span class="string">"fr"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像上面那样通过<code>resconfig</code>属性指定的语言。未指定的语言的任何资源都被删除。</p>
<p>同样的图片资源我们也可以这么做，例如：我们提供一套xxhdpi的图片资源，其他的都过滤清除掉，这样大量清除了support，其他第三方library的资源文件，关于这个待会我们在后面会说。</p>
<h3 id="合并重复的资源"><a href="#合并重复的资源" class="headerlink" title="合并重复的资源"></a>合并重复的资源</h3><p>默认情况下，Gradle也将同名的资源，比如相同的名字，可能是在不同的资源文件夹下，这样子不能通过shrinkResources属性来去除。</p>
<p>只有当两个或多个文件共享相同的资源名称、类型和限定符时才发生资源合并，关于资源的合并优先级如下：</p>
<p>Gradle 主要从以下位置合并资源：</p>
<ul>
<li>src/main/res/ 主要资源</li>
<li>Gradle 使用variant(build type 和 build flavors) </li>
<li>Library的依赖使用</li>
</ul>
<p>Gradle合并重复资源优先顺序为：</p>
<p>Dependencies → Main → Build flavor → Build type</p>
<p>例如：如果一个重复的资源在你的mian res中和一个Build flavor指定 ，Gradle 会优先选择Build flavor</p>
<h3 id="查看资源回收"><a href="#查看资源回收" class="headerlink" title="查看资源回收"></a>查看资源回收</h3><p>当你Gradle <code>resource shrinker</code>，Gradle Console 输出日志，移除APK资源的信息。例如:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">:android:shrinkDebugResources</span></div><div class="line">Removed unused resources: Binary resource data reduced from 2570KB to 1711KB: Removed 33%</div><div class="line"><span class="meta">:android:validateDebugSigning</span></div></pre></td></tr></table></figure>
<p>APK构建完成后会Gradle会生成一个resource.txt 在 <module-name>/build/outputs/mapping/release/ 中，这个文件包括详细信息，如资源参考其他资源和使用或删除资源的详细信息等。</module-name></p>
<p>例如：找出为什么<code>@drawable/ic_plus_anim_016</code>，仍然包含在你的APK中，在resource.txt 搜索该文件名，你可能会发现它是被另一个资源引用，如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">16<span class="selector-pseudo">:25</span><span class="selector-pseudo">:48.005</span> <span class="selector-attr">[QUIET]</span> <span class="selector-attr">[system.out]</span> @<span class="keyword">drawable</span>/<span class="keyword">add_schedule_fab_icon_anim</span> : reachable=true</div><div class="line"><span class="number">16</span>:<span class="number">25</span>:<span class="number">48.009</span> [QUIET] [system.out]     @drawable/ic_plus_anim_016</div></pre></td></tr></table></figure>
<p>现在需要知道为什么<code>@drawable/add_schedule_fab_icon_anim</code> 仍然在使用，搜索我们可以知道应该有代码引用着<code>add_schedule_fab_icon_anim</code>。</p>
<p>如果你不使用严格的检查（就是上面讲的<code>shrinkMode</code>），同样的我们如果我们在drawable中使用了字符串’#FFFFFF‘ 这样的使用<code>resource shrinker</code>也不能将他移除在APK中，通常我们可以在Gradle Console中看到以下信息：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>:<span class="number">32</span>:<span class="number">50.590</span> [QUIET] [<span class="keyword">system</span>.out] Marking drawable:ic_plus_anim_016:<span class="number">2130837506</span></div><div class="line">    used because <span class="keyword">it</span> <span class="built_in">format</span>-<span class="keyword">string</span> matches <span class="keyword">string</span> pool <span class="built_in">constant</span> ic_plus_anim_%<span class="number">1</span>$d.</div></pre></td></tr></table></figure>
<p>那么这种情况我们如何解决呢，可以通过以下方法来清理：</p>
<ul>
<li>使用tools:discard，在 tools:shrinkMode=”strict” 的时候生效，指定某资源文件需要删除。在你确定该资源文件无效的时候使用。</li>
<li><p>利用Lint找出未使用的资源并清理掉</p>
<blockquote>
<p>在Android Studio中打开“Analyze” 然后选择”Inspect Code…”，范围选择整个项目，然后点击”OK”</p>
</blockquote>
</li>
</ul>
<p>到这里APK的大小又小了不少。</p>
<h2 id="使用APK-Splits构建APK"><a href="#使用APK-Splits构建APK" class="headerlink" title="使用APK Splits构建APK"></a>使用APK Splits构建APK</h2><p>虽然我们上面很好的使用了<code>resource shrinker</code>可以回收一些未使用的资源(v7、v4、google Service 等Libarry资源)，但有些资源仍然未被清除。</p>
<p>例如：那些未使用的多套替代资源，或者是library内部隐患着引用着的资源而我们却没有使用到。或者是我们要根据用户的手机去提供不同版本的APK，如分辨率(xxhdpi,mhdpi等)，so库等。那么我们可以使用<code>APK Splits</code>大大的减少一些无用的资源，这里我们主要参考了<a href="http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits" target="_blank" rel="external">http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits</a> 文档。</p>
<p><code>APK Splits</code>比起使用 flavors，能让应用程序更有效地构建一些形式的多个apk。</p>
<p>多 apk 只支持以下类型：</p>
<ul>
<li>屏幕密度</li>
<li>ABI</li>
</ul>
<p>使用新的<code>APK Splits</code>，构建同一个应用程序的hdpi版本和mdpi版本，能够共享很多的任务 （如 javac，dx，proguard）。此外，它会被认为是一个单一的variant，并且同一个测试程序将会被用来测试每​​个多APK。</p>
<h3 id="按屏幕密度拆分"><a href="#按屏幕密度拆分" class="headerlink" title="按屏幕密度拆分"></a>按屏幕密度拆分</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">android</span> &#123;</div><div class="line">  ...</div><div class="line">  splits &#123;</div><div class="line">    density &#123;</div><div class="line">      <span class="literal">enable</span> <span class="keyword">true</span></div><div class="line">      <span class="literal">exclude</span> <span class="string">"ldpi"</span>, <span class="string">"tvdpi"</span>, <span class="string">"xxxhdpi"</span></div><div class="line">      compatibleScreens <span class="string">'small'</span>, <span class="string">'normal'</span>, <span class="string">'large'</span>, <span class="string">'xlarge'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>enable： 启用屏幕密度拆分机制</li>
<li>exclude： 默认情况下所有屏幕密度都包括在内，你可以移除一些密度。</li>
<li>include： 表示要包括哪些屏幕密度</li>
<li>reset()： 重置屏幕密度列表为只包含一个空字符串 （这能够实现，在与include一起使用时可以表示使用哪一个屏幕密度，而不是要忽略哪一些屏幕密度）</li>
<li>compatibleScreens：表示兼容屏幕的列表。这将会注入到manifest中匹配的 <compatible-screens> <screen> 节点。这个设置是可选的。</screen></compatible-screens></li>
</ul>
<p>构建完成后可以在out/apk/目录下看到多个版本的APK</p>
<h3 id="按-ABI-拆分"><a href="#按-ABI-拆分" class="headerlink" title="按 ABI 拆分"></a>按 ABI 拆分</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">android</span> &#123;</div><div class="line">  ...</div><div class="line">  splits &#123;</div><div class="line">    abi &#123;</div><div class="line">      <span class="literal">enable</span> <span class="keyword">true</span></div><div class="line">      reset()</div><div class="line">      <span class="literal">include</span> <span class="string">'x86'</span>, <span class="string">'armeabi-v7a'</span>, <span class="string">'mips'</span></div><div class="line">      universalApk <span class="keyword">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>enable： 启用ABI拆分机制</li>
<li>exclude： 默认情况下所有ABI都包括在内，你可以移除一些ABI。</li>
<li>include：指明要包含哪些ABI</li>
<li>reset()：重置ABI列表为只包含一个空字符串（这可以实现，在与include一起使用来可以表示要使用哪一个ABI，而不是要忽略哪一些ABI）</li>
<li>universalApk：指示是否打包一个通用版本（包含所有的ABI）。默认值为 false。</li>
</ul>
<p>例如：我们项目主要提供xxhdpi的图片资源，而项目中引用到了很多第三方库(v7、v4、google Service 等Libarry资源)我们无法使用到，那么我们可以通过这种方法来去除那些资源。这样我们的APK又减小了非常多。</p>
<h3 id="使用多版本的APK"><a href="#使用多版本的APK" class="headerlink" title="使用多版本的APK"></a>使用多版本的APK</h3><p><code>Multiple APK Support</code>是一个在Google Play，可以发布不同的应用程序，分别针对不同的设备配置特征。每个APK是一个完整的、独立的应用程序版本，但他们分享在Google Play相同的应用程序清单，必须共享相同的包名和与签名。Google Play 会自动给你匹配相应的APK，这样我们的APK 就可以是分不同版本构建需要资源文件，从而减小APK的大小。</p>
<p>通过发布有多个APK，我们可以：</p>
<ul>
<li>支持不同OpenGL的APK</li>
<li>支持不同的屏幕尺寸和密度的APK</li>
<li>支持不同的设备功能的APK</li>
<li>支持不同的平台版本的APK</li>
<li><p>支持不同的CPU架构，每个apk（如ARM、x86，MIPS等)的APK</p>
<p>更多相关信息请参考<a href="https://developer.android.com/google/play/publishing/multiple-apks.html#Concepts" target="_blank" rel="external">https://developer.android.com/google/play/publishing/multiple-apks.html#Concepts</a></p>
</li>
</ul>
<p>目前我们基于这个方案做了不同屏幕的APK。</p>
<h2 id="资源动态加载"><a href="#资源动态加载" class="headerlink" title="资源动态加载"></a>资源动态加载</h2><p>我们可以在项目中使用资源动态加载形式，例如：表情，语言，离线库等资源动态加载，减小APK的大小。</p>
<h2 id="依赖库优化"><a href="#依赖库优化" class="headerlink" title="依赖库优化"></a>依赖库优化</h2><ul>
<li>如果应用支持的最低版本是API14，那就不要使用android support库，或者分开使用android support库，用哪个引入哪个库(android-support-ui/android-support-core 等)虽然现在支持还不太好，Google servie 也是如此。</li>
<li>使用更轻量级的库代替，或者优化library的大小，不然自己写更好。</li>
<li>删除armable-v7包下的so、删除x86包下的so，基本上armable的so也是兼容armable-v7的，armable-v7a的库会对图形渲染方面有很大的改进，不过最好的是根据上面我们说的提供多版本APK，对不同的平台精简，再或者动态的加载so。</li>
<li>使用H5编写界面，图片云端获取</li>
<li>资源缓存库不放在assets下，云端获取更新。</li>
</ul>
<h2 id="支持插件化"><a href="#支持插件化" class="headerlink" title="支持插件化"></a>支持插件化</h2><p>未来对于一些独立业务模块，可以做成插件化动态加载，用户需要使用时，只需下载少部分插件。</p>
<h2 id="使用ReDex优化"><a href="#使用ReDex优化" class="headerlink" title="使用ReDex优化"></a>使用ReDex优化</h2><p>ReDex是Facebook开源一个减小安卓app大小以提高性能的工具，内嵌以及清除僵尸代码这样的优化来减小字节码，主要是对Dex进行了优化，能让APK 运行更快，不过需要多测试是否会崩溃。</p>
<p>教程很简单具体更详细的内容请参考：<br><a href="https://code.facebook.com/posts/998080480282805/open-sourcing-redex-making-android-apps-smaller-and-faster/" target="_blank" rel="external">https://code.facebook.com/posts/998080480282805/open-sourcing-redex-making-android-apps-smaller-and-faster/</a></p>
<p>github地址：<br><a href="https://github.com/facebook/redex.git" target="_blank" rel="external">https://github.com/facebook/redex.git</a></p>
<p>关于APK瘦身我们就总结到这了，应该还有很多更好的方案，若有错漏，欢迎补充。</p>
<blockquote>
<ul>
<li>author：傅声华(Silver)</li>
<li>phone：18911630016</li>
<li>e-mail:silverfu@tcl.com</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;让我们的apk文件尽可能更小，移除那些未使用的代码和资源文件。本章节介绍了如何做到让APK更小，性能更好，下载转化率会更高，以及如何指定在构建APK过程中保留或移除项目中的代码和资源，在我们还没有分析APK大小之前，项目中存在一些资源放置处理不当，没有统一的规范，依赖管理不
    
    </summary>
    
      <category term="性能优化" scheme="http://fushenghua.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>app安全之Apk完整性校验</title>
    <link href="http://fushenghua.github.io/archives/a72a1e10.html"/>
    <id>http://fushenghua.github.io/archives/a72a1e10.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-05-23T02:51:39.075Z</updated>
    
    <content type="html"><![CDATA[<p>APK 完整性校验，虽然很难做到绝对的安全，但能提高应用的安全性和破解难度,下面简单记录一下Apk完整性的校验方案。</p>
<h2 id="一、认识APK安全性"><a href="#一、认识APK安全性" class="headerlink" title="一、认识APK安全性"></a>一、认识APK安全性</h2><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>可以通过修改客户端文件篡改客户端行为。攻击者可以让客户端显示自己制作的钓鱼网站，偷取用户信息</p>
<h2 id="二、完整性校验原理"><a href="#二、完整性校验原理" class="headerlink" title="二、完整性校验原理"></a>二、完整性校验原理</h2><h3 id="完整性校验的几种方式"><a href="#完整性校验的几种方式" class="headerlink" title="完整性校验的几种方式"></a>完整性校验的几种方式</h3><ol>
<li>CRC校验</li>
<li>MD5值校验</li>
<li>SHA1值校验</li>
</ol>
<h3 id="常见android完整性检测"><a href="#常见android完整性检测" class="headerlink" title="常见android完整性检测"></a>常见android完整性检测</h3><ol>
<li>检测签名</li>
<li>校验classes.dex</li>
<li>校验整个apk</li>
</ol>
<h4 id="检测签名"><a href="#检测签名" class="headerlink" title="检测签名"></a>检测签名</h4><p>Android对每一个Apk文件都会进行签名，在Apk文件安装时，系统会对其签名信息进行比对，判断程序的完整性，从而决定该Apk文件是否可以安装，在一定程度上达到安全的目的。</p>
<ol>
<li>MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。</li>
<li>CERT.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。</li>
<li>CERT.RSA文件中保存了公钥、所采用的加密算法等信息。系统对签名文件进行解密，所需要的公钥就是从这个文件里取出来的。<br>这三个文件在apk META-INFO文件夹</li>
</ol>
<p>结论：从上面的总结可以看出，META-INFO里面的说那个文件环环相扣，从而保证Android程序的安全性。（只是防止开发者的程序不被攻击者修改，如果开发者的公私钥对对攻击者得到或者开发者开发出攻击程序，Android系统都无法检测出来。）</p>
<p>虽然系统通过以上方式可以防止，但如果是root的手机就不安全了，建议通过服务器来校验，</p>
<h4 id="校验classes-dex"><a href="#校验classes-dex" class="headerlink" title="校验classes.dex"></a>校验classes.dex</h4><p><strong>用crc32对classes.dex文件的完整性进行校验</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="meta">@Override</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(BundlesavedInstanceState)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"> </div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"> </div><div class="line">    String apkPath = getPackageCodePath();</div><div class="line"> </div><div class="line">    Long dexCrc = Long.parseLong(getString(R.string.classesdex_crc));</div><div class="line">    <span class="comment">//建议将dexCrc值放在服务器做校验</span></div><div class="line"> </div><div class="line">    <span class="keyword">try</span></div><div class="line"> </div><div class="line">    &#123;</div><div class="line"> </div><div class="line">        ZipFile zipfile = <span class="keyword">new</span> ZipFile(apkPath);</div><div class="line"> </div><div class="line">        ZipEntry dexentry = zipfile.getEntry(<span class="string">"classes.dex"</span>);</div><div class="line"> </div><div class="line">        Log.i(<span class="string">"verification"</span>,<span class="string">"classes.dexcrc="</span>+dexentry.getCrc());</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(dexentry.getCrc() != dexCrc)&#123;</div><div class="line"> </div><div class="line">        Log.i(<span class="string">"verification"</span>,<span class="string">"Dexhas been modified!"</span>);</div><div class="line"> </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line"> </div><div class="line">        Log.i(<span class="string">"verification"</span>,<span class="string">"Dex hasn't been modified!"</span>);</div><div class="line"> </div><div class="line">        &#125;</div><div class="line"> </div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"> </div><div class="line">     <span class="comment">// TODO Auto-generated catch block</span></div><div class="line"> </div><div class="line">     e.printStackTrace();</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="校验整个apk"><a href="#校验整个apk" class="headerlink" title="校验整个apk"></a>校验整个apk</h4><p>用哈希值对整个apk完整性进行校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="meta">@Override</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(BundlesavedInstanceState)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"> </div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"> </div><div class="line">   </div><div class="line"> String apkPath = getPackageCodePath();</div><div class="line"> </div><div class="line">     MessageDigest msgDigest = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line"> </div><div class="line">        msgDigest = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> byteCount;</div><div class="line"> </div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(apkPath));</div><div class="line"> </div><div class="line">        <span class="keyword">while</span> ((byteCount = fis.read(bytes)) &gt; <span class="number">0</span>)</div><div class="line"> </div><div class="line">        &#123;</div><div class="line"> </div><div class="line">            msgDigest.update(bytes, <span class="number">0</span>, byteCount);</div><div class="line"> </div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, msgDigest.digest());</div><div class="line"> </div><div class="line">        String sha = bi.toString(<span class="number">16</span>);</div><div class="line"> </div><div class="line">        fis.close();</div><div class="line"> </div><div class="line">        <span class="comment">//这里添加从服务器中获取哈希值然后进行对比校验</span></div><div class="line"> </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> </div><div class="line">            e.printStackTrace();</div><div class="line"> </div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将把crc值和sha1值放在服务器做处理，做个记录。</p>
<p>更多Android 之美，请阅读<a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external">《Android 之美 从0到1 – 高手之路》</a>系列文章</p>
<blockquote>
<p>水平有限，若有错漏，欢迎指正，批评，如需转载，请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a>，谢谢！</p>
<p>作者：fuchenxuan<br>出处：<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a><br>欢迎访问我的个人站点：<a href="http://fuchenxuan.cn" target="_blank" rel="external">http://fuchenxuan.cn</a><br>转载请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a></p>
</blockquote>
<p><a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160608234402229" alt="Android 之美 从0到1"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;APK 完整性校验，虽然很难做到绝对的安全，但能提高应用的安全性和破解难度,下面简单记录一下Apk完整性的校验方案。&lt;/p&gt;
&lt;h2 id=&quot;一、认识APK安全性&quot;&gt;&lt;a href=&quot;#一、认识APK安全性&quot; class=&quot;headerlink&quot; title=&quot;一、认识AP
    
    </summary>
    
      <category term="安全" scheme="http://fushenghua.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>版本管理发布流程</title>
    <link href="http://fushenghua.github.io/archives/375726b.html"/>
    <id>http://fushenghua.github.io/archives/375726b.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-20T05:25:03.655Z</updated>
    
    <content type="html"><![CDATA[<p>为了在多个版本中并行开发，提高开发效率，保证各个版本和各个环境（开发、测试、主干）的独立，避免相互影响，减少最终发布时合并主干出现冲突的概率，降低冲突处理的难度，那么在团队开发过程中就需要一定的规范流程。</p>
<h3 id="版本命名规范"><a href="#版本命名规范" class="headerlink" title="版本命名规范"></a>版本命名规范</h3><p>软件版本号由四部分组成，第一个1为主版本号，第二个1为子版本号，第三个1为阶段版本号，第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有5种，分别为：base、alpha、beta、RC、release。例如：1.1.1.051021_beta。</p>
<h4 id="版本号修改规则"><a href="#版本号修改规则" class="headerlink" title="版本号修改规则"></a>版本号修改规则</h4><p>⑴ 主版本号(1)<br>当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。<br>⑵ 子版本号(1)<br>相对于主版本号而言，子版本号升级对应的是软件功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。<br>⑶ 阶段版本号(1)<br>一般是 Bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本号由项目经理决定是否修改。<br>⑷ 日期版本号(051021)<br>用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。<br>⑸ 希腊字母版本号(beta)<br>此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时需要修改此版本号。此版本号由项目决定是否修改。</p>
<h4 id="软件版本阶段说明"><a href="#软件版本阶段说明" class="headerlink" title="软件版本阶段说明"></a>软件版本阶段说明</h4><p>⑴ Base：<br>此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。<br>⑵ α（Alpha）版：内测版。<br>软件的初级版本，表示该软件在此阶段以实现软件功能为主，通常只在软件开发者 内部交流，或者专业测试人员测试用，一般而言，该版本软件的Bug较多，需要继续修改，是测试版本。测试人员提交Bug经开发人员修改确认之后，发布到测试网址让测试人员测试，此时可将软件版本标注为alpha版。<br>⑶ β（Beta）版：公测版。<br>该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI，供专业爱好者大规模测试用。<br>⑷ RC 版：<br>是 Release Candidate 的缩写，意思是发布倒计时，候选版本，该版本已经相当成熟了，完成全部功能并清除大部分的BUG，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。<br>⑷ Release 版：<br>该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。</p>
<h4 id="版本号修改举例说明"><a href="#版本号修改举例说明" class="headerlink" title="版本号修改举例说明"></a>版本号修改举例说明</h4><p>比如版本号为：1.0.0.0321_alpha ，此时为内部测试阶段<br>⑴ 开发人员修复了测试人员提交的bug并经测试人员测试验证关闭bug之后，发布到外网时，此时就进入了软件的下一个阶段，版本号可改为：1.0.0.0321_beta ，如当前日期跟上一个版本号的日期不一样，版本号可改为：1.0.0.0322_beta。<br>⑵ 如果修复了一些重大Bug 并按照流程发布到外网时就可发布一个修订版，如1.0.1.0322_beta，日期为发布的当前日期。<br>⑶ 如果对软件进行了一些功能上的改进或增强，进行了一些局部变动的时候要修改次版本号，如：1.1.0.0322_beta（上一级有变动时，下级要归零）。<br>⑷ 当功能模块有较大变动，增加模块或整体架构发生变化时要修改主版本号，如新增加了退款功能，则版本号要改为：2.0.0.0322_beta 。<br>⑸ 紧急情况：如果bug比较紧急可跳过一般流程，由开发人员尽快修复bug，测试确认之后直接发布该版本的beta版。</p>
<h4 id="APK-文件命名"><a href="#APK-文件命名" class="headerlink" title="APK 文件命名"></a>APK 文件命名</h4><p>appName_版本号，即中间用“下划线”分割。</p>
<h2 id="持续集成流程"><a href="#持续集成流程" class="headerlink" title="持续集成流程"></a>持续集成流程</h2><p>引用自百科的话来说，持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
<h2 id="项目自动化流程"><a href="#项目自动化流程" class="headerlink" title="项目自动化流程"></a>项目自动化流程</h2><p>在没有自动化的开发过程中，很多事就需要我们人为去做，那就增长我们的时间成本，而且难免会有疏忽的一些问题，比如某个配置文件忘改了，哪个版本出问题，代码的集成，重复构建等一些耗时且易于犯错的问题。</p>
<p>于是我们引入一些自动化的Java构建工具：</p>
<h3 id="Apache-Ant"><a href="#Apache-Ant" class="headerlink" title="Apache Ant"></a>Apache Ant</h3><p>Apache Ant，是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于Java环境中的软件开发。由Apache软件基金会所提供。默认情况下，它的buildfile(XML文件)名为build.xml。每一个buildfile含有一个<project>和至少一个预设的<target>，这些targets包含许多task elements。每一个task element有一个用来被参考的id，此id必须是唯一的</target></project></p>
<p>build.xml 示例：<br><figure class="highlight plain"><figcaption><span>version="1.0" ?> </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;project name=&quot;Hello World&quot; default=&quot;execute&quot;&gt;</div><div class="line"></div><div class="line">	&lt;target name=&quot;init&quot;&gt;</div><div class="line">		&lt;mkdir dir=&quot;build/classes&quot;/&gt;</div><div class="line">		&lt;mkdir dir=&quot;dist&quot;/&gt;</div><div class="line">	&lt;/target&gt;</div><div class="line">	&lt;target name=&quot;compile&quot; depends=&quot;init&quot;&gt;</div><div class="line">		&lt;javac srcdir=&quot;src&quot; destdir=&quot;build/classes&quot;/&gt;</div><div class="line">	&lt;/target&gt;</div><div class="line">	</div><div class="line">	&lt;target name=&quot;compress&quot; depends=&quot;compile&quot;&gt;</div><div class="line">	        &lt;jar destfile=&quot;dist/HelloWorld.jar&quot; basedir=&quot;build/classes&quot;  /&gt;</div><div class="line">	&lt;/target&gt;</div><div class="line"></div><div class="line">	&lt;target name=&quot;execute&quot; depends=&quot;compile&quot;&gt;</div><div class="line">		&lt;java classname=&quot;HelloWorld&quot; classpath=&quot;build/classes&quot;/&gt;</div><div class="line">	&lt;/target&gt;</div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Apache-Maven"><a href="#Apache-Maven" class="headerlink" title="Apache Maven"></a>Apache Maven</h3><p>Apache Maven，是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。<br>Maven也可被用于构建和管理各种项目，例如C#，Ruby，Scala和其他语言编写的项目。Maven曾是Jakarta项目的子项目，现为由Apache软件基金会主持的独立Apache项目</p>
<p>Maven项目使用项目对象模型（Project Object Model，POM）来配置。<br>项目对象模型存储在名为 pom.xml 的文件中。<br>以下是一个简单的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">  &lt;!-- model version is always 4.0.0 for Maven 2.x POMs --&gt;</div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line">  </div><div class="line">  &lt;!-- project coordinates, i.e. a group of values which</div><div class="line">       uniquely identify this project --&gt;</div><div class="line">  </div><div class="line">  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;my-app&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;1.0&lt;/version&gt;</div><div class="line"></div><div class="line">  &lt;!-- library dependencies --&gt;</div><div class="line">  </div><div class="line">  &lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">    </div><div class="line">      &lt;!-- coordinates of the required library --&gt;</div><div class="line">      </div><div class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</div><div class="line">      </div><div class="line">      &lt;!-- this dependency is only used for running and compiling tests --&gt;</div><div class="line">      </div><div class="line">      &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">      </div><div class="line">    &lt;/dependency&gt;</div><div class="line">  &lt;/dependencies&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>引自<a href="https://zh.wikipedia.org/wiki/Apache_Maven介绍" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Apache_Maven介绍</a></p>
<p>目前JavaEE使用Apache_Maven的比较多，而我们选择了Android Studio 内置的封装布署工具，拥有以上工具中优秀特性并且更棒的工具Gradle。</p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML。[2]<br>当前其支持的语言限于Java、Groovy和Scala[3]，计划未来将支持更多的语言。</p>
<h4 id="使用-Gradle-的优势"><a href="#使用-Gradle-的优势" class="headerlink" title="使用 Gradle 的优势"></a>使用 Gradle 的优势</h4><pre><code>•    自动处理包相依关系 - 取自 Maven Repos 的概念
•    自动处理布署问题 - 取自 Ant 的概念
•    条件判断写法直觉 - 使用 Groovy 语言
</code></pre><p>过去 Java 开发者常用 Maven 和 Ant 等工具进行封装布署的自动化，或是两者兼用，不过这两个包彼此有优缺点，如果频繁改变相依包版本，使用 Ant 相当麻烦，如果琐碎工作很多，Maven 功能不足，而且两者都使用 XML 描述，相当不利于设计 if、switch 等判段式，即使写了可读性也不佳，而 Gradle 改良了过去 Maven、Ant 带给开发者的问题，至今也成为 Android Studio 内置的封装布署工具。</p>
<h2 id="代码检测流程"><a href="#代码检测流程" class="headerlink" title="代码检测流程"></a>代码检测流程</h2><p>在我们日常开发过程中，使用静态代码检查工具自动进行代码检查，对软件开发者来讲是有利的事情，因为这些工具相比人工方式，能更快捷的查找软件存在的缺陷。但是，在很多情况下，这些工具并没用被开发者所广泛采用。</p>
<p>尽管在我们开发中编译和测试的结果给出了一些产品健康状态的基本报告，但没有提供代码质量的基本报告，也没有任何地方可以查看到我们开发代码质量，产品质量的趋势，来帮助我们发现问题提升产品质量，我们公司内部构建平台会对代码质量，产品质量做一些分析，来推进产品的前进。</p>
<h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><p>在Java中有很多免费和商业的代码覆盖率工具，大多数这些工具都可以集成在我们的构建平台上。这里我们列举几个Gradle比较流行的代码覆盖率工具。</p>
<h4 id="Cobertura"><a href="#Cobertura" class="headerlink" title="Cobertura"></a>Cobertura</h4><p><a href="http://cobertura.sourceforge.net/" target="_blank" rel="external">Cobertura</a> 是一种开源工具，它通过检测基本的代码，并观察在测试包运行时执行了哪些代码和没有执行哪些代码，来测量测试覆盖率。除了找出未测试到的代码并发现 bug 外，Cobertura 还可以通过标记无用的、执行不到的代码来优化代码。</p>
<h4 id="Emma"><a href="#Emma" class="headerlink" title="Emma"></a>Emma</h4><p><a href="http://emma.sourceforge.net/" target="_blank" rel="external">EMMA</a> 是一个开源、面向 Java 程序测试覆盖率收集和报告工具。它通过对编译后的 Java 字节码文件进行插装，在测试执行过程中收集覆盖率信息，并通过支持多种报表格式对覆盖率结果进行展示。 EMMA 所使用的字节码插装不仅保证 EMMA 不会给源代码带来“脏代码”，还确保 EMMA 摆脱了源代码的束缚，这一特点使 EMMA 应用于功能测试成为了可能。</p>
<h4 id="Clover"><a href="#Clover" class="headerlink" title="Clover"></a>Clover</h4><p><a href="https://www.atlassian.com/software/clover" target="_blank" rel="external">Clover</a>是一款量度单元测试代码覆盖率（Code Coverage）的软件，用于检测Java单元测试是否完整覆盖代码中所有可能的路径，能够快速、准确地检测测试是否覆盖代码中的所有路径。</p>
<p>团队成员通过Code review来发现架构、逻辑设计方面、安全缺漏和一些潜在的bug，但随着项目业务的增长，Code review的过程难免也会疏忽很多潜在的bug等问题。</p>
<p>在我们工作中还有一些静态代码检查工具如<a href="http://checkstyle.sourceforge.net/" target="_blank" rel="external">Checkstyle</a>、<a href="http://findbugs.sourceforge.net/" target="_blank" rel="external">Findbugs</a>、<a href="http://pmd.sourceforge.net/" target="_blank" rel="external">PMD</a>等，将他们集成在我们的构建平台上，并成为我们构建流程中的一步骤。</p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>对于开发流程，在不同的项目团队中，开发流程不太一样，但大致可为：<br>每天下班前RD必须把今天工作代码全部提交到Git上。</p>
<p>####</p>
<ul>
<li>使用Jenkins CI ，每天定期会从Git上拉去最新代码，自定编译构建生成APK发出邮件，二维码等到产品维护人员的邮箱，并且将应用更新至公司内测分发平台。</li>
<li>编译构建成功，进行自动化测试、单元测试覆盖率（Cobertura、Emma或Clover等生成）、功能测试结果（如Selenium）、静态代码检查结果（Checkstyle、Findbugs、PMD等）</li>
<li>测试人员对产品进行test，测试中若有紧急问题也可以让开发人员可以随时修改提交代码。并且立即重新构建测试安装包。</li>
</ul>
<h2 id="打包和发布流程"><a href="#打包和发布流程" class="headerlink" title="打包和发布流程"></a>打包和发布流程</h2><p>以上版本管理发布流程只是参考指南，而不是具体规则。你可以根据自己实际情况来选择适合自己的版本管理发布流程或微调来满足自己的需要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了在多个版本中并行开发，提高开发效率，保证各个版本和各个环境（开发、测试、主干）的独立，避免相互影响，减少最终发布时合并主干出现冲突的概率，降低冲突处理的难度，那么在团队开发过程中就需要一定的规范流程。&lt;/p&gt;
&lt;h3 id=&quot;版本命名规范&quot;&gt;&lt;a href=&quot;#版本命名
    
    </summary>
    
      <category term="基础技能" scheme="http://fushenghua.github.io/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>git仓库迁移</title>
    <link href="http://fushenghua.github.io/archives/8e05eece.html"/>
    <id>http://fushenghua.github.io/archives/8e05eece.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-05-22T02:59:15.212Z</updated>
    
    <content type="html"><![CDATA[<p>最近又要把公司<code>Stash</code>上的项目在别部门一个私有仓库,平移到自己部门项目组的仓库，要求迁移的时候要保留已有的分支和以前的提交记录，类似的需求经常遇到，刚好做个记录。</p>
<p>1). 从原地址克隆一份裸版本库(纯仓库形式)，比如原本托管于 GitHub。</p>
<p><img src="/images/git--bare.png" alt="git--bare"></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">clone</span> <span class="title">--bare</span> git://github.com/username/project.git</div></pre></td></tr></table></figure>
<blockquote>
<p>–bare 创建的克隆版本库都不包含工作区，直接就是版本库的内容，这样的版本库称为裸版本库。</p>
</blockquote>
<p>2). 然后到新的 Git 服务器上创建一个新项目，比如 GitCafe。</p>
<p>3). 以镜像推送的方式上传代码到 GitCafe 服务器上。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">cd</span> <span class="selector-tag">project</span><span class="selector-class">.git</span></div><div class="line"><span class="selector-tag">git</span> <span class="selector-tag">push</span> <span class="selector-tag">--mirror</span> <span class="selector-tag">git</span>@<span class="keyword">stash</span>.<span class="keyword">com</span>/<span class="keyword">username</span>/<span class="keyword">newproject</span>.<span class="keyword">git</span></div></pre></td></tr></table></figure>
<p><img src="/images/cd-push.png" alt="cd-push"></p>
<blockquote>
<p>– mirror 克隆出来的裸版本对上游版本库进行了注册，这样可以在裸版本库中使用git fetch命令和上游版本库进行持续同步。</p>
</blockquote>
<p>4). 到新服务器 Stash 上找到 Clone 地址，直接 Clone 到本地就可以了。</p>
<p><img src="/images/git-clone.png" alt="git-clone"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">git</span> <span class="selector-tag">clone</span> <span class="selector-tag">git</span>@<span class="keyword">Stash</span>.<span class="keyword">com</span>/<span class="keyword">username</span>/<span class="keyword">newproject</span>.<span class="keyword">git</span></div></pre></td></tr></table></figure>
<p>通过这样的Git仓库迁移可以保留原版本库中的所有内容(<code>tag</code>,<code>branch</code>等记录)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又要把公司&lt;code&gt;Stash&lt;/code&gt;上的项目在别部门一个私有仓库,平移到自己部门项目组的仓库，要求迁移的时候要保留已有的分支和以前的提交记录，类似的需求经常遇到，刚好做个记录。&lt;/p&gt;
&lt;p&gt;1). 从原地址克隆一份裸版本库(纯仓库形式)，比如原本托管于 Gi
    
    </summary>
    
      <category term="基础技能" scheme="http://fushenghua.github.io/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>EventBus解析</title>
    <link href="http://fushenghua.github.io/archives/5f794a45.html"/>
    <id>http://fushenghua.github.io/archives/5f794a45.html</id>
    <published>2016-06-07T00:55:29.000Z</published>
    <updated>2018-04-23T09:17:45.027Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。</p>
<p>作为一个消息总线主要有三个组成部分：</p>
<p>事件（Event）：可以是任意类型的对象。通过事件的发布者将事件进行传递。</p>
<p>事件订阅者（Subscriber）：接收特定的事件。</p>
<p>事件发布者（Publisher）：用于通知 Subscriber 有事件发生。可以在任意线程任意位置发送事件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-42b1c487b9640141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>上图解释了整个EventBus的大概工作流程：事件的发布者（Publisher）将事件（Event）通过post()方法发送。EventBus内部进行处理，找到订阅了该事件（Event）的事件订阅者（Subscriber）。然后该事件的订阅者（Subscriber）通过onEvent()方法接收事件进行相关处理（关于onEvent()在EventBus 3.0中有改动，下面详细说明）。</p>
<h2 id="二、EventBus的简单使用"><a href="#二、EventBus的简单使用" class="headerlink" title="二、EventBus的简单使用"></a>二、EventBus的简单使用</h2><p>1、把EventBus依赖到项目</p>
<p>build.gradle添加引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'de.greenrobot:eventbus:3.0.0-beta1'</span></div></pre></td></tr></table></figure>
<p>2、构造事件（Event）对象。也就是发送消息类<br>每一个消息类，对应一种事件。这里我们定义两个消息发送类。后面讲解具体作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewsEvent</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToastEvent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、注册/解除事件订阅（Subscriber）</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus<span class="selector-class">.getDefault</span>()<span class="selector-class">.register</span>(this);<span class="comment">//注册事件 其中this代表订阅者</span></div></pre></td></tr></table></figure>
<p>具体注册了对什么事件的订阅，这个需要onEvent()方法来说明。在EventBus 3.0之前，onEvent()方法是用来接收指定事件（Event）类型对象，然后进行相关处理操作。在EventBus 3.0之后，onEvent()方法可以自定义方法名，不过要加入注解@Subscribe。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过register(this)来表示该订阅者进行了订阅，通过onToastEvent(ToastEvent event)表示指定对事件ToastEvent的订阅。到这里订阅就完成了。</p>
<p>需要注意的是：一般在onCreate()方法中进行注册订阅。在onDestory()方法中进行解除订阅。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>4 、发送消息<br>订阅已经完成，那么便可以发送订阅了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> ToastEvent(<span class="string">"Toast,发个提示，祝大家新年快乐！"</span>));</div></pre></td></tr></table></figure>
<p>那么onToastEvent(ToastEvent event)会收到事件，并弹出提示。</p>
<p>EventBus的基础使用流程就是这样的。</p>
<p>其实，EventBus还有好多其他的功能。下面我们一个个介绍。</p>
<h2 id="三、EventBus的进阶使用"><a href="#三、EventBus的进阶使用" class="headerlink" title="三、EventBus的进阶使用"></a>三、EventBus的进阶使用</h2><h5 id="1-线程模式ThreadMode"><a href="#1-线程模式ThreadMode" class="headerlink" title="1.线程模式ThreadMode"></a>1.线程模式ThreadMode</h5><p>当你接收的的事件后，如果处于非UI线程，你要更新UI怎么办？如果处于UI线程，你要进行耗时操作，怎么办?等等其他情况，通过ThreadMode统统帮你解决。</p>
<p>用法展示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@Subscribe</span>(threadMode = ThreadMode.MainThread)</div><div class="line">    public void  onNewsEvent(NewsEvent event)&#123;</div><div class="line">        String message = event<span class="selector-class">.getMessage</span>();</div><div class="line">        mTv_message<span class="selector-class">.setText</span>(message);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用起来很简单，通过<code>@Subscribe(threadMode = ThreadMode.MainThread)</code>即可指定。<br>下面具体介绍下ThreadMode。</p>
<p>关于ThreadMode，一共有四种模式PostThread，PostThread，BackgroundThread以及Async。</p>
<p><strong>PostThread：</strong>事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程。</p>
<p><strong>MainThread: </strong>事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的。</p>
<p><strong>BackgroundThread：</strong>如果事件是在UI线程中发布出来的，那么事件处理就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么事件处理直接在该子线程中执行。所有待处理事件会被加到一个队列中，由对应线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。</p>
<p><strong>Async：</strong>事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程。</p>
<h5 id="2-priority事件优先级"><a href="#2-priority事件优先级" class="headerlink" title="2.priority事件优先级"></a>2.priority事件优先级</h5><p>事件的优先级类似广播的优先级，优先级越高优先获得消息。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当多个订阅者（Subscriber）对同一种事件类型进行订阅时，即对应的事件处理方法中接收的事件类型一致，则<strong>优先级高（priority 设置的值越大），则会先接收事件进行处理；优先级低（priority 设置的值越小），则会后接收事件进行处理。</strong></p>
<p>除此之外，EventBus也可以终止对事件继续传递的功能。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">       Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">       EventBus.getDefault().cancelEventDelivery(event);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这样其他优先级比100低，并且订阅了该事件的订阅者就会接收不到该事件。</p>
<h5 id="3-EventBus黏性事件"><a href="#3-EventBus黏性事件" class="headerlink" title="3.EventBus黏性事件"></a>3.EventBus黏性事件</h5><p>EventBus除了普通事件也支持粘性事件。可以理解成：订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅的方法有所不同，需要注解中添加sticky = true。<br>用法展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(priority = <span class="number">100</span>,sticky = <span class="keyword">true</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToastEvent</span><span class="params">(ToastEvent event)</span></span>&#123;</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,event.getContent(),Toast.LENGTH_SHORT).show();</div><div class="line">        EventBus.getDefault().cancelEventDelivery(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这样，假设一个ToastEvent 的事件已经发布，此时还没有注册订阅。当设置了sticky = true，在ToastEvent 的事件发布后，进行注册。依然能够接收到之前发布的事件。</p>
<p>不过这个时候，发布事件的方式就改变了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().postSticky(<span class="keyword">new</span> ToastEvent(<span class="string">"Toast,发个提示，祝大家新年快乐！"</span>));</div></pre></td></tr></table></figure>
<p>我们如果不再需要该粘性事件我们可以移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().removeStickyEvent(ToastEvent.class);</div></pre></td></tr></table></figure>
<p>或者调用移除所有粘性事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().removeAllStickyEvents();</div></pre></td></tr></table></figure>
<h5 id="4-EventBus配置"><a href="#4-EventBus配置" class="headerlink" title="4.EventBus配置"></a>4.EventBus配置</h5><p>EventBus在2.3版本中添加了EventBuilder去配置EventBus的各方各面。</p>
<p>比如：如何去构建一个在发布事件时没有订阅者时保持沉默的EventBus。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventBus eventBus = EventBus.builder()</div><div class="line">.logNoSubscriberMessages(<span class="keyword">false</span>)</div><div class="line">.sendNoSubscriberEvent(<span class="keyword">false</span>)</div><div class="line">.build();</div></pre></td></tr></table></figure>
<p>通过上述设置，当一个事件没有订阅者时，不会输出log信息，也不会发布一条默认信息。</p>
<p>配置默认的EventBus实例，使用EventBus.getDefault()是一个简单的方法。获取一个单例的EventBus实例。EventBusBuilder也允许使用installDefaultEventBus方法去配置默认的EventBus实例。</p>
<p><strong>注意：不同的EventBus 的对象的数据是不共享的。通过一个EventBus 对象去发布事件，只有通过同一个EventBus 对象订阅事件，才能接收该事件。所以以上使用EventBus.getDefault()获得的都是同一个实例。</strong></p>
<h2 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h2><p><code>EventBus</code>实现了观察者模式，使用方法非常简单</p>
<p>下面文章主要讲解EventBus的实现原理。<br>EventBus内部有一个map，当register时往map中增加一个元素(key为事件的类型，value为观察者)，post时根据事件类型找到观察者之后，对其反射调用。<br>下面我们从register方法开始：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span>(<span class="params">Object <span class="keyword">object</span></span>) </span>&#123;</div><div class="line">    Multimap, EventHandler&gt; methodsInListener =</div><div class="line">        finder.findAllHandlers(<span class="keyword">object</span>);</div><div class="line">    handlersByTypeLock.writeLock().<span class="keyword">lock</span>();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      handlersByType.putAll(methodsInListener);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      handlersByTypeLock.writeLock().unlock();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用eventBus.register(new Event())时，会将事件类型及观察者(封装为EventHandler)放置在SetMultimap, EventHandler&gt; handlersByType中，这是一个线程安全的对象容器，卸载事件也是在这个容器中做移除操作。根据事件类型查找观察者时使用了策略模式，HandlerFindingStrategy finder做为策略接口，目前只有一个策略实现AnnotatedHandlerFinder(查找带有Subscribe注解的方法)。<br>有了这样一个map，调用post时只需要根据类型找到观察者就行了：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span>(<span class="params">Object <span class="keyword">event</span></span>) </span>&#123;</div><div class="line">    Set&gt; dispatchTypes = flattenHierarchy(<span class="keyword">event</span>.getClass());</div><div class="line"></div><div class="line">    boolean dispatched = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (Class eventType : dispatchTypes) &#123;</div><div class="line">      handlersByTypeLock.readLock().<span class="keyword">lock</span>();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Set wrappers = handlersByType.<span class="keyword">get</span>(eventType);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!wrappers.isEmpty()) &#123;</div><div class="line">          dispatched = <span class="literal">true</span>;</div><div class="line">          <span class="keyword">for</span> (EventHandler wrapper : wrappers) &#123;</div><div class="line">            enqueueEvent(<span class="keyword">event</span>, wrapper);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        handlersByTypeLock.readLock().unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dispatched &amp;&amp; !(<span class="keyword">event</span> instanceof DeadEvent)) &#123;</div><div class="line">      post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, <span class="keyword">event</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispatchQueuedEvents();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里查找到参数匹配的<code>EventHandler</code>后并没有立刻执行反射调用，而是分发到了事件队列<code>（ThreadLocal&gt; eventsToDispatch）</code>中，当所有事件分发完毕之后，事件队列做统一的事件消费。</p>
<p>下面是一些EventBus源码解析。</p>
<h3 id="getDefault"><a href="#getDefault" class="headerlink" title="getDefault()"></a>getDefault()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">                <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> defaultInstance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过上述代码可以得知，getDefault()中通过双检查锁（DCL）机制实现了EventBus的单例机制，获得了一个默认配置的EventBus对象。<br>下面我们继续看register()方法。</p>
<h3 id="register"><a href="#register" class="headerlink" title="register()"></a>register()</h3><p>在了解register()之前，我们先要了解一下EventBus中的几个关键的成员变量。方便对下面内容的理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Map&lt;订阅事件, 订阅该事件的订阅者集合&gt; */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</div><div class="line"></div><div class="line"><span class="comment">/** Map&lt;订阅者, 订阅事件集合&gt; */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</div><div class="line"></div><div class="line"><span class="comment">/** Map&lt;订阅事件类类型,订阅事件实例对象&gt;. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</div></pre></td></tr></table></figure>
<p>下面看具体的register()中执行的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">        <span class="comment">//订阅者类型</span></div><div class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass(); </div><div class="line">        <span class="comment">//判断该类是不是匿名类，如果是匿名累要使用反射</span></div><div class="line">        <span class="keyword">boolean</span> forceReflection = subscriberClass.isAnonymousClass();</div><div class="line">        <span class="comment">//获取订阅者全部的响应函数信息（即上面的onNewsEvent()之类的方法）</span></div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods =</div><div class="line">                subscriberMethodFinder.findSubscriberMethods(subscriberClass, forceReflection);</div><div class="line">        <span class="comment">//循环每一个事件响应函数，执行 subscribe()方法，更新订阅相关信息</span></div><div class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">            subscribe(subscriber, subscriberMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由此可见，register()第一步获取订阅者的类类型. 第二步,通过SubscriberMethodFinder类来解析订阅者类,获取所有的响应函数集合. 第三步,遍历订阅函数,执行 subscribe()方法，更新订阅相关信息。<br>关于 subscriberMethodFinder这里就不介绍了。先跟着线索，继续看subscribe()方法。<br>subscribe 函数分三步。</p>
<p>第一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//获取订阅的事件类型</span></div><div class="line">  Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line"> <span class="comment">//获取订阅该事件的订阅者集合</span></div><div class="line">  CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line"><span class="comment">//把通过register()订阅的订阅者包装成Subscription 对象</span></div><div class="line">  Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">  <span class="comment">//订阅者集合为空，创建新的集合，并把newSubscription 加入</span></div><div class="line">  <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</div><div class="line">      subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Subscription&gt;();</div><div class="line">      subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//集合中已经有该订阅者，抛出异常。不能重复订阅</span></div><div class="line">      <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">                  + eventType);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="comment">//把新的订阅者按照优先级加入到订阅者集合中。</span></div><div class="line">  <span class="keyword">synchronized</span> (subscriptions) &#123;</div><div class="line">      <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">          <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">              subscriptions.add(i, newSubscription);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>第二步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//根据订阅者，获得该订阅者订阅的事件类型集合</span></div><div class="line"> List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line"><span class="comment">//如果事件类型集合为空，创建新的集合，并加入新订阅的事件类型。</span></div><div class="line"> <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">     subscribedEvents = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</div><div class="line">     typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line"> &#125;</div><div class="line"><span class="comment">//如果事件类型集合不为空，加入新订阅的事件类型</span></div><div class="line"> subscribedEvents.add(eventType);</div></pre></td></tr></table></figure>
<p>第三步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该事件是stick=true。</span></div><div class="line"><span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">            <span class="comment">//响应订阅事件的父类事件</span></div><div class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">                <span class="comment">//循环获得每个stickyEvent事件</span></div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                    <span class="comment">//是该类的父类</span></div><div class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                         <span class="comment">//该事件类型最新的事件发送给当前订阅者。</span></div><div class="line">                        Object stickyEvent = entry.getValue();</div><div class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>由此可见，第一步：通过subscriptionsByEventType得到该事件类型所有订阅者信息队列，根据优先级将当前订阅者信息插入到订阅者队列subscriptionsByEventType中；</p>
<p>第二步：在typesBySubscriber中得到当前订阅者订阅的所有事件队列，将此事件保存到队列typesBySubscriber中，用于后续取消订阅；<br>第三步：检查这个事件是否是 Sticky 事件，如果是则从stickyEvents事件保存队列中取出该事件类型最后一个事件发送给当前订阅者。</p>
<p>到此，便完成了订阅功能。下面是订阅的具体流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-210bce35b60a5481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h3 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取该订阅者所有的订阅事件类类型集合.</span></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">            unsubscribeByEventType(subscriber, eventType);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 从typesBySubscriber删除该&lt;订阅者对象,订阅事件类类型集合&gt;</span></div><div class="line">        typesBySubscriber.remove(subscriber);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Log.e(<span class="string">"EventBus"</span>, <span class="string">"Subscriber to unregister was not registered before: "</span></div><div class="line">                + subscriber.getClass());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取订阅事件对应的订阅者信息集合.</span></div><div class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</div><div class="line">            Subscription subscription = subscriptions.get(i);</div><div class="line">            <span class="comment">// 从订阅者集合中删除特定的订阅者.</span></div><div class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</div><div class="line">                subscription.active = <span class="keyword">false</span>;</div><div class="line">                subscriptions.remove(i);</div><div class="line">                i --;</div><div class="line">                size --;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>unregister()方法比较简单，主要完成了subscriptionsByEventType以及typesBySubscriber两个集合的同步。</p>
<h3 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取当前线程的Posting状态.</span></div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    <span class="comment">// 获取当前线程的事件队列.</span></div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    <span class="comment">//将当前事件添加到其事件队列</span></div><div class="line">    eventQueue.add(event);</div><div class="line">    <span class="comment">//判断新加入的事件是否在分发中</span></div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">        postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 循环处理当前线程eventQueue中的每一个event对象.</span></div><div class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 处理完知乎重置postingState一些标识信息.</span></div><div class="line">            postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">            postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>post 函数会首先得到当前线程的 post 信息PostingThreadState，其中包含事件队列，将当前事件添加到其事件队列中，然后循环调用 postSingleEvent 函数发布队列中的每个事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> </span>&#123;</div><div class="line">   <span class="comment">//分发事件的类型</span></div><div class="line">    Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">   <span class="comment">//响应订阅事件的父类事件</span></div><div class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">        <span class="comment">//找出当前订阅事件类类型eventClass的所有父类的类类型和其实现的接口的类类型</span></div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h ++) &#123;</div><div class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">            <span class="comment">//发布每个事件到每个订阅者</span></div><div class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">    &#125;</div><div class="line">....................................</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 postSingleEventForEventType 函数发布每个事件到每个订阅者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState,</span></span></div><div class="line">                                            Class&lt;?&gt; eventClass) &#123;</div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 获取订阅事件类类型对应的订阅者信息集合.(register函数时构造的集合)</span></div><div class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">            postingState.event = event;</div><div class="line">            postingState.subscription = subscription;</div><div class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 发布订阅事件给订阅函数</span></div><div class="line">                postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                aborted = postingState.canceled;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postingState.event = <span class="keyword">null</span>;</div><div class="line">                postingState.subscription = <span class="keyword">null</span>;</div><div class="line">                postingState.canceled = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (aborted) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 postToSubscription 函数向每个订阅者发布事件。<br>postToSubscription 函数中会判断订阅者的 ThreadMode，从而决定在什么 Mode 下执行事件响应函数。这里就不贴源码了。后续还牵着到反射以及线程调度问题，这里就不展开了。<br>以上就是post的流程，下面是具体的post的流程图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-6567ff2602475d05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。&lt;/p&gt;
&lt;p&gt;作为一个消息总线主要有三个组成部分：&lt;/p&gt;
&lt;p&gt;事件（Event）：可以是任意类型的对象。通过事件的发布者将事件进行
    
    </summary>
    
      <category term="源码" scheme="http://fushenghua.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 之美 Android 进阶（一）</title>
    <link href="http://fushenghua.github.io/archives/2abed2d6.html"/>
    <id>http://fushenghua.github.io/archives/2abed2d6.html</id>
    <published>2016-04-09T03:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.625Z</updated>
    
    <content type="html"><![CDATA[<p>在前几篇文章中都是讲的基础，大家应该会觉得非常熟悉，但往往我们可能对于基础某些细节认识不够彻底或贯穿不全，我一直认为基础都是比较难的，那么本章节终于到进阶啦，主要讲的是View 的相关知识，在前面<a href="http://blog.csdn.net/vfush/article/details/51534916" target="_blank" rel="external">《Android 面试题总结之Android 基础 (六)》
</a>中已经对View有了一定的了解，由于内容较多且也是<strong>面试必考题</strong>，所以将分两篇继续深入的理解View。</p>
<blockquote>
<p>在阅读过程中有任何问题，请及时联系。如需转载请注明 <a href="http://blog.csdn.net/vfush" target="_blank" rel="external">fuchenxuan de Blog</a><br>  本章系<a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external">《Android 之美 从0到1 – 高手之路》</a>Android进阶（一）自定义View的过程</p>
</blockquote>
<p>[TOC]</p>
<h1 id="掌握"><a href="#掌握" class="headerlink" title="掌握"></a>掌握</h1><ol>
<li>什么是View?</li>
<li>View 坐标的基本概念</li>
<li>View的生命周期</li>
<li>如何自定义View</li>
</ol>
<h1 id="什么是View"><a href="#什么是View" class="headerlink" title="什么是View?"></a>什么是View?</h1><p>android.app.View 就是手机的UI，View 负责绘制UI，处理事件(evnet),Android 利用 View 打造出所 Widgets，利用 Widget 可打造出互动式的使用者介面，每个View 负责一定区域的绘制。</p>
<p>一张图理解常用控件层级关系</p>
<p><img src="http://img.blog.csdn.net/20160608135802023" alt="这里写图片描述"></p>
<h1 id="View-坐标的基本概念"><a href="#View-坐标的基本概念" class="headerlink" title="View 坐标的基本概念"></a>View 坐标的基本概念</h1><p>View的宽高是有top、left、right、bottom参数决定的 而X，Y和translationX，和translationY则负责View位置的改变。</p>
<blockquote>
<p>从Android3.0开始，加入了translation的概念，即相对于父容器的偏移量以及X,Y坐标的概念，X,Y代表左上顶点的横纵坐标。当View在发生平移时，getX，getY，setX，setY<br>get/setTranslationX/Y来获得当前左上点的坐标。</p>
</blockquote>
<p>X=left+translationX Y同理。<br>注意：在View发生改变的过程中，top，left等值代表原始位置，是不会改变的。改变的只有X,Y，translationX/Y。  </p>
<p>一张图理解View的坐标概念<br><img src="http://img.blog.csdn.net/20160608162836872" alt="这里写图片描述"></p>
<h1 id="View的生命周期"><a href="#View的生命周期" class="headerlink" title="View的生命周期"></a>View的生命周期</h1><table>
<thead>
<tr>
<th>Category</th>
<th style="text-align:center">Methods</th>
<th style="text-align:right">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Creation</td>
<td style="text-align:center">Constructors</td>
<td style="text-align:right">几个View的构造函数</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onFinishInflate(" target="_blank" rel="external">onFinishInflate()</a>)</td>
<td style="text-align:right">当系统解析完View之后调用onFinishInflate方法</td>
</tr>
<tr>
<td>Layout</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onMeasure(int,%20int" target="_blank" rel="external">onMeasure(int, int)</a>)</td>
<td style="text-align:right">确定所有子View的大小</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int" target="_blank" rel="external">onLayout(boolean, int, int, int, int)</a>)</td>
<td style="text-align:right">当ViewGroup分配所有的子View的大小和位置时触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onSizeChanged(int,%20int,%20int,%20int" target="_blank" rel="external">onSizeChanged(int, int, int, int)</a>)</td>
<td style="text-align:right">当view的大小发生变化时触发</td>
</tr>
<tr>
<td>Drawing</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onDraw(android.graphics.Canvas" target="_blank" rel="external">onDraw(android.graphics.Canvas)</a>)</td>
<td style="text-align:right">view渲染内容的细节</td>
</tr>
<tr>
<td>Event processing</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onKeyDown(int,%20android.view.KeyEvent" target="_blank" rel="external">onKeyDown(int, KeyEvent)</a>)</td>
<td style="text-align:right">有按键按下后触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onKeyUp(int,%20android.view.KeyEvent" target="_blank" rel="external">onKeyUp(int, KeyEvent)</a>)</td>
<td style="text-align:right">有按键按下后弹起时触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onTrackballEvent(android.view.MotionEvent" target="_blank" rel="external">onTrackballEvent(MotionEvent)</a>)</td>
<td style="text-align:right">轨迹球事件</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onTouchEvent(android.view.MotionEvent" target="_blank" rel="external">onTouchEvent(MotionEvent)</a>)</td>
<td style="text-align:right">触屏事件</td>
</tr>
<tr>
<td>Focus</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onFocusChanged(boolean,%20int,%20android.graphics.Rect" target="_blank" rel="external">onFocusChanged(boolean, int, android.graphics.Rect)</a>)</td>
<td style="text-align:right">当View获取或失去焦点时触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onWindowFocusChanged(boolean" target="_blank" rel="external">onWindowFocusChanged(boolean)</a>)</td>
<td style="text-align:right">当窗口包含的view获取或失去焦点时触发</td>
</tr>
<tr>
<td>Attaching</td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onAttachedToWindow(" target="_blank" rel="external">onAttachedToWindow()</a>)</td>
<td style="text-align:right">当view被附着到一个窗口时触发</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onAttachedToWindow(" target="_blank" rel="external">onDetachedFromWindow()</a>)</td>
<td style="text-align:right">当view离开附着的窗口时触发，该方法和  onAttachedToWindow() 是相反</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><a href="http://developer.android.com/reference/android/view/View.html#onWindowVisibilityChanged(int" target="_blank" rel="external">onWindowVisibilityChanged(int)</a>)</td>
<td style="text-align:right">当窗口中包含的可见的view发生变化时触发</td>
</tr>
</tbody>
</table>
<p>对实现自定义View，不需要重写所有这些方法。事实上，你可以只<a href="https://developer.android.com/reference/android/view/View.html#onDraw(android.graphics.Canvas" target="_blank" rel="external">onDraw(android.graphics.Canvas)</a>)</p>
<h2 id="View-的几个构造函数"><a href="#View-的几个构造函数" class="headerlink" title="View 的几个构造函数"></a>View 的几个构造函数</h2><ul>
<li><p><code>public MyView(Context context)</code><br>java代码直接new一个Custom View实例的时候,会调用第一个构造函数</p>
</li>
<li><p><code>public MyView(Context context, AttributeSet attrs)</code><br>在xml创建但是没有指定style的时候被调用.多了一个AttributeSet类型的参数，自定义属性，在通过布局文件xml创建一个view时，会把XML内的参数通过AttributeSet带入到View内。</p>
</li>
<li><p><code>public MyView(Context context, AttributeSet attrs, int defStyleAttr)</code><br>构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，且只有在明确调用的时候才会调用</p>
</li>
<li><p><code>@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public MyView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)</code><br>该构造函数是在api21的时候才添加上的</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160607171836507" alt="http://blog.csdn.net/vfush"></p>
<h2 id="View-的几个重要方法"><a href="#View-的几个重要方法" class="headerlink" title="View 的几个重要方法"></a>View 的几个重要方法</h2><ul>
<li><p>requestLayout<br>View重新调用一次layout过程</p>
</li>
<li><p>invalidate<br>View重新调用一次draw过程</p>
</li>
<li><p>forceLayout<br>标识View在下一次重绘，需要重新调用layout过程。</p>
</li>
<li><p>postInvalidate<br>这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。</p>
</li>
</ul>
<h1 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h1><h2 id="简单理解View的绘制"><a href="#简单理解View的绘制" class="headerlink" title="简单理解View的绘制"></a>简单理解View的绘制</h2><p>这里我们先简单理解View 的绘制，后续文章我们会深入理解。<br>1.测量——onMeasure()：决定View的大小</p>
<p>2.布局——onLayout()：决定View在ViewGroup中的位置</p>
<p>3.绘制——onDraw()：如何绘制这个View。</p>
<p><img src="http://img.blog.csdn.net/20160608141154933" alt="这里写图片描述"></p>
<h2 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h2><ul>
<li>继承View</li>
<li>继承ViewGroup</li>
<li>继承系统控件(Button,LinearLayout…)</li>
</ul>
<h2 id="自定义View的过程"><a href="#自定义View的过程" class="headerlink" title="自定义View的过程"></a>自定义View的过程</h2><ol>
<li><p>自定义 View 首先要实现一个继承自 View 的类</p>
</li>
<li><p>添加类的构造方法,通常是三个构造方法,不过从 Android5.0 开始构造方法已经添加到 4 个了</p>
</li>
<li><p><code>override</code> 父类的方法,如 <code>onDraw,(onMeasure)</code>等</p>
</li>
<li><p>自定义属性，需要在 values 下建立 <code>attrs.xml</code> 文件,在其中定义属性</p>
<blockquote>
<p>通过context.obtainStyledAttributes将构造函数中的attrs进行解析出来,就可以拿到相对应的属性.<br>TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView);<br>mColor = typedArray.getColor(R.styleable.MyView_myColor, 0XFF00FF00);  </p>
<p><strong>【注意】</strong>三个函数获取尺寸的区别：<br><strong><code>getDimension()</code></strong>是基于当前DisplayMetrics进行转换，获取指定资源id对应的尺寸<br><strong><code>getDimensionPixelSize()</code></strong>与<strong><code>getDimension()</code></strong>功能类似，不同的是将结果转换为int，并且小数部分四舍五入<br><strong><code>getDimensionPixelOffset()</code></strong>与<strong><code>getDimension()</code></strong>功能类似，不同的是将结果转换为int，取整去除小数。举个例子<br>列如<strong><code>getDimension()</code></strong>返回结果是20.5f，那么<strong><code>getDimensionPixelSize()</code></strong>返回结果就是 21，<strong><code>getDimensionPixelOffset()</code></strong>返回结果就是20。</p>
</blockquote>
</li>
<li><p>打开布局文件我们可以看到有很多的以xmlns开头的字段。其实这个就是XML name space 的缩写。我们可以使用<code>res-atuo</code>命名空间,就不用在添加自定义View全类名。<br><code>xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by fuchenxuan on 16/6/4.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mRadius=<span class="number">200</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mColor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line">        <span class="comment">//read custom attrs</span></div><div class="line">        TypedArray t = context.obtainStyledAttributes(attrs,</div><div class="line">                R.styleable.rainbowbar, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">       mRadius = t.getDimensionPixelSize(R.styleable.coutom_radius, (<span class="keyword">int</span>) hSpace);</div><div class="line">        t.getDimensionPixelOffset(R.styleable.coutom_at1, (<span class="keyword">int</span>) vSpace);</div><div class="line">   		mColor=t.getColor(R.styleable.color, barColor);</div><div class="line">        t.recycle();   <span class="comment">// we should always recycle after used</span></div><div class="line">     </div><div class="line">     </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="comment">//super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span></div><div class="line">         <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">        <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="comment">//set size</span></div><div class="line">        setMeasuredDimension(widthMode == MeasureSpec.AT_MOST ? (<span class="keyword">int</span>) mRadius * <span class="number">3</span> : widthSize, heightMode == MeasureSpec.AT_MOST ? (<span class="keyword">int</span>) mRadius * <span class="number">3</span> : heightSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//draw be invoke clire.</span></div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="comment">//super.onDraw(canvas);</span></div><div class="line"> 	     mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mPaint.setColor(mColor);</div><div class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);</div><div class="line">		 canvas.drawCircle(mRadius, mRadius, mRadius, mPaint);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是一个普通的自定义View，里面画了圆，根据不同的模式设置了父View的大小。</p>
<p><strong>关于View重写<code>onMeasure()</code>时机</strong>：<br>如果用了<code>wrap_content</code>。那么在<code>onMeasure()</code>中就要调用<code>setMeasuredDimension()</code>，<br>来指定view的宽高。如果使用的是<code>match_parent</code>或者一个具体的dp值。那么直接使用<code>super.onMeasure()</code>即可。</p>
<h2 id="自定义ViewGroup"><a href="#自定义ViewGroup" class="headerlink" title="自定义ViewGroup"></a>自定义ViewGroup</h2><h2 id="自定义ViewGroup的过程"><a href="#自定义ViewGroup的过程" class="headerlink" title="自定义ViewGroup的过程"></a>自定义ViewGroup的过程</h2><ol>
<li>自定义 ViewGroup 和自定义View 一样，只是继承自 ViewGroup 的类，和必须实现<code>onLayout()</code>函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * Created by fuchenxuan on 16-6-6.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CostumViewGroup</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CostumViewGroup</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CostumViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">            View childView = getChildAt(i);</div><div class="line">            measureChild(childView, widthMeasureSpec, heightMeasureSpec);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (changed) &#123;</div><div class="line">            <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">                View childView = getChildAt(i);</div><div class="line">                childView.layout(i * childView.getMeasuredWidth(), <span class="number">0</span>, (i + <span class="number">1</span>) * childView.getMeasuredWidth(), childView.getMeasuredHeight());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是一个简单的自定义ViewGroup，实现类似LinearLayout 横向排放子View位置。这就是一个简单的ViewGroup过程。</p>
<h3 id="彻底理解MeasureSpec三种模式"><a href="#彻底理解MeasureSpec三种模式" class="headerlink" title="彻底理解MeasureSpec三种模式"></a>彻底理解MeasureSpec三种模式</h3><p>View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。他们是由 mode+size两部分组成的。widthMeasureSpec和heightMeasureSpec转化成二进制数字表示，他们都是30位的。前两位代表mode(测量模 式)，后面28位才是他们的实际数值（size）;<code>MeasureSpec.getMode()</code>获取模式,<code>MeasureSpec.getSize()</code>获取尺寸<br>测量View大小使用的是onMeasure函数，所以我们需要了解三种测量模式：  </p>
<ul>
<li><code>EXACTLY</code>：一般是设置了明确的值（100dp）或者是<code>MATCH_PARENT</code></li>
<li><code>AT_MOST</code>：表示子布局限制在一个最大值内，一般为<code>WARP_CONTENT</code></li>
<li><code>UNSPECIFIED</code>：表示子布局想要多大就多大，很少使用</li>
</ul>
<p><strong>关于ViewGroup重写<code>onMeasure()</code>时机</strong>：</p>
<ul>
<li><p>首先要先测量子View的宽高:<br><code>getChildAt(int index)</code>可以拿到index上的子view。<br><code>getChildCount()</code>得到子view的个数，再循环遍历出子view。</p>
</li>
<li><p>使用子view自身的测量方法<br>childView.measure(int wSpec, int hSpec); </p>
<p>或<strong>使用viewGroup的测量子view的方法</strong>：</p>
<ul>
<li><p><code>measureChild(subView, int wSpec, int hSpec);</code><br>测量某一个子view，多宽，多高, 内部加上了viewGroup的padding值</p>
</li>
<li><p><code>measureChildren(int wSpec, int hSpec);</code><br>测量所有子view 都是 多宽，多高, 内部调用了measureChild方法    </p>
</li>
<li><code>measureChildWithMargins(subView, intwSpec, int wUsed, int hSpec, int hUsed);</code>测量某一个子view，多宽，多高, 内部加上了viewGroup的padding值、margin值和传入的宽高wUsed、hUsed </li>
</ul>
</li>
</ul>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ol>
<li><p><strong>getWidth()和getMeasuredWidth()的区别？</strong><br>getMeasuredWidth()：只要一执行完 setMeasuredDimension() 方法，就有值了，并且不再改变。<br>getWidth()：必须执行完 onMeasure() 才有值，可能发生改变。<br>如果 onLayout 没有对子 View 实际显示的宽高进行修改，那么 getWidth() 的值 == getMeasuredWidth() 的值。</p>
</li>
<li><p><strong>onLayout() 和Layout()的区别？</strong><br>onLayout() ViewGroup中子View的布局方法，layout()是子View布局的方法</p>
</li>
<li><p><strong>View 里面的 onSavedInstanceState和onRestoreInstanceState的作用？</strong><br>View和Activity一样的，每个View都有onSavedInstanceState和onRestoreInstanceState这两个方法，可用于保存和恢复view的状态。</p>
</li>
</ol>
<p>   在本章节中我们知道什么是View?，View 坐标的基本概念，理解了View的生命周期，学习了如何自定义View？虽然全是理论知识总结，在后续我们会一起来自定义View的实战学习。不管有没有任何疑问，欢迎在下方留言吧。</p>
<p> 更多Android 面试题总结，请点击下方图片哦。</p>
<blockquote>
<p>水平有限，若有错漏，欢迎指正，批评，如需转载，请注明出处–<a href="http://blog.csdn.net/vfush" target="_blank" rel="external">http://blog.csdn.net/vfush</a>，谢谢！<br><a href="http://blog.csdn.net/vfush/article/details/51508098" target="_blank" rel="external"><img src="http://img.blog.csdn.net/20160608162227307" alt="这里写图片描述"></a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前几篇文章中都是讲的基础，大家应该会觉得非常熟悉，但往往我们可能对于基础某些细节认识不够彻底或贯穿不全，我一直认为基础都是比较难的，那么本章节终于到进阶啦，主要讲的是View 的相关知识，在前面&lt;a href=&quot;http://blog.csdn.net/vfush/art
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>给我们的apk应用瘦身计划</title>
    <link href="http://fushenghua.github.io/archives/6412bd09.html"/>
    <id>http://fushenghua.github.io/archives/6412bd09.html</id>
    <published>2015-09-11T03:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.622Z</updated>
    
    <content type="html"><![CDATA[<h4 id="现在apk越来越大，原因有如下几个："><a href="#现在apk越来越大，原因有如下几个：" class="headerlink" title="现在apk越来越大，原因有如下几个："></a>现在apk越来越大，原因有如下几个：</h4><ul>
<li>1.多dpi支持([l|m|tv|h|x|xx|xxx]dpi)</li>
<li>2.Android开发工具和生态系统的发展</li>
<li>3.为了提高用户体验的高分辨率ui设计</li>
<li>4.无用代码,重复类库的编译</li>
</ul>
<p>随着项目的开发，项目体积不断增长，应用体积也变大了许多,会让很多用户会放弃安装，为了给apk瘦身,翻阅了大片文章,总结一下自己在开发中的经验</p>
<p>我们从一下几个方面去解决:</p>
<ul>
<li>开发阶段代码优化:<br>优化查错瘦身神器之android lint<br>运行Proguard： proguard能够便利你所有的代码路径，把没有用到的代码重apk中剔除。并且能够重命名变量，尽量精简你的代码；<br>使用Lint： 上面的proguard只是分析Java代码。lint工具能够分析你资源文件（/res），使用./gradlew lint就能够检测出没有用的资源文件；</li>
</ul>
<p>什么是ProGuard工具？</p>
<p>ProGuard是android提供的一个免费的工具，它能够移除工程中一些没用的代码，或者使用语义上隐晦的名称来重命名代码中的类、字段和函数等，达到压缩、优化和混淆代码的功能。具体来说，使用ProGuard工具，可以达到下面两个目的：<br>删除了源文件中没有调用的那部分代码，最大化的精简了字节码文件，使得最终生成的apk文件更小。<br>使用语义混淆的命名替换了代码中的类、字段和函数等，使得其他人无法反编译获取源代码，起到对代码的保护作用。</p>
<h4 id="add-Library和add-jars的区别"><a href="#add-Library和add-jars的区别" class="headerlink" title="add Library和add jars的区别?"></a>add Library和add jars的区别?</h4><p>在android项目中调用一些方法需要第三方的jar包，我们习惯做法是在android项目文件夹根目录下加一个lib文件并添加诸如.jar的文件，然后在右击该android项目，点属性(Properties),配置android,Java Build Path等。对于添加的jar文件，我们都是点 add External jars 或者 add jars，目前我还没发现两者的区别。<br>但是如果这样添加，会导致apk包增大至少2M以上，我用的办法是 添加add Library,选择User Library，如果有现成调用过的jar直接选择添加，如果没有则新建后添加，这样生成的apk比原来会减小很多。一般只有几百k左右。</p>
<ul>
<li>使用webP图片格式：</li>
<li>只用一种图片xhdpi</li>
<li>只用一张xhdpi图片放到xhdpi目录时，所有的屏幕密度都能很好的适配， android系统会自动的对你的图片进行缩放， 不用为每个密度都切一版图片的， 经过实际验证我也发现确实是这样的， 于是我将hdpi下的所有和xhdpi目录有重复的图片全部删除掉。 这样下来应用就减少了将近2M ！<br>so库压缩</li>
<li>项目中使用了室内定位功能，，编译成so直接打包在apk里以jni方式调用。 我相信有不少应用对于注重性能或者功能复用的模块都使用了jni方式，带来的问题就是so经常成为apk体积膨胀的一大因素， 以这个室内定位库为例， so文件就有整整8MB。为了适配armeabi和armeabi-v7a两种机型，这个库必须在libs/armeabi目录和libs/armeabi-v7a两个文件夹下各放一份。否则有可能在某种CPU类型的机器上运行出现初始化连接异常（因为找不到so库引起的）。</li>
<li>将so库使用zip压缩，可以压缩到50%~60%，然后 后只放一份到res/raw目录， 在代码里实现： 如果程序是第一次运行，则获取到raw下这个zip文件的输入流，然后将其解压到/data/data/com.xxx.xxx/lib_xxx目录， lib_xxx为你自己建的目录， 然后使用System.load加载库，而不要使用System.loadLibrary.， 这样指定路径加载肯定不会出现找不到so的问题。</li>
</ul>
<ul>
<li><p>项目构建优化:<br> 参考我的Android studio gradle 配置文章中,构建项目的时候,只编译所用代码,自动移除无用资源.</p>
</li>
<li><p>资源文件瘦身:<br>图片资源的优化原则是：在不降低图片效果、保证APK显示效果的前提下缩小图片文件的大小。<br>使用tinypng优化大部分图片资源：<a href="https://tinypng.com/" target="_blank" rel="external">https://tinypng.com/</a></p>
</li>
</ul>
<p>未完待续……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;现在apk越来越大，原因有如下几个：&quot;&gt;&lt;a href=&quot;#现在apk越来越大，原因有如下几个：&quot; class=&quot;headerlink&quot; title=&quot;现在apk越来越大，原因有如下几个：&quot;&gt;&lt;/a&gt;现在apk越来越大，原因有如下几个：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
      <category term="优化" scheme="http://fushenghua.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装Android Studio</title>
    <link href="http://fushenghua.github.io/archives/89bbc27f.html"/>
    <id>http://fushenghua.github.io/archives/89bbc27f.html</id>
    <published>2015-09-11T03:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.619Z</updated>
    
    <content type="html"><![CDATA[<pre><code>实在是不喜欢使用Windows了，时间长了就变得卡顿，还是喜欢Linux的文件系统不会像Windows的文件系统一样产生碎片化严重、
</code></pre><p>用Linux开发Android 感觉太好了，Android Studio 美观，编译速度也快，终端好用。这里我使用的是Ubuntu 安装Android Studio<br>非常方便。</p>
<p>##1.百度网盘Android Studio 资源<br>Android集成环境 NDK JDK 总链接 : <a href="http://pan.baidu.com/s/1bnjaDKb" target="_blank" rel="external">http://pan.baidu.com/s/1bnjaDKb</a>;</p>
<p>Android Studio Linux版 : <a href="http://pan.baidu.com/s/1eQjA6MA" target="_blank" rel="external">http://pan.baidu.com/s/1eQjA6MA</a> ;</p>
<p>Adt Bundle windows 64位版 : <a href="http://pan.baidu.com/s/1bnvlVnL" target="_blank" rel="external">http://pan.baidu.com/s/1bnvlVnL</a>;</p>
<p>Adt Bundle Linux 32位版 : <a href="http://pan.baidu.com/s/1jG41dI2" target="_blank" rel="external">http://pan.baidu.com/s/1jG41dI2</a>;</p>
<p>Adt Bundle Linux 64位版  : <a href="http://pan.baidu.com/s/1dDxjHXv" target="_blank" rel="external">http://pan.baidu.com/s/1dDxjHXv</a>;</p>
<p>NDK Linux 32位 : <a href="http://pan.baidu.com/s/1eQtJVe6" target="_blank" rel="external">http://pan.baidu.com/s/1eQtJVe6</a>;</p>
<p>NDK Linux 64位 : <a href="http://pan.baidu.com/s/1bnvRRJL" target="_blank" rel="external">http://pan.baidu.com/s/1bnvRRJL</a>;</p>
<p>NDK Windows 32位 : <a href="http://pan.baidu.com/s/1eQzj9iq" target="_blank" rel="external">http://pan.baidu.com/s/1eQzj9iq</a>;</p>
<p>##2.下载安装JDK<br>第一:</p>
<figure class="highlight plain"><figcaption><span>Ubuntu 中使用 PPA 安装 Java 8 ( 支持 Ubuntu 10.04 - Ubuntu 14.04 ):</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sudo add-apt-repository ppa:webupd8team/java</div><div class="line"></div><div class="line">sudo apt-get update</div><div class="line"></div><div class="line">sudo apt-get install Oracle-java8-installer</div><div class="line"></div><div class="line">完成之后可以通过以下命令来查看版本：</div><div class="line"></div><div class="line">javac -version</div><div class="line"></div><div class="line">安装 Java 8 需要接受许可，如果你想自动安装，那么可以在安装之前运行：</div><div class="line"></div><div class="line">echo oracle-java8-installer shared/accepted-oracle-license-v1-1 select true | sudo /usr/bin/debconf-set-selections</div><div class="line"></div><div class="line">设置 Java 8 环境变量：</div><div class="line"></div><div class="line">sudo apt-get install oracle-java8-set-default</div><div class="line"></div><div class="line">切换为 Java 7 ：</div><div class="line"></div><div class="line">sudo update-java-alternatives -s java-7-oracle</div><div class="line"></div><div class="line">再切换为 Java 8：</div><div class="line"></div><div class="line">sudo update-java-alternatives -s java-8-oracle</div></pre></td></tr></table></figure>
<p>##3.测试</p>
<p>打开一个终端，输入下面命令：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -<span class="built_in">version</span></div></pre></td></tr></table></figure>
<p>显示结果：</p>
<p>java version “1.7.0_05”<br>Java(TM) SE Runtime Environment (build 1.7.0_05-b05)</p>
<p>Java HotSpot(TM) Server VM (build 23.1-b03, mixed mode)</p>
<p>这表示java命令已经可以运行了。</p>
<p>##4.安装Android Studio<br>上面网盘的资源</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、下载<span class="keyword">android </span>studio包<span class="keyword">android-studio-bundle-133.970939-linux.tgz</span></div><div class="line">解压：$ sudo tar zxvf <span class="keyword">android-studio-bundle-133.970939-linux.tgz</span></div><div class="line">解压后文件夹名为<span class="keyword">android-studio。</span></div><div class="line">移动：$ sudo mv <span class="keyword">android-studio </span>/<span class="meta">opt</span>/</div><div class="line">打开文件夹：$ cd /<span class="meta">opt</span>/<span class="keyword">android-studio/bin/</span></div><div class="line">运行：$ sudo studio.sh</div><div class="line"><span class="symbol">oh</span> shit，提示命令不存在，怎么回事？额，恩，不是这么打的吧？！</div><div class="line">再次运行：$ sudo ./studio.sh</div><div class="line"><span class="symbol">OK</span>，打开了。固定到任务栏方便以后打开</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;实在是不喜欢使用Windows了，时间长了就变得卡顿，还是喜欢Linux的文件系统不会像Windows的文件系统一样产生碎片化严重、
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用Linux开发Android 感觉太好了，Android Studio 美观，编译速度也快
    
    </summary>
    
      <category term="linux" scheme="http://fushenghua.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://fushenghua.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用Android Studio Gradle 构建、打包、发布项目</title>
    <link href="http://fushenghua.github.io/archives/c8dd37ec.html"/>
    <id>http://fushenghua.github.io/archives/c8dd37ec.html</id>
    <published>2015-08-12T03:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.615Z</updated>
    
    <content type="html"><![CDATA[<p>Gradle其他好处就不多说，在android应用发布的时候，如果要统计多个渠道，gradle 批量打包的好处就显示出来了,发现确实比Ant打包会方便很多,就说下本篇Gradle作用吧</p>
<p>主要功能：<br>多渠道自动打包<br>beta /debug/relese /多版本打包<br>dex突破65535的限制<br>打包自动命名，提交测试时方便识别，不用每次打包测试 ，重命名啦！<br>自动移除程序LOG_DEBUG调试<br>自动移除无用资源文件，为APK瘦身<br>混淆代码<br>更多强大功能探索中……</p>
<p>Gradle 基本概念</p>
<p>首先我们学习几个gradle 的脚步语法，掌握了这几个语法，你就能非常简单的用gradle构建打包android项目了。 首先，我们来看下一个最简单android build.gradle。</p>
<p>apply plugin: ‘android’//声明构建的项目类型，这里当然是android了<br>buildscript{} //设置脚本的运行环境<br>repositories{}支持java 依赖库管理（maven/ivy）,用于项目的依赖<br>dependencies{}//依赖包的定义。支持maven/ivy，远程，本地库，也支持单文件<br>android{}编译android项目的参数</p>
<p>废话不多说，来一份我在项目中使用的完整的gradle文件配置吧：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    compileSdkVersion <span class="number">22</span></div><div class="line">    buildToolsVersion <span class="string">"22.0.1"</span></div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId <span class="string">"com.rtmap.sample"</span></div><div class="line">        minSdkVersion <span class="number">9</span></div><div class="line">        targetSdkVersion <span class="number">22</span></div><div class="line">        versionCode <span class="number">10</span></div><div class="line">        versionName <span class="string">"1.3"</span></div><div class="line">        <span class="comment">// dex突破65535的限制</span></div><div class="line">              multiDexEnabled <span class="keyword">true</span></div><div class="line">        manifestPlaceholders = [channel_param: <span class="string">"official"</span>]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="comment">//----begin  是为了兼容Eclipse 可忽略</span></div><div class="line">    <span class="keyword">sourceSets</span> &#123;</div><div class="line">        main &#123;</div><div class="line">            manifest.srcFile <span class="string">'AndroidManifest.xml'</span></div><div class="line">            java.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            resources.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            aidl.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            renderscript.srcDirs = [<span class="string">'src'</span>]</div><div class="line">            res.srcDirs = [<span class="string">'res'</span>]</div><div class="line">            assets.srcDirs = [<span class="string">'assets'</span>]</div><div class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">//----end  </span></div><div class="line"></div><div class="line">    buildTypes &#123;</div><div class="line"></div><div class="line">        release &#123;</div><div class="line">            <span class="comment">// 不显示Log</span></div><div class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span></div><div class="line"></div><div class="line">            minifyEnabled <span class="keyword">true</span></div><div class="line">            zipAlignEnabled <span class="keyword">true</span></div><div class="line">            <span class="comment">// 移除无用的resource文件</span></div><div class="line">            shrinkResources <span class="keyword">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line"><span class="comment">//            signingConfig signingConfigs.release</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        beta &#123;</div><div class="line">            <span class="comment">// 不显示Log</span></div><div class="line"><span class="comment">//            buildConfigField "boolean", "LOG_DEBUG", "false"</span></div><div class="line">            versionNameSuffix <span class="string">"-beta"</span></div><div class="line"><span class="comment">//            minifyEnabled true</span></div><div class="line">            zipAlignEnabled <span class="keyword">true</span></div><div class="line">            <span class="comment">// 移除无用的resource文件</span></div><div class="line">            minifyEnabled <span class="keyword">true</span></div><div class="line">            shrinkResources <span class="keyword">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line"><span class="comment">//            signingConfig signingConfigs.release</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        debug &#123;</div><div class="line">            versionNameSuffix <span class="string">"-debug"</span></div><div class="line">            zipAlignEnabled <span class="keyword">true</span></div><div class="line">            <span class="comment">// 移除无用的resource文件</span></div><div class="line">            shrinkResources <span class="keyword">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line"><span class="comment">//            signingConfig signingConfigs.release</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        applicationVariants.all &#123; variant -&gt;</div><div class="line">            variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</div><div class="line">                <span class="keyword">def</span> outputFile = output.outputFile</div><div class="line">                <span class="keyword">if</span> (variant.buildType.name.equals(<span class="string">'release'</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</div><div class="line">                        <span class="comment">// erdoushop_v1.1_release_201508101027</span></div><div class="line">                        <span class="keyword">def</span> fileName = <span class="string">"erdoushop_v$&#123;defaultConfig.versionName&#125;_release_$&#123;getDate()&#125;.apk"</span></div><div class="line">                        output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (variant.buildType.name.equals(<span class="string">'beta'</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</div><div class="line">                        <span class="comment">// erdoushop_v1.1_beta_201508101027</span></div><div class="line">                        <span class="keyword">def</span> fileName = <span class="string">"erdoushop_v$&#123;defaultConfig.versionName&#125;_beta_$&#123;getDate()&#125;.apk"</span></div><div class="line">                        output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">def</span> getDate() &#123;</div><div class="line">    <span class="keyword">def</span> date = <span class="keyword">new</span> Date()</div><div class="line">    <span class="keyword">def</span> formattedDate = date.format(<span class="string">'yyyyMMddHHmm'</span>)</div><div class="line">    <span class="keyword">return</span> formattedDate</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文章目前只讲到了打包，时间喘促，先写到这里，最近都比较忙，没时间写博客，后期博客会整理一下，现在就当作笔记一下 ，怕以后忘记了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gradle其他好处就不多说，在android应用发布的时候，如果要统计多个渠道，gradle 批量打包的好处就显示出来了,发现确实比Ant打包会方便很多,就说下本篇Gradle作用吧&lt;/p&gt;
&lt;p&gt;主要功能：&lt;br&gt;多渠道自动打包&lt;br&gt;beta /debug/reles
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解Handler原理</title>
    <link href="http://fushenghua.github.io/archives/158db06e.html"/>
    <id>http://fushenghua.github.io/archives/158db06e.html</id>
    <published>2015-07-13T04:23:32.000Z</published>
    <updated>2018-04-20T05:25:03.612Z</updated>
    
    <content type="html"><![CDATA[<p>Handler在Android开发中非常重要，最常见的使用场景就是在子线程需要更新UI，用Handler来投递消息到主线程执行UI更新操作。因为 Android系统的View是非线程安全的，所以需要在主线程更新UI。总的来说Handler就是用来做线程间通信，在不同线程之间传递消息。</p>
<p>注：这篇文章所讲到的Handler是在主线程创建的，主线程在开始的时候已经创建了默认的消息循环。后面的文章会讲如何创建自己的消息循环。<br>从图中可以看出，四种颜色分别代表了四个对象，并且大致描述了几个对象之间的关系，以及消息的流转过程，首先Handler通过sendMessage将消息投递给MessageQueue，Looper通过消息循环（loop）不断的从MessageQueue中取出消息，然后消息被Handler的dispatchMessage分发到handleMessage方法消费掉。<br>消息循环中涉及的重要对象</p>
<p>Handler</p>
<p>通过Handler的sendMessage等方法来投递消息到MessageQueue，通过handleMessage来消费Message。Handler必须要有一个已经prepare好的Looper对象，也就是说必须调用了prepare方法(也包括prepareMainLooper方法)，究其根本是初始化一个消息队列，这一过程将在下文中详细分析。</p>
<p>Looper</p>
<p>Looper负责从MessageQueue中取出消息，然后通过执行message.target.dispatchMessage()消费掉这个消息，这里的target就是Handler。</p>
<p>MessageQueue</p>
<p>消息队列，管理Handler投递过来的消息。</p>
<p>Message</p>
<p>用来承载数据的消息，最终被Handler消费掉。</p>
<p>UML类图分析</p>
<p>Handler class diagram</p>
<p>通过上面的类图可以清晰的了解各个类之间的关系。然后再来分析一下源码。<br>Handler的创建</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> Handler(Callback callback, boolean async) &#123;</div><div class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Handler</span>&gt; <span class="title">klass</span> = <span class="title">getClass</span>();</span></div><div class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">Log</span>.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span> Handler(Callback callback, boolean async) &#123;</div><div class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Handler</span>&gt; <span class="title">klass</span> = <span class="title">getClass</span>();</span></div><div class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">Log</span>.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面这段代码中，首先是检查是否存在潜在的内存泄漏，如果该类是匿名内部类，或者是成员类且没有static修饰符时那么打印一个内存泄漏风险警告。这是由于这种类型的class持有外部类的this引用，可能导致外部类无法释放。<br>接下来就是对成员变量mLooper赋值，在文章开头就提到过，这篇文章中提到的handler对象时在主线程（UI线程）中创建，而Android主线已经有一个消息队列了,所以直接将mLooper.mQueue赋给Handler的mQueue。<br>那么主线程中的消息队列是怎么创建的呢？</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        将looper对象装入ThreadLocal中，Handler就是从它里面取出looper对象的</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建消息队列</span></div><div class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        将looper对象装入ThreadLocal中，Handler就是从它里面取出looper对象的</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="comment">//创建消息队列</span></div><div class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面的关键代码，UI线程在创建的时候，会调用prepareMainLooper()这个方法，创建一个不退出的消息队列。所以prepareMainLooper这个方法自己永远也不要调用，它是系统调用的，如果我们需要用自己的消息队列呢？那么就应该调用prepare()方法。</p>
<p>消息怎么被消费的呢？</p>
<p>整个消息循环系统中的几个重要部件的创建都已经明白了，那么消息时怎么循环起来的，又是如何消费的呢？来看看下面是loop源码的一部分关键代码。代码非常简单易懂，就是从消息队列中取出消息，然后通过msg.target.dispatchMessage(msg)将消息投递到Handler。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            msg.<span class="keyword">target</span>.dispatchMessage(msg);</div><div class="line">            msg.recycleUnchecked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            msg.<span class="keyword">target</span>.dispatchMessage(msg);</div><div class="line">            msg.recycleUnchecked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">消息传递的终点</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当消息循环中取出的消息被再次传递给Handler的时候，这个消息就走到了生命的尽头(并不代表对象销毁，有一个消息池来回收消息)，从dispatchMessage方法可以看出，消息最终的归宿有三个，一是消息自身的callback接口，二是handler的callback接口，最后是handleMessage接口。<br>原文地址：<a href="http://vjson.com/wordpress/handler-looper%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" target="_blank" rel="external">http://vjson.com/wordpress/handler-looper%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</a><br>后面我们将继续分析Handler源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler在Android开发中非常重要，最常见的使用场景就是在子线程需要更新UI，用Handler来投递消息到主线程执行UI更新操作。因为 Android系统的View是非线程安全的，所以需要在主线程更新UI。总的来说Handler就是用来做线程间通信，在不同线程之间
    
    </summary>
    
      <category term="android" scheme="http://fushenghua.github.io/categories/android/"/>
    
    
      <category term="android" scheme="http://fushenghua.github.io/tags/android/"/>
    
  </entry>
  
</feed>
